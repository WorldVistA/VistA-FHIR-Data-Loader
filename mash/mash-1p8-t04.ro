pre-release version of Mash
GT.M 07-JUN-2018 23:29:12
%sfv2g
%sfv2g  ;ven/gpl-dataset format: vista to graph ;2018-02-11T14:06Z
 ;;1.8;Mash;
 ;
 ; %sfv2g implements the Dataset Format Library's apis for converting
 ; data from vista format to graphstore format.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development: see routine %wful
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-02-11T14:06Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Dataset Format - %sf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@module-credits
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-09-24 ven/gpl %*1.8t04 %sfv2g: create routine w/$$fmrec & fmx.
 ;
 ; 2018-02-05/11 ven/toad %*1.8t04 %sfv2g: passim hdr comments, spell out
 ; mumps language elements, add do-dot quits & white space, license &
 ; attribution.
 ;
 ;@to-do
 ; convert entry points to ppi/api style & put in %sf
 ; r/all local calls w/calls through ^%sf
 ; change branches from %sf
 ;
 ;@contents
 ; $$fmrec = extrinsic which returns the json version of the fmx return
 ; fmx: return an array of a fileman record for external
 ;
 ;
 ;
 ;@section 1 fmrec & fmx apis
 ;
 ;
 ;
fmrec(file,ien) ; extrinsic which returns the json version of the fmx return
 ;
 new %g,%gj
 do fmx("%g",file,ien)
 do ENCODE^VPRJSON("%g","%gj")
 ;
 quit %gj ; end of $$fmrec
 ;
 ;
 ;
fmx(rtn,file,ien,camel) ; return an array of a fileman record for external
 ;
 ; use in rtn, which is passed by name. 
 ;
 kill @rtn
 new trec,filenm
 do GETS^DIQ(file,ien_",","**","ENR","trec")
 set filenm=$order(^DD(file,0,"NM",""))
 set filenm=$translate(filenm," ","_")
 ; zwrite trec
 if $get(debug)=1 break
 new % set %=$query(trec(""))
 for  do  quit:%=""  ;
 . new fnum,fname,iens,field,val
 . set fnum=$qsubscript(%,1)
 . if $data(^DD(fnum,0,"NM")) do  ;
 . . set fname=$order(^DD(fnum,0,"NM",""))
 . . set fname=$translate(fname," ","_")
 . . quit
 . else  set fname=fnum
 . set iens=$qsubscript(%,2)
 . set field=$qsubscript(%,3)
 . set field=$translate(field," ","_")
 . set val=@%
 . if fnum=file do  ; not a subfile
 . . set @rtn@(fname,ien,field)=val
 . . set @rtn@(fname,"ien")=$piece(iens,",",1)
 . . quit
 . else  do  ;
 . . new i2 set i2=$order(@rtn@(fname,""),-1)+1
 . . set @rtn@(fname,$piece(iens,","),field)=val
 . . ; set @rtn@(fname,i2,field)=val
 . . ; set @rtn@(fname,i2,"iens")=iens
 . . quit
 . write:$get(debug)=1 !,%,"=",@%
 . set %=$query(@%)
 . quit
 ;
 quit  ; end of fmx
 ;
 ;
 ;
 ;example
 ;g("bsts_concept","codeset")=36
 ;g("bsts_concept","concept_id")=370206005
 ;g("bsts_concept","counter")=75
 ;g("bsts_concept","dts_id")=370206
 ;g("bsts_concept","fully_specified_name")="asthma limits walking on the flat (finding)"
 ;g("bsts_concept","last_modified")="may 11, 2015"
 ;g("bsts_concept","out_of_date")="no"
 ;g("bsts_concept","partial_entry")="non-patial (full entry)"
 ;g("bsts_concept","revision_in")="mar 01, 2012"
 ;g("bsts_concept","revision_out")="jan 01, 2050"
 ;g("bsts_concept","version")=20140901
 ;g("bsts_concept","ien")="75"
 ;g("is_a_relationship",1,"is_a_relationship")=2
 ;g("subsets",1,"subsets")="ehr ipl asthma dxs"
 ;g("subsets",2,"subsets")="srch cardiology"
 ;g("subsets",3,"subsets")="ihs problem list"
 ;
 ;
 ;
eor ; end of routine %sfv2g

%ts
%ts ;ven/toad-type string: api/ppi library ;2018-03-13T16:36Z
 ;;1.8;Mash;
 ;
 ; %ts is the Mumps String Library, an element of the Mumps
 ; Advanced Shell's Data Type Library. It collects all public
 ; application programmer interfaces in the Mumps String Library.
 ; Its APIs are implemented in other %ts* routines, none of which
 ; contains any public entry points.
 ; See %tsul for the module's primary-development log.
 ; See %tsud for documentation introducing the library.
 ; %ts contains public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-13T16:36Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@contents
 ; (all application programmer interfaces)
 ;
 ;
 ;
 ;@section 1 %tsc: string-case tools
 ;
 ;
 ;
 ;@API $$alphabet^%ts, abcdefghijklmnopqrstuvwxyz
alphabet() goto alphabet^%tsc
 ;
 ;@API $$ALPHABET^%ts, ABCDEFGHIJKLMNOPQRSTUVWXYZ
ALPHABET() goto ALPHABET^%tsc
 ;
 ;
 ;
 ;@API $$upcase^%ts, upper case (ALL CAPITAL LETTERS)
upcase(string) goto upcase^%tsc
 ;
 ;@API $$u^%ts, upper case
u(string) goto upcase^%tsc
 ;
 ;@API $$upperCase^%ts, upper case
upperCase(string) goto upcase^%tsc
 ;
 ;
 ;
 ;@API $$lowcase^%ts, lower case (no capital letters)
lowcase(string) goto lowcase^%tsc
 ;
 ;@API $$l^%ts, lower case
l(string) goto lowcase^%tsc
 ;
 ;@API $$lowerCase^%ts, lower case
lowerCase(string) goto lowcase^%tsc
 ;
 ;
 ;
 ;@API $$capcase^%ts, capital case (First Char Of Each Word Capital)
capcase(string) goto capcase^%tsc
 ;
 ;@API $$c^%ts, capital case
c(string) goto capcase^%tsc
 ;
 ;@API $$capitalCase^%ts, capital case
capitalCase(string) goto capcase^%tsc
 ;
 ;
 ;
 ;@API $$invcase^%ts, inverse case (uPPERS TO lOWERS & vice versa)
invcase(string) goto invcase^%tsc
 ;
 ;@API $$i^%ts, inverse case
i(string) goto invcase^%tsc
 ;
 ;@API $$inverseCase^%ts, inverse case
inverseCase(string) goto invcase^%tsc
 ;
 ;
 ;
 ;@API $$sencase^%ts, sentence case (1st character capital)
sencase(string) goto sencase^%tsc
 ;
 ;@API $$s^%ts, sentence case
s(string) goto sencase^%tsc
 ;
 ;@API $$sentenceCase^%ts, sentence case
sentenceCase(string) goto sencase^%tsc
 ;
 ;
 ;
 ;@section 2 %tse: string-extract tools
 ;
 ;
 ;
 ;@API findex^%ts, find extract (find position of substring)
findex(string,find,flags) goto findex^%tsef
 ;
 ;@API fe^%ts, find extract
fe(string,find,flags) goto findex^%tsef
 ;
 ;@API findExtract^%ts, find extract
findExtract(string,find,flags) goto findex^%tsef
 ;
 ;@API find^%ts, find extract
find(string,find,flags) goto findex^%tsef
 ;
 ;
 ;
 ;@API setex^%ts, set extract (change value of positional substring)
setex(string,replace,flags) goto setex^%tses
 ;
 ;@API se^%ts, set extract
se(string,replace,flags) goto setex^%tses
 ;
 ;@API setExtract^%ts, set extract
setExtract(string,replace,flags) goto setex^%tses
 ;
 ;@API place^%ts, set extract
place(string,replace,flags) goto setex^%tses
 ;
 ;
 ;
 ;@section 3 %tsf: string-find tools
 ;
 ;
 ;
 ;@ppi setfind^%ts, set find (find & replace substring)
setfind(string,find,replace,flags) goto setfind^%tsfs
 ;
 ;@ppi sf^%ts, set find
sf(string,find,replace,flags) goto setfind^%tsfs
 ;
 ;@ppi setFind^%ts, set find
setFind(string,find,replace,flags) goto setfind^%tsfs
 ;
 ;
 ;
 ;@ppi findReplace^%ts, simple substring find & replace
findReplace(string,find,replace,flags) goto findReplace^%tsfwr
 ;
 ;
 ;
 ;@ppi findReplaceAll^%ts, simple substring find & replace all
findReplaceAll(string,find,replace,flags) goto findReplaceAll^%tsfwra
 ;
 ;
 ;
 ;@section 4 %tsj: string-justify tools
 ;
 ;
 ;
 ;@API $$trim^%ts, trim character from end(s) of string
trim(string,end,char) goto trim^%tsjt
 ;
 ;
 ;
 ;@section 5 %tsv: string-validation tools
 ;
 ;
 ;
 ;@API $$strip^%ts, strip character(s) from string
strip(string,char) goto strip^%tsvs
 ;
 ;
 ;
eor ; end of routine %ts

%tsc
%tsc ;ven/toad-type string: case conversion ;2018-02-23T22:06Z
 ;;1.8;Mash;
 ;
 ; %tsc implements MASH String Library Case Conversion APIs.
 ; See %tsud for an introduction to the String library, including an
 ; intro to the String Replace library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsc contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-02-23T22:06Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@original-dev: R. Wally Fort (rwf)
 ;@original-dev-org: U.S. Department of Veterans Affairs
 ; prev. Veterans Administration
 ; National Development Office in San Francisco (vaisf)
 ;
 ;@to-do
 ; do multi-string versions [see JJOHCASE for examples]
 ; apply standard string-length protection consistently
 ; create unit tests for all of these subroutines
 ;
 ;@contents
 ; alphabet = code for API $$alphabet^%ts
 ;  abcdefghijklmnopqrstuvwxyz
 ; ALPHABET = code for API $$ALPHABET^%ts
 ;  ABCDEFGHIJKLMNOPQRSTUVWXYZ
 ; upcase = code for API $$upcase^%ts
 ;  CONVERT STRING TO UPPERCASE
 ; lowcase = code for API $$lowcase^%ts
 ;  convert string to lowercase
 ; capcase = code for API $$capcase^%ts
 ;  Convert String To Capitalized Case
 ; invcase = code for API $$invcase^%ts
 ;  iNVERT cASE (uPPERS TO lOWERS & lOWERS TO uPPERS)
 ; sencase = code for API $$sencase^%ts
 ;  Convert string to sentence-case
 ;
 ;
 ;
 ;@section 1 code
 ;
 ;
 ;
alphabet ; code for API $$alphabet^%ts, abcdefghijklmnopqrstuvwxyz
 ;
 ;ven/toad;private;variable;clean;silent;sac;NO tests;;100% tests
 ;@signature
 ; $$alphabet^%ts
 ;@branches-from
 ; $$alphabet^%ts
 ;@called-by
 ; $$upcase^%ts
 ; $$invcase^%ts
 ;@calls: none
 ;@inputs: none
 ;@output = abcdefghijklmnopqrstuvwxyz
 ;@tests: [tbd]
 ;
 quit "abcdefghijklmnopqrstuvwxyz" ; end of $$alphabet^%ts
 ;
 ;
 ;
ALPHABET ; code for API $$ALPHABET^%ts, ABCDEFGHIJKLMNOPQRSTUVWXYZ
 ;
 ;ven/toad;private;variable;clean;silent;sac;NO tests;100% tests
 ;@signature
 ;  $$ALPHABET^%ts
 ;@branches-from
 ; $$ALPHABET^%ts
 ;@called-by
 ; $$upcase^%ts
 ; $$invcase^%ts
 ;@calls: none
 ;@inputs: none
 ;@output = ABCDEFGHIJKLMNOPQRSTUVWXYZ
 ;@tests: [tbd]
 ;
 quit "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ; end of $$ALPHABET^%ts
 ;
 ;
 ;
upcase ; code for API $$upcase^%ts, CONVERT STRING TO UPPERCASE
 ;
 ;isf/rwf,ven/toad;private;function;clean;silent;sac;;100% tests
 ;@signature
 ; $$upcase^%ts(string)
 ;@branches-from
 ; $$upcase^%ts
 ;@called-by
 ; $$capcase^%ts
 ; $$sencase^%ts
 ;@calls
 ; $$ALPHABET^%ts
 ; $$alphabet^%ts
 ;@input
 ; string = string to convert
 ;@output = uppercase string
 ;@tests: [tbd]
 ;
 set string=$translate(string,$$alphabet^%ts,$$ALPHABET^%ts)
 ;
 quit string ; return uppercase string; end of $$upcase^%ts
 ;
 ;
 ;
lowcase ; code for API $$lowcase^%ts, convert string to lowercase
 ;
 ;isf/rwf,ven/toad;private;function;clean;silent;sac;100% tests
 ;@signature
 ; $$lowcase^%ts(string)
 ;@branches-from
 ; $$lowcase^%ts
 ;@called-by
 ; $$capcase^%ts
 ; $$sencase^%ts
 ;@calls
 ; $$ALPHABET^%ts
 ; $$alphabet^%ts
 ;@input
 ; string = string to convert
 ;@output = lowercase string
 ;@tests: [tbd]
 ;
 set string=$translate(string,$$ALPHABET^%ts,$$alphabet^%ts)
 ;
 quit string ; return lowercase string; end of $$lowcase^%ts
 ;
 ;
 ;
capcase ; code for API $$capcase^%ts, Convert String To Capitalized
 ;
 ;isf/rwf,ven/toad;private;function;clean;silent;sac;;100% tests
 ;@signature
 ; $$capcase^%ts(string)
 ;@branches-from
 ; $$capcase^%ts
 ;@called by: none
 ;@calls
 ; $$lowcase^%ts
 ; $$upcase^%ts
 ;@input
 ; string = string to convert
 ;@output = capitalized string
 ;@examples
 ;  write $$capcase^%ts("THIS IS CAPITALIZED. (this isn't.)")
 ; produces
 ;  This Is Capitalized. (This Isn't.)
 ;@tests: [tbd]
 ;
 ; Capitalized Case = first letter of each word uppercase, rest lower
 ;
 ; internal
 ;  up = convert next letter to uppercase?
 ;  %p = string-extract position
 ;  char = current character
 ;
 set string=$$lowcase^%ts(string) ; start with lowercase
 new up set up=1 ; flag to convert next letter to uppercase
 new %p ; position of each character
 for %p=1:1:$length(string) do  ; traverse string's characters
 . new char set char=$extract(string,%p) ; get each character
 . if up,char?1L do  ; if cap flag set & char is lc
 . . set $extract(string,%p)=$$upcase^%ts(char) ; convert lc to uc
 . . set up=0 ; and clear cap flag
 . . quit
 . if char?1P,char'="'" do  ; if punctuation but not apostrophe
 . . set up=1 ; set cap flag
 . . quit
 . quit
 ;
 quit string ; return capitalized string; end of $$capcase^%ts
 ;
 ;
 ;
invcase ; code for API $$invcase^%ts, iNVERT cASE (uPPERS TO lOWERS...
 ;
 ;kbaz/zag,ven/toad;private;function;clean;silent;sac;;100% tests
 ;@signature
 ; $$invcase^%ts(string)
 ;@branches-from
 ; $$invcase^%ts
 ;@called by: none
 ;@calls
 ; $$ALPHABET^%ts
 ; $$alphabet^%ts
 ;@input
 ; string = string to convert
 ;@output = inverse-cased string
 ;@examples
 ;  write $$invcase^%ts("tHIS iS cAPITALIZED. (tHIS iSN'T.)")
 ; produces
 ;  This Is Capitalized. (This Isn't.)
 ;@tests: [tbd]
 ;
 ; Inverted Case = lowers replaced with uppers, uppers with lowers
 ;
 new up set up=$$ALPHABET^%ts
 new low set low=$$alphabet^%ts
 new uplow set uplow=up_low
 new lowup set lowup=low_up
 set string=$translate(string,uplow,lowup)
 ;
 quit string ; return inverse-case string; end of $$invcase^%ts
 ;
 ;
 ;
sencase ; code for API $$sencase^%ts, Convert string to sentence case
 ;
 ;isf/rwf,ven/toad;private;function;clean;silent;sac;100% tests
 ;@signature
 ; $$sencase^%ts(string)
 ;@branches-from
 ; $$sencase^%ts
 ;@called by: none
 ;@calls
 ; $$lowcase^%ts
 ; $$upcase^%ts
 ;@input
 ; string = string to convert
 ;@output = sentence-case string
 ;@examples
 ;  write $$sencase^%ts("HELLO!!! THIS IS A SENTENCE. (this isn't.)")
 ; produces
 ;  Hello!!! This is a sentence. (This isn't.)
 ;@tests: [tbd]
 ;
 ; Sentence case = first letter of each sentence uppercase, rest lower
 ;
 ; internal
 ;  up = state flag (1 = next letter should be caps)
 ;  %p = string-extract position
 ;  char = current character
 ;
 set string=$$lowcase^%ts(string) ; start with lowercase
 new up set up=1 ; flag to convert next letter to uppercase
 new %p ; position of each character
 for %p=1:1:$length(string) do  ; traverse string's characters
 . new char set char=$extract(string,%p) ; get each character
 . if up,char?1L do  ; if cap flag set & char is lc
 . . set $extract(string,%p)=$$upcase^%ts(char) ; convert lc char to uc
 . . set up=0 ; and clear cap flag
 . . quit
 . if ".!?"[char do  ; if end-of-sentence, punctuation
 . . set up=1 ; set cap flag
 . . quit
 . quit
 ;
 quit string ; return sentence-case string; end of $$sencase^%ts
 ;
 ;
 ;
eor ; end of routine %tsc

%tsef
%tsef ;ven/toad-type string: findex^%ts ;2018-03-20T19:02Z
 ;;1.8;Mash;
 ;
 ; %tsef implements MASH String Library ppi findex^%ts, find substring;
 ; it is part of the String Extract Library.
 ; See %tsutef for unit tests for findex^%ts.
 ; Compare %tses to see how setex^%ts works with findex^%ts
 ; See %tsud for an introduction to the String Library, including an
 ; intro to the String Extract Library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsef contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-20T19:02Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@to-do
 ; add ability to scan backward
 ;  f or F = scan forward
 ; add ability to limit scan to w/in certain characters
 ;  scanfrom & scanto
 ; add ability to call by passing object
 ;  s or S = case-sensitive scan
 ;  call("case")
 ;  call("extract","from")
 ;  call("extract","to")
 ;  call("find")
 ;  call("find","low")
 ;  call("scan","from")
 ;  call("scan","to")
 ;  call("string")
 ;  call("string","low")
 ;  call("way")
 ; add feature to load object w/parameters for shorter calls
 ;  direction => call("direction"), 1 or -1
 ;  find=-1,to=-1 => call("way"), default to 1
 ;  find => call("find")
 ;  from => call("find","from")
 ;  to => call("find","to")
 ; apply standard string-length protection consistently
 ; create findm/findmsg to preload call-message array
 ;
 ; description of future call-message system
 ;
 ; The caller passes in a call message describing the scan to be
 ; performed. This can either be entirely passed as array nodes under
 ; the first parameter, or the caller may set other parameters in the
 ; list to ask findex^%ts to initialize the call message for the caller
 ; based on those values. Where the call message and listed parameters
 ; disagree, the parameters will override the call message, giving
 ; callers a simple mechanism for revising the call message on
 ; subsequent calls to findex^%ts.
 ;
 ; This new call-message system gives callers nuanced control over how
 ; findex^%ts performs the scan, via the call message, for complex scans,
 ; but it also gives one-time callers who want simple scans an easy-to-
 ; use multi-parameter format that can request most typical scans. Some
 ; more mature version of this system will spread to the rest of Mash.
 ;
 ;
 ;
 ;@section 1 code
 ;
 ;
 ;
 ;@ppi-code findex^%ts
findex ; find position of substring
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/toad;private;procedure;clean;silent;sac;NO tests
 ;@signatures
 ; do findex^%ts(.string)
 ; do findex^%ts(.string,find)
 ; do findex^%ts(.string,find,flags)
 ;@synonyms
 ; fe^%ts
 ; findExtract^%ts
 ; find^%ts
 ;@branches-from
 ; findex^%ts
 ;@ppi-called-by: none yet, but just wait an hour or two
 ;@called-by: none
 ;@calls: $$lowcase^%ts
 ;@input
 ;.string = string to search for substring
 ; find = substring to find in string
 ; flags = characters to control scan [optional]
 ;  b or B = scan backward
 ;  i or I = case-insensitive scan
 ;  r or R = refresh lower-case versions of string & find
 ;@throughput
 ;.string("extract","from") = pos of 1st char of substring found
 ;.string("extract","to") = pos of last char of substring found
 ;.string("low","find") = lowercase find value [if i flag]
 ;.string("low","string") = lowercase string value [if i flag]
 ;
 ;@examples
 ;
 ; group 1: Find First & Find Next
 ;
 ;  new string set string="totototo"
 ;  do findex^%ts(.string,"Kansas")
 ; produces
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do findex^%ts(.string,"toto")
 ; produces
 ;  string("extract","from")=1
 ;  string("extract","to")=4
 ;
 ; followed by
 ;  do findex^%ts(.string,"toto")
 ; produces
 ;  string("extract","from")=5
 ;  string("extract","to")=8
 ;
 ; followed by
 ;  do findex^%ts(.string,"toto")
 ; produces
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  set string("extract","from")=1
 ;  set string("extract","to")=2
 ;  do findex^%ts(.string,"toto")
 ; produces
 ;  string("extract","from")=3
 ;  string("extract","to")=6
 ;
 ;  new string set string="totototo"
 ;  set string("extract","from")=6
 ;  set string("extract","to")=7
 ;  do findex^%ts(.string,"toto")
 ; produces
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ; group 2: Find Last & Find Previous
 ;
 ;  new string set string="totototo"
 ;  do findex^%ts(.string,"Kansas","b")
 ; produces
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do findex^%ts(.string,"toto","b")
 ; produces
 ;  string("extract","from")=5
 ;  string("extract","to")=8
 ;
 ; followed by
 ;  do findex^%ts(.string,"toto","b")
 ; produces
 ;  string("extract","from")=1
 ;  string("extract","to")=4
 ;
 ; followed by
 ;  do findex^%ts(.string,"toto","b")
 ; produces
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  set string("extract","from")=7
 ;  set string("extract","to")=8
 ;  do findex^%ts(.string,"toto","b")
 ; produces
 ;  string("extract","from")=3
 ;  string("extract","to")=6
 ;
 ;  new string set string="totototo"
 ;  set string("extract","from")=1
 ;  set string("extract","to")=2
 ;  do findex^%ts(.string,"toto","b")
 ; produces
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ; group 3: Find Case-Insensitive
 ;
 ;  new string set string="totototo"
 ;  do findex^%ts(.string,"Toto")
 ; produces
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ; followed by
 ;  do findex^%ts(.string,"Toto","i")
 ; produces
 ;  string("extract","from")=1
 ;  string("extract","to")=4
 ;
 ; followed by
 ;  do findex^%ts(.string,"Toto","i")
 ; produces
 ;  string("extract","from")=5
 ;  string("extract","to")=8
 ;
 ;  
 ;
 ; group 4: Boundary Cases
 ;
 ;
 ;@tests [tbd]
 ;
 ;
 ;@stanza 2 detailed description
 ;
 ;
 ; findex^%ts is an enhanced version of the Mumps $find function. It
 ; will find the position of a substring (find) w/in a string.
 ;
 ; (Note: a future findex^%ts will support a new call-message
 ; system of passing parameters. For now, the embryonic form is the
 ; behavior of the string array, which findex^%ts & setex^%ts manage.)
 ;
 ; In the discussion that follows, string("extract","from") will be
 ; referred to as from, & string("extract","to") as to.
 ;
 ;
 ; I. about string & find
 ;
 ; So long as string and find are both non-empty, findex^%ts will scan
 ; string looking for find.
 ;
 ; If either string or find is passed undefined or = the empty
 ; string (""), it is said to be empty, because it contains no
 ; characters & no positions. If find is empty, it is contained in
 ; every string but at no position, so it cannot be found. If string
 ; is empty, it contains no string but the empty string, and that at
 ; no position, so no string can be found in it. If string or find
 ; is empty, findex^%ts will set from & to = 0 to indicate a failed
 ; scan.
 ;
 ; string must be passed by reference = the string to scan; if it is
 ; passed by value, findex^%ts is a no-op, because it returns its
 ; results as nodes in from & to in the string array (see below). If
 ; string is passed undefined, findex^%ts will set it = the empty
 ; string ("").
 ;
 ; find is passed by value. It = the substring to look for in string.
 ; If find is passed by reference undefined, findex^%ts will set it =
 ; the empty string ("").
 ;
 ;
 ; II. Find First: two-argument findex^%ts
 ;
 ; If from & to are not set, then two-argument findex^%ts finds the 1st
 ; occurrence of find within string. It sets from = the position within
 ; string of the 1st character of the found substring & to = the
 ; position of the last character of the found substring. Together they
 ; precisely identify where the scan found the substring.
 ;
 ; If the scan does not find the substring in string, then from & to
 ; are set = 0.
 ;
 ; The other Extract calls in the String Library, such as setex^%ts are
 ; designed to update these same two nodes if they use them to alter
 ; the string, so that a subsequent call to findex^%ts will resume at
 ; the correct location (see below).
 ;
 ;
 ; III. Find Next: two-argument findex^%ts
 ;
 ; After a call to findex^%ts, if its scan found the substring & set
 ; from & to, another call to findex^%ts with the string array & find
 ; parameter set just the way findex^%ts left them will locate the next
 ; instance of substring & update from & to = the new location or set
 ; them = 0 if there was only the one instance of substring to be
 ; found.
 ;
 ; Since from & to act like inputs as well as outputs, if you want to
 ; scan for a different substring w/in the same string from the
 ; beginning, you need to kill string("extract") to clear the prior
 ; results.
 ;
 ; Conversely, you can set from & to manually before calling findex^%ts
 ; to control where the scan begins. The scan will begin (or resume)
 ; at character position to+1.
 ;
 ; from & to represent string's character positions as a ring that
 ; begins and ends at position 0; other than 0, only positions 1
 ; through the length of string are possible. Decimals are ignored,
 ; just truncated. all negative values are treated as 0. So are
 ; all values greater than the length of string. If from & to are
 ; passed = strings isntead of numbers, they will be coerced into
 ; numbers following the Mumps rules, so if from = "12 cats" it will
 ; be treated as 12, but "cats 12" will be treated as 0. If they
 ; are passed empty (undefined or = the empty string), they will be
 ; set = 0, meaning start at the beginning (see Find First above).
 ;
 ; (Note: a future version of findex^%ts will introduce new parameters
 ; for controlling where a scan begins & ends, though if they are not
 ; passed, the current behavior will continue to work.)
 ;
 ; The Find Next capability need not be used to search for the same
 ; find value each time; scanning a structured string might involve
 ; searching for one find value & then another. There is no requirement
 ; that the size of the window between from & to match the length of
 ; find on input.
 ;
 ;
 ; IV. Find Last: two-argument findex^%ts + b flag
 ;
 ; If we set up a Find First call to findex^%ts but also include a b or
 ; B in the flags parameter, it will scan backward instead of forward &
 ; so find the last instance of substring within string instead of the
 ; first. As usual, if substring is not found, from & to will be set
 ; = 0.
 ;
 ; If the b flag is not passed, findex^%ts defaults to scanning forward.
 ;
 ;
 ; V. Find Previous: two-argument findex^%ts + b flag
 ;
 ; Likewise, if we set up a Find Next call but include b or B in flags,
 ; findex^%ts will continue its backward scan from where it left off &
 ; find the previous instance of substring in string, setting its output
 ; nodes to the result.
 ;
 ; When the b flag is passed, Find Previous scans begin at from-1 &
 ; scans earlier positions (instead of beginning at to+1 & scanning
 ; later positions). If from = 0, as per the rules of the find number
 ; ring, from-1 is treated as the last character position in string.
 ; Otherwise, the same interpretation rules for from & to apply as
 ; scanning forward.
 ;
 ;
 ; VI. Case-insensitive Find: two-argument findex^%ts + i flag
 ;
 ; If flags includes i or I, the scan will be case-insensitive, so for
 ; example substring "Toto" would be found in string "totototo".
 ;
 ; To help make scans more efficient, findex^%ts will save a lowercase
 ; version of string in string("low","string") & of find in
 ; string("low","find") to use in subsequent calls, to avoid having to
 ; recalculate lowercase versions of them each time findex^%ts is called.
 ;
 ; Other Extract calls in the String Library that manipulate string &
 ; support the case-insensitive flag will perform the same changes on
 ; string("low") to keeps nodes in synch with string. If you change
 ; string or find & plan to call findex^%ts again without killing or
 ; newing them, pass the r flag, which will make findex^%ts refresh the
 ; string("low") nodes to keep them in synch with your changes.
 ;
 ; If the i flag is not passed, findex^%ts defaults to a case-sensitive
 ; scan. No flags other than b, i, or r are currently supported. All
 ; other values are reserved. Including any other value in flags will
 ; cause the scan to fail & set from & to = 0.
 ;
 ;
 ;@stanza 3 handle defaults, coercion, reserved values
 ;
 set string=$get(string)
 set find=$get(find)
 ;
 new from,to
 set from=$get(string("extract","from"))\1 ; reduce from to integers
 set:from<0 from=0 ; negative = 0
 new stringlen set stringlen=$length(string)
 set:from>stringlen from=0 ; too long = 0
 ;
 set to=$get(string("extract","to"))\1 ; reduce to to integers
 set:to<0 to=0 ; negative = 0
 set:to>stringlen to=0 ; too long = 0
 ;
 set flags=$get(flags)
 ;
 if flags?.e1u.e do  ; if flags contains uppercase values
 . set flags=$$lowcase^%ts(flags) ; convert to lowercase
 . quit
 ;
 new badflags set badflags=$translate(flags,"bir")]"" ; reserved flags
 ;
 ;
 ;@stanza 4 set up direction of scan
 ;
 new way,begin ; direction & where to start
 ;
 if badflags do  ; if bad flags, there will be no scan
 . set begin=0
 . quit
 ;
 else  if flags'["b" do  ; if scanning forward
 . set way=1 ; normal direction
 . set begin=to+1 ; begin after previously found substring
 . set:begin>stringlen begin=0 ; no scan, ran out of string
 . quit
 ;
 else  do  ; if scanning backward
 . set way=-1 ; reverse direction
 . set begin=from-1 ; begin before previously found substring
 . set:begin<1 begin=0 ; no scan, ran out of string
 . set:from=0 begin=stringlen ; begin at end of string
 . quit
 ;
 ;
 ;@stanza 5 set up case-sensitivity of scan
 ;
 new scanme,lookfor
 new case set case=flags["i" ; case insensitive?
 ;
 if 'case do  ; if case-sensitive scan, set that up
 . set scanme=string
 . set lookfor=find
 . quit
 ;
 else  do  ; if case-insensitive scan, set that up instead
 . if $get(string("low","string"))=""!(flags["r") do
 . . set string("low","string")=$$lowcase^%ts(string)
 . . quit
 . if $get(string("low","find"))=""!(flags["r") do
 . . set string("low","find")=$$lowcase^%ts(find)
 . . quit
 . set scanme=string("low","string")
 . set lookfor=string("low","find")
 . quit
 ;
 ;
 ;@stanza 6 perform scan
 ;
 new found set found=0 ; where did our scan find the substring
 set found("from")=0
 set found("to")=0
 ;
 ; if empty string, empty find, or ran out of string, then no scan
 new findlen set findlen=$length(find)
 if 'stringlen!'findlen!'begin ; if nothing can be found
 ;
 else  if way=1 do  ; forward scan
 . set found=$find(scanme,lookfor,begin) ; find substring
 . if 'found quit  ; done if couldn't find it
 . set found("to")=found-1 ; otherwise remember where
 . set found("from")=found-findlen
 . set found=1
 . quit
 ;
 else  do  ; backward scan
 . new winto set winto=begin ; end position of window into string
 . new winfrom,window
 . for  do  quit:found!'winfrom  ; traverse until found or done
 . . set winfrom=winto-findlen+1 ; start position of window
 . . if winfrom<1 do  quit  ; window has backed past start of string
 . . . set winfrom=0 ; no more substring instances to be found
 . . . quit
 . . set window=$extract(string,winfrom,winto) ; extract window
 . . set found=window=find ; did we find it?
 . . if found do  quit  ; if so, remember where
 . . . set found("from")=winfrom
 . . . set found("to")=winto
 . . . quit
 . . set winto=winto-1 ; shift end of window to previous position
 . . quit
 . quit
 ;
 ;
 ;@stanza 7 return results
 ;
 kill string("extract")
 merge string("extract")=found
 ;
 ;
 ;@stanza 8 termination
 ;
 quit  ; end of ppi findex^%ts
 ;
 ;
 ;
eor ; end of routine %tsef

%tses
%tses ;ven/toad-type string: setex^%ts ;2018-03-03T06:27Z
 ;;1.8;Mash;
 ;
 ; %tses implements MASH String Library ppi setex^%ts, change
 ; (or create) value of positional substring; it is part of the
 ; String Extract sublibrary.
 ; See %tsutes for unit tests for setex^%ts.
 ; See %tsud for an introduction to the String library, including an
 ; intro to the String Replace library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tses contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-03T06:27Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@to-do
 ; put back from and to parameters
 ; apply standard string-length protection consistently
 ; add ability to call by passing object
 ;  s or S = case-sensitive replace
 ;  call("case")
 ;  call("extract","from")
 ;  call("extract","to")
 ;  call("replace")
 ;  call("low","string")
 ;  call("string")
 ; add feature to load object w/parameters for shorter calls
 ;  find => call("find")
 ; apply standard string-length protection consistently
 ; create findm/findmsg to preload call-message array
 ;
 ;
 ;@section 1 code
 ;
 ;
 ;
 ;@ppi-code setex^%ts
setex ; change value of positional substring
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/toad;private;procedure;clean;silent;sac;NO tests
 ;@signatures
 ; setex^%ts(.string,replace)
 ; setex^%ts(.string,replace,flags)
 ; setex^%ts(.string,replace,flags)
 ;@synonyms
 ; se^%ts
 ; setExtract^%ts
 ; place^%ts
 ;@branches-from
 ; setex^%ts
 ;@ppi-called-by: none yet, but just wait an hour or two
 ;@called-by: none
 ;@calls
 ; $$lowcase^%ts
 ;@input
 ;.string = string to set an extract into
 ; replace = replacement substring to place into string
 ; flags = characters to control set [optional]
 ;  b or B = set for a backward scan
 ;  i or I = set for a case-insensitive scan
 ;  r or R = refresh lower-case versions of string & replace
 ;@throughput
 ;.string("extract","from") = pos of 1st char of substring to set
 ;.string("extract","to") = pos of last char of substring to set
 ;.string("low","string") = lowercase string value [if i flag]
 ;@examples
 ;
 ; group 1: default addressing
 ;
 ;  new string,replace
 ;  do setex^%ts(.string,.replace)
 ; produces
 ;  string=""
 ;  replace=""
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string=""
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string=""
 ;  new replace
 ;  do setex^%ts(.string,.replace)
 ; produces
 ;  string=""
 ;  replace=""
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string=""
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string=""
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string=""
 ;  do setex^%ts(.string,"*")
 ; produces
 ;  string="*"
 ;  string("extract","from")=1
 ;  string("extract","to")=1
 ;
 ;  new string set string=""
 ;  do setex^%ts(.string,"Sparrowhawk")
 ; produces
 ;  string="Sparrowhawk"
 ;  string("extract","from")=1
 ;  string("extract","to")=11
 ;
 ;  new string set string="Never the way he can follow grows narrower"
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="ever the way he can follow grows narrower"
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="In the empty sky."
 ;  do setex^%ts(.string,"o")
 ; produces
 ;  string="on the empty sky."
 ;  string("extract","from")=1
 ;  string("extract","to")=1
 ;
 ;  new string set string="O the hawk's flight"
 ;  do setex^%ts(.string,"bright")
 ; produces
 ;  string="bright the hawk's flight"
 ;  string("extract","from")=1
 ;  string("extract","to")=6
 ;
 ; group 2: absolute addressing w/in string
 ;
 ;  new string set string="She lay thus dark and dumb"
 ;  set string("from")=1
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="he lay thus dark and dumb"
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="O Wizard of Earthsea"
 ;  set string("extract","from")=1
 ;  do setex^%ts(.string,"A")
 ; produces
 ;  string="A Wizard of Earthsea"
 ;  string("extract","from")=1
 ;  string("extract","to")=1
 ;
 ;  new string set string="I hear, one must be silent."
 ;  set string("extract","from")=1
 ;  do setex^%ts(.string,"To")
 ; produces
 ;  string="To hear, one must be silent."
 ;  string("extract","from")=1
 ;  string("extract","to")=2
 ;
 ;  new string set string="until at lEast he chooses nothing"
 ;  set string("extract","from")=11
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="until at last he chooses nothing"
 ;  string("extract","from")=10
 ;  string("extract","to")=10
 ;
 ;  new string set string="To light a Sandle is to cast a shadow."
 ;  set string("extract","from")=12
 ;  do setex^%ts(.string,"c")
 ; produces
 ;  string="To light a candle is to cast a shadow."
 ;  string("extract","from")=12
 ;  string("extract","to")=12
 ;
 ;  new string set string="does onlY what he must do"
 ;  set string("extract","from")=9
 ;  do setex^%ts(.string,"y and wholly")
 ; produces
 ;  string="does only and wholly what he must do"
 ;  string("extract","from")=9
 ;  string("extract","to")=20
 ;
 ;  new string set string="For a word to be spoken there must be silenceS"
 ;  set string("extract","from")=46
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="For a word to be spoken there must be silence"
 ;  string("extract","from")=45
 ;  string("extract","to")=45
 ;
 ;  new string set string="there must be darkness to see the starT"
 ;  set string("extract","from")=39
 ;  do setex^%ts(.string,"s")
 ; produces
 ;  string="there must be darkness to see the stars"
 ;  string("extract","from")=39
 ;  string("extract","to")=39
 ;
 ;  new string set string="only men do"
 ;  set string("extract","from")=11
 ;  do setex^%ts(.string,"o evil")
 ; produces
 ;  string="only men do evil"
 ;  string("extract","from")=11
 ;  string("extract","to")=16
 ;
 ; group 3: absolute addressing before string
 ;
 ;  new string set string="She wept in pain, because she was free"
 ;  set string("extract","from")=0
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="She wept in pain, because she was free"
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="eight of liberty"
 ;  set string("extract","from")=0
 ;  do setex^%ts(.string,"w")
 ; produces
 ;  string="weight of liberty"
 ;  string("extract","from")=1
 ;  string("extract","to")=1
 ;
 ;  new string set string="Wizard of Earthsea"
 ;  set string("extract","from")=-1
 ;  do setex^%ts(.string,"A")
 ; produces
 ;  string="A Wizard of Earthsea"
 ;  string("extract","from")=1
 ;  string("extract","to")=1
 ;
 ;  new string set string="Tombs of Atuan"
 ;  set string("extract","from")=-3
 ;  do setex^%ts(.string,"The")
 ; produces
 ;  string="The Tombs of Atuan"
 ;  string("extract","from")=1
 ;  string("extract","to")=3
 ;
 ;  new string set string="Farthest Shore"
 ;  set string("extract","from")=-5
 ;  do setex^%ts(.string,"The")
 ; produces
 ;  string="The   Farthest Shore"
 ;  string("extract","from")=1
 ;  string("extract","to")=3
 ;
 ;  new string set string="Tehanu"
 ;  set string("extract","from")=-4
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="    Tehanu"
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="Another Wind"
 ;  set string("extract","from")=-1
 ;  do setex^%ts(.string,"The O")
 ; produces
 ;  string="The Other Wind"
 ;  string("extract","from")=1
 ;  string("extract","to")=5
 ;
 ; group 4: absolute addressing after string
 ;
 ;  new string set string="muddle, mystery, mumbling"
 ;  set string("extract","from")=26
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="muddle, mystery, mumbling"
 ;  string("extract","from")=25
 ;  string("extract","to")=25
 ;
 ;  new string set string="There's no way to use power for good."
 ;  set string("extract","from")=39
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="There's no way to use power for good. "
 ;  string("extract","from")=38
 ;  string("extract","to")=38
 ;
 ;  new string set string="All times are changing times"
 ;  set string("extract","from")=32
 ;  do setex^%ts(.string,"")
 ; produces string="All times are changing times   "
 ;  string("extract","from")=31
 ;  string("extract","to")=31
 ;
 ;  new string set string="Tales"
 ;  set string("extract","from")=6
 ;  do setex^%ts(.string," from Earthsea")
 ; produces
 ;  string="Tales from Earthsea"
 ;  string("extract","from")=6
 ;  string("extract","to")=19
 ;
 ;  new string set string="to make love"
 ;  set string("extract","from")=14
 ;  do setex^%ts(.string,"is to unmake power")
 ; produces
 ;  string="to make love is to unmake power"
 ;  string("extract","from")=14
 ;  string("extract","to")=31
 ;
 ;  new string set string="The solution lies in secret"
 ;  set string("extract","from")=27
 ;  do setex^%ts(.string,"cy")
 ; produces
 ;  string="The solution lies in secrecy"
 ;  string("extract","from")=27
 ;  string("extract","to")=28
 ;
 ; group 5: relative addressing
 ;
 ;  new string set string="The road goes upward towards the light"
 ;  set string("extract","from")="b"
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="The road goes upward towards the light"
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string=" dark hand had let go its lifelong hold"
 ;  set string("extract","from")="b"
 ;  do setex^%ts(.string,"A")
 ; produces string="A dark hand had let go its lifelong hold"
 ;  string("extract","from")=1
 ;  string("extract","to")=1
 ;
 ;  new string set string="a gift given, but a choice made"
 ;  set string("extract","from")="b"
 ;  do setex^%ts(.string,"It is not ")
 ; produces
 ;  string="It is not a gift given, but a choice made"
 ;  string("extract","from")=1
 ;  string("extract","to")=10
 ;
 ;  new string set string="courage breaks them."
 ;  set string("extract","from")="B"
 ;  do setex^%ts(.string,"Injustice makes the rules, and ")
 ; produces
 ;  string="Injustice makes the rules, and courage breaks them."
 ;  string("extract","from")=1
 ;  string("extract","to")=31
 ;
 ;  new string set string="when you eat illusions you end up hungrier"
 ;  set string("extract","from")="a"
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="when you eat illusions you end up hungrier"
 ;  string("extract","from")=42
 ;  string("extract","to")=42
 ;
 ;  new string set string="Manipulated, one manipulates others"
 ;  set string("extract","from")="a"
 ;  do setex^%ts(.string,".")
 ; produces
 ;  string="Manipulated, one manipulates others."
 ;  string("extract","from")=36
 ;  string("extract","to")=36
 ;
 ;  new string set string="Statesmen remember things"
 ;  set string("extract","from")="a"
 ;  do setex^%ts(.string," selectively")
 ; produces
 ;  string="Statesmen remember things selectively"
 ;  string("extract","from")=26
 ;  string("extract","to")=37
 ;
 ;  new string set string="I can breathe back the breath"
 ;  set string("extract","from")="A"
 ;  do setex^%ts(.string," that made me live")
 ; produces string="I can breathe back the breath that made me live"
 ;  string("extract","from")=30
 ;  string("extract","to")=47
 ;
 ;  new string set string="Ignorant power is a bane!"
 ;  set string("extract","from")="f"
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="Ignorant power is a bane!"
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="U can give them back to the world"
 ;  set string("extract","from")="f"
 ;  do setex^%ts(.string,"I")
 ; produces
 ;  string="I can give them back to the world"
 ;  string("extract","from")=1
 ;  string("extract","to")=1
 ;
 ;  new string set string="MANHOOD speaks evenly, in a quiet voice"
 ;  set string("extract","from")="f"
 ;  do setex^%ts(.string,"Despair")
 ; produces
 ;  string="Despair speaks evenly, in a quiet voice"
 ;  string("extract","from")=1
 ;  string("extract","to")=7
 ;
 ;  new string set string="AUTHORITY makes the rules"
 ;  set string("extract","from")="F"
 ;  do setex^%ts(.string,"Injustice")
 ; produces string="Injustice makes the rules"
 ;  string("extract","from")=1
 ;  string("extract","to")=9
 ;
 ;  new string set string="To which Silence of course made no reply"
 ;  set string("extract","from")="l"
 ;  do setex^%ts(.string,"")
 ; produces
 ;  string="To which Silence of course made no reply"
 ;  string("extract","from")=40
 ;  string("extract","to")=40
 ;
 ;  new string set string="Greed puts out the suM"
 ;  set string("extract","from")="l"
 ;  do setex^%ts(.string,"n")
 ; produces
 ;  string="Greed puts out the sun"
 ;  string("extract","from")=22
 ;  string("extract","to")=22
 ;
 ;  new string set string="The world's vast and ANCIENT"
 ;  set string("extract","from")="l"
 ;  do setex^%ts(.string,"strange")
 ; produces string="The worldâ€™s vast and strange"
 ;  string("extract","from")=22
 ;  string("extract","to")=28
 ;
 ;  new string set string="To refuse death is to refuse DOOM"
 ;  set string("extract","from")="L"
 ;  do setex^%ts(.string,"life")
 ; produces string="To refuse death is to refuse life"
 ;  string("extract","from")=30
 ;  string("extract","to")=33
 ;
 ; group 6: from & to, absolute addressing w/in string [tbd]
 ;
 ;  new string set string="the terrible pain"
 ;  set string("extract","from")=13
 ;  do setex^%ts(.string," boredom of ")
 ; produces
 ;  string="the terrible boredom of pain"
 ;  string("extract","from")=13
 ;  string("extract","to")=24
 ;
 ;  new string set string="admit the ATTRACTION of evil"
 ;  set string("extract","from")=11
 ;  set string("extract","to")=20
 ;  do setex^%ts(.string,"banality")
 ; produces
 ;  string="admit the banality of evil"
 ;  string("extract","from")=11
 ;  string("extract","to")=18
 ;
 ;  new string set string="the victory they celebrate is WAR WON WELL"
 ;  set string("extract","from")="L"
 ;  do setex^%ts(.string,"that of life")
 ; produces
 ;  string="the victory they celebrate is that of life"
 ;  string("extract","from")=31
 ;  string("extract","to")=42
 ;
 ; group 7: from & to, absolute addressing before string [tbd]
 ;
 ;
 ; group 8: from & to, absolute addressing after string [tbd]
 ;
 ;
 ; group 9: from & to, relative addressing [tbd]
 ;
 ; 
 ; group 11: reserved values & other boundary conditions [tbd]
 ;
 ;
 ; group 12: the b flag [tbd]
 ;
 ; only difference: for deletions, from & to set to +1
 ; except at end, where set to 0
 ;
 ; group 12: the i flag [tbd]
 ;
 ; show effects on string("low",string")
 ;
 ; group 12: the r flag [tbd]
 ;
 ; show effects on string("low",string")
 ;
 ;@tests [tbd]
 ;
 ;@stanza 2 detailed description
 ;
 ; setex^%ts is an enhanced version of the Mumps set $extract.
 ; It will place characters w/in a string at the specified position.
 ;
 ; (Note: a future version of setex^%ts will support a new call-
 ; message system of passing parameters. For now, the embryonic form
 ; is the behavior of the string array, which find^%ts &
 ; setextract%ts manage.)
 ;
 ; In the discussion that follows, string("extract","from") will be
 ; referred to as from, & string("extract","to") as to.
 ;
 ;
 ; I. about string & replace
 ;
 ; If either string or replace is passed undefined or = the empty
 ; string (""), it is said to be empty, because it contains no
 ; characters & no positions. When setex^%ts sets a value to
 ; empty, it sets it = the empty string. Placing a substring into a
 ; string will never leave that string undefined; canonically, even
 ; the minimal case will leave string empty instead of undefined.
 ; Although replace need only be passed by value, if passed by
 ; reference undefined the same holds true; it will never be left
 ; undefined but will be set to empty.
 ;
 ; Together, string & replace define most or all of the contents of
 ; the place operation, as well as what kind of placement occurs:
 ;
 ; 1. Overwrite Substring: if neither string nor replace is empty,
 ; string will be altered to overwrite the characters at positions
 ; from through to (see below) w/substring replace.
 ;
 ; 2. Create Substring: if string is empty, setex^%ts will create
 ; a string of spaces & place substring replace w/in that.
 ;
 ; 3. Delete Substring: if replace is empty, then the overwritten
 ; characters in the string are removed but not replaced.
 ;
 ;
 ; II. about from & to as input
 ;
 ; from & to are optional. from defaults to 1, just as with $extract.
 ; to defaults to = from. They can have two different kinds of values:
 ;
 ; i. Absolute Addressing: from & to may be integers, in which case they
 ; identify character positions before, within, or after the range from
 ; 1 to string's length. If passed with a decimal part, it is truncated
 ; (any decimal parts will be ignored). If to evaluates to <= from,
 ; it is treated as = from. Values > the string's length extend string
 ; to the right to create the positions, padding with spaces if needed,
 ; just as set $extract does. Values < 1 extend string to the left to
 ; create the positions, which set $extract does not do.
 ;
 ; ii. Relative Addressing: from may be passed as one of four codes:
 ; b, a, f, l (or their uppercase equivalents). In this case, to is
 ; ignored. Other code values are reserved for future versions of
 ; setex^%ts:
 ; a. B-1, B-2, etc., b-1, b-2, etc.
 ; b. A+1, A+2, etc., a+1, a+2, etc.
 ; c. F+1, F+2, etc., f+1, f+2, etc.
 ; d. L-1, L-2, etc., l-1, l-2, etc.
 ; e. all other string values.
 ; For now, if any of these values is used for from, setex^%ts will
 ; set string = empty, but this behavior may not be relied upon in future
 ; versions.
 ;
 ; Together, from & to define the locations w/in string to be altered
 ; by the placement, which in turn defines which characters are
 ; overwritten or created by the place operation. There are five main
 ; categories of placement, categorized by from's value (in each case,
 ; if to is passed it has requirements for its value, and passing it
 ; with any other value will result in setting string = empty):
 ;
 ; a. Place Within: if from's value is not < 1 nor > the length of
 ; string, then to is required either to = 0 or a value w/in that same
 ; range >= from. In this case, the characters located by from & to are
 ; removed & replace is inserted, which may or may not change the length
 ; of string.
 ;
 ; b. Place Before String (Prepend): if from = "b" or "B", then to will
 ; be ignored. In this case, replace is concatenated to the front of
 ; string.
 ;
 ; c. Place After String (Append): if from = "a" or "A", then to will
 ; be ignored. In this case replace is concatenated to the end of
 ; string.
 ;
 ; d. Place First in String: if from = "f" or "F", then to will be
 ; ignored. In this case, replace overwrites the first characters of
 ; string, up to replace's length. If the length of replace is >=
 ; string's length, string will be set to replace.
 ;
 ; e. Place Last in String: if from = "l" or "L", then to will be
 ; ignored. In this case, replace overwrites the last characters of
 ; string, up to replace's length. If the length of replace is >=
 ; string's length, string will be set to replace.
 ;
 ;
 ; III. about from & to as output
 ;
 ; setex^%ts will set from & to = the 1st & last character
 ; positions of replace w/in the resulting string. This feature is
 ; important to combining setex^%ts smoothly w/find^%ts to create
 ; find-replace loops that include Find Next operations.
 ;
 ;
 ; IV. about from & to & the b flag
 ;
 ; When replace is empty, it has no specific location, but any ongoing
 ; scans being performed by find^%ts in concert with setex^%ts do,
 ; so from & to are set to the character before the deleted substring.
 ; If the b or B flag is passed, it means the associated find^%ts
 ; calls are performing a backward scan, so from & to will instead be
 ; set to the character position after the deleted substring. In both
 ; cases, from & to are set so a subsequent call to find^%ts will
 ; neither miss nor repeat any of string's characters in its scan.
 ;
 ; If you are doing stand-alone calls to setex^%ts that are not
 ; being coordinated with calls to find^%ts, feel free to omit the b
 ; flag.
 ;
 ; V. about the i & r flags
 ;
 ; To help make scans more efficient, find^%ts saves a lowercase
 ; version of string in string("low","string") to use in subsequent
 ; calls, to avoid having to recalculate lowercase versions of them each
 ; time find^%ts is called.
 ;
 ; Because setex^%ts manipulates string, it supports the same
 ; case-insensitive flag to instruct it to perform the same changes
 ; on string("low","string") that it does on string, to keep the node in
 ; synch with string. If you change string & plan to call find^%ts again
 ; without killing or newing it, pass setex^%ts the r flag, which
 ; will make it refresh string("low","string") to keep it in synch with
 ; your changes.
 ;
 ; If the i flag is not passed, setex^%ts will only update string.
 ; If you are doing stand-alone calls to setex^%ts that are not
 ; being coordinated with calls to find^%ts, feel free to omit the i & r
 ; flags.
 ;
 ; No flags other than b, i, or r are currently supported. All
 ; other values are reserved. Including any other value in flags will
 ; cause the string placement to fail & set from & to = 0.
 ;
 ;@stanza 3 evaluate inputs
 ;
 ; 3.1. handle empty string or replace
 set string=$get(string)
 set replace=$get(replace)
 ;
 ; 3.2. handle absolute, relative, or reserved from
 set from=$get(string("extract","from"))
 set:from="" from=1 ; default to 1st character
 new absolute set absolute=+from=from ; is from a character position?
 new relative set relative='absolute ; is from a code?
 new reserved set reserved=0
 ;
 set:absolute from=from\1 ; absolute from: ignore decimals
 ;
 if relative do  quit:reserved  ; relative from
 . set:from?1a.e from=$$lowcase^%ts(from) ; case-insensitive codes
 . quit:from?1(1"b",1"a",1"f",1"l")  ; place before,after,first,last
 . set reserved=1
 . set string="" ; reject reserved values
 . set string("extract")=0
 . set string("extract","from")=0
 . set string("extract","to")=0
 . quit:from?1(1"b",1"a",1"f",1"l")1(1"+",1"-")1.n  ; reserved codes
 . quit  ; all other string values are reserved
 ;
 ; 3.3. handle absolute, relative, or reserved to
 set to=$get(string("extract","to"))
 set:to="" to=from ; to defaults to from
 ;
 set:relative to=from ; relative to: ignore to
 ;
 if absolute do  quit:reserved  ; absolute to
 . if +to=to set to=to\1 quit  ; legit = ignore decimals
 . set reserved=1 ; can't mix relative addressing with absolute
 . set string=""
 . set string("extract")=0
 . set string("extract","from")=0
 . set string("extract","to")=0
 . quit
 ;
 set:to<from to=from ; to can't be < from
 ;
 ; 3.4. handle flags
 ;
 set flags=$get(flags)
 ;
 if flags?.e1u.e do  ; if flags contains uppercase values
 . set flags=$$lowcase^%ts(flags) ; convert to lowercase
 . quit
 ;
 new badflags set badflags=$translate(flags,"bir")]"" ; reserved flags
 if badflags do  quit
 . set string("extract")=0
 . set string("extract","from")=0
 . set string("extract","to")=0
 . quit
 ;
 ; 3.5. handle set extract for case-insensitive scan
 ;
 new lower set lower=flags["i" ; lowercase string
 if lower do  ; ensure we have a fresh string("low","string")
 . if $data(string("low","string"))#2,flags'["r" quit
 . set string("low","string")=$$lowcase^%ts(string)
 . quit
 ;
 new lowrep set lowrep=replace
 if lower,lowrep?.e1u.e do
 . set lowrep=$$lowcase^%ts(lowrep)
 . quit
 ;
 ;@stanza 4 calculate placement
 ;
 new stringlen set stringlen=$length(string)
 new replacelen set replacelen=$length(replace)
 new prepad set prepad=0 ; # spaces to prefix to make set $extract work
 ;
 if absolute do  ; absolute addressing
 . quit:from>0  ; set $extract can handle 1 or above
 . set prepad=-from+1 ; prepend absolute value plus one spaces
 . set from=1
 . set to=replacelen
 . set:replace="" to=1 ; to place empty string, ensure to > 0
 . quit
 ;
 else  if from="b" do  ; place substring before string (prepend)
 . set prepad=replacelen ; prepend length of replace spaces
 . set from=1
 . set to=replacelen
 . set:replace="" (prepad,to)=1 ; to place empty string, pad & remove
 . quit
 ;
 else  if from="a" do  ; place substring after string (append)
 . set from=stringlen+1
 . set to=stringlen+replacelen
 . quit
 ;
 else  if from="f" do  ; place substring first in string
 . set from=1
 . set to=replacelen
 . set:replace="" (prepad,to)=1 ; to place empty string, pad & remove
 . quit
 ;
 else  if from="l" do  ; place substring last in string
 . set from=stringlen-replacelen+1
 . set:from<1 from=1
 . set to=stringlen
 . set:replace="" (from,to)=stringlen+1 ; to place empty string
 . quit
 ;
 ;@stanza 5 place substring within string
 ;
 if prepad do  ; if placing replace before string
 . new pad set $extract(pad,prepad+1)="" ; create pad of spaces
 . set string=pad_string ; prepend pad
 . set stringlen=stringlen+prepad ; update string length
 . quit:'lower  ; quit if not for a case-insensitive scan
 . set string("low","string")=pad_string("low","string")
 . quit
 ;
 do  ; place it
 . set $extract(string,from,to)=replace ; place substring in string
 . set:lower $extract(string("low","string"),from,to)=lowrep
 . set to=from+replacelen-1 ; update to location
 . set stringlen=$length(string) ; update string length
 . quit
 ;
 if replace="" do  ; empty-string replace has no position
 . ; it is used to delete characters
 . set (from,to)=from-1 ; so back up to just before the deletion
 . set:from<1 (from,to)=0 ; but not into negatives
 . quit:flags'["b"  ; done if scanning forward
 . set (from,to)=from+1 ; set from & to = after deletion
 . set:from>stringlen (from,to)=0 ; set to end if overflow
 . quit
 ;
 ;@stanza 6 set return from & to values
 ;
 set string("extract")=1
 set string("extract","from")=from
 set string("extract","to")=to
 ;
 ;@stanza 7 termination
 ;
 quit  ; end of setex^%ts
 ;
 ;
 ;
eor ; end of routine %tses

%tsfs
%tsfs ;ven/toad-type string: setfind^%ts ;2018-03-18T16:38Z
 ;;1.8;Mash;
 ;
 ; %tsfs implements MASH String Library ppi setfind^%ts, find &
 ; replace a substring; it is part of the String Find Library.
 ; See %tsutfs for unit tests for setfind^%ts.
 ; See %tsud for an introduction to the String library, including an
 ; intro to the String Find Library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsfs contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, gpl&toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;@original-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;
 ;@last-updated: 2018-03-18T16:38Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@to-do
 ; convert to standardized success or failure flag
 ; apply standard string-length protection consistently
 ; add ability to call by passing object
 ; add feature to load object w/parameters for shorter calls
 ; if r flag passed, don't include in call to setex^%ts
 ; write detailed description of setfind^%ts
 ; develop more examples
 ; write unit tests
 ;
 ;
 ;
 ;@section 1 code
 ;
 ;
 ;
 ;@ppi-code setfind^%ts
setfind ; set a find (find & replace a substring)
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl&toad;private;procedure;clean;silent;sac;NO tests
 ;@signature
 ; do setfind^%ts(.string,find,replace,flags)
 ;@synonyms
 ; sf^%ts
 ; setFind^%ts
 ;@branches-from
 ; setfind^%ts
 ;@ppi-called-by
 ; findReplace^%ts
 ; findReplaceAll^%ts
 ; check^%wf
 ; insError^%wf
 ; putErrMsg2^%wf
 ; $$replaceHref^%wf [deprecated]
 ; $$replaceSrc^%wf [deprecated]
 ; uncheck^%wf
 ; value^%wf
 ; wsGetForm^%wf
 ; wsCASE^SAMICASE
 ; wsNuForm^SAMICASE
 ; fixHref^SAMIFRM
 ; fixSrc^SAMIFRM
 ; SAMISUBS^SAMIFRM
 ; getHome^SAMIHOME
 ;@called-by: none
 ;@calls
 ; findex^%ts
 ; setex^%ts
 ;@throughput
 ;.string = string to scan & change
 ;.string("low","string") = lowercase version of string to scan & change
 ;.string("extract") = 1 if find & replace succeeded; otherwise 0
 ;  if "a" flag, passed, =1 if succeeded at least once
 ;.string("extract","from") = pos of 1st char of substring set
 ;.string("extract","to") = pos of last char of substring set
 ;@input
 ;.string("extract","from") = pos of 1st char of substring to set
 ;.string("extract","to") = pos of last char of substring to set
 ; find = substring to find in string
 ; replace = substring to replace it with
 ; flags = characters that control how find & replace are done
 ;  a or A = find & replace all instances of find in string
 ;  b or B = set for a backward scan
 ;  i or I = case-insensitive scan [default]
 ;  r or R = refresh lower-case versions of string & replace
 ;@examples
 ;
 ; group 1: Find-and-Replace First & Find-and-Replace Next
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"Kansas","Dorothy")
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="Dorothytoto"
 ;  string("extract")=1
 ;  string("extract","from")=1
 ;  string("extract","to")=7
 ;
 ; followed by
 ;  do setfind^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="DorothyDorothy"
 ;  string("extract")=1
 ;  string("extract","from")=8
 ;  string("extract","to")=14
 ;
 ; followed by
 ;  do setfind^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="DorothyDorothy"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  set string("extract","from")=1
 ;  set string("extract","to")=2
 ;  do setfind^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="toDorothyto"
 ;  string("extract")=1
 ;  string("extract","from")=3
 ;  string("extract","to")=9
 ;
 ;  new string set string="totototo"
 ;  set string("extract","from")=6
 ;  set string("extract","to")=7
 ;  do setfind^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ; group 2: Find Last & Find Previous
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"Kansas","Dorothy","b")
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"toto","Dorothy","b")
 ; produces
 ;  string="totoDorothy"
 ;  string("extract")=1
 ;  string("extract","from")=5
 ;  string("extract","to")=11
 ;
 ; followed by
 ;  do setfind^%ts(.string,"toto","Dorothy","b")
 ; produces
 ;  string="DorothyDorothy"
 ;  string("extract")=1
 ;  string("extract","from")=1
 ;  string("extract","to")=7
 ;
 ; followed by
 ;  do setfind^%ts(.string,"toto","Dorothy","b")
 ; produces
 ;  string="DorothyDorothy"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  set string("extract","from")=7
 ;  set string("extract","to")=8
 ;  do setfind^%ts(.string,"toto","Dorothy","b")
 ; produces
 ;  string="toDorothyto"
 ;  string("extract")=1
 ;  string("extract","from")=3
 ;  string("extract","to")=9
 ;
 ;  new string set string="totototo"
 ;  set string("extract","from")=1
 ;  set string("extract","to")=2
 ;  do setfind^%ts(.string,"toto","Dorothy","b")
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ; group 3: Find Case-Insensitive
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ; followed by
 ;  do setfind^%ts(.string,"Toto","Dorothy","i")
 ; produces
 ;  string="Dorothytoto"
 ;  string("extract")=1
 ;  string("extract","from")=1
 ;  string("extract","to")=7
 ;
 ; followed by
 ;  do setfind^%ts(.string,"Toto","Dorothy","i")
 ; produces
 ;  string="DorothyDorothy"
 ;  string("extract")=1
 ;  string("extract","from")=8
 ;  string("extract","to")=14
 ;
 ; group 4: Boundary Cases
 ;
 ;  new string
 ;  do setfind^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string=""
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string=""
 ;  do setfind^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string=""
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"","Dorothy")
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string=""
 ;  do setfind^%ts(.string,"","Dorothy")
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"toto")
 ; produces
 ;  string="toto"
 ;  string("extract")=1
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"toto","","b")
 ; produces
 ;  string="toto"
 ;  string("extract")=1
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string)
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string
 ;  do setfind^%ts(.string)
 ; produces
 ;  string=""
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"toto","Dorothy","badflag")
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ; group 5: Alternate Signatures
 ;
 ;  new string set string="totototo"
 ;  do sf^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="Dorothytoto"
 ;  string("extract")=1
 ;  string("extract","from")=1
 ;  string("extract","to")=7
 ;
 ; followed by
 ;  do setFind^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="DorothyDorothy"
 ;  string("extract")=1
 ;  string("extract","from")=8
 ;  string("extract","to")=14
 ;
 ; group 6: Find & Replace All
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"Toto","Dorothy","abir")
 ; produces
 ;  string="DorothyDorothy"
 ;  string("extract")=1
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;  new string set string="totototo"
 ;  do setfind^%ts(.string,"Kansas","Dorothy","a")
 ; produces
 ;  string="totototo"
 ;  string("extract")=0
 ;  string("extract","from")=0
 ;  string("extract","to")=0
 ;
 ;@tests: in %tsutfs
 ; setfind01: no next match
 ; setfind02: find first & next
 ; setfind03: find next from
 ; setfind04: no match next from
 ; setfind05: no previous match
 ; setfind06: find last & previous
 ; setfind07: find previous from
 ; setfind08: no match previous from
 ; setfind09: find case-insensitive
 ; setfind10: undefined string
 ; setfind11: empty string
 ; setfind12: empty find
 ; setfind13: empty find & string
 ; setfind14: empty replace
 ; setfind15: empty replace backward
 ; setfind16: empty find & replace
 ; setfind17: empty string, find, & replace
 ; setfind18: bad flag
 ; setfind19: alternate signatures
 ; setfind20: all backward case-insensitive
 ; setfind21: all but no next match
 ;
 ; [description tbd]
 ; find a substring w/in a string & replace w/another
 ; Lowercase version of string is used to scan for matches, & it too is
 ; changed to keep it in synch with string.
 ;
 ; If find & replace succeeds, from & to nodes in string array will be
 ; updated to the new substring's position. If the new substring is the
 ; empty string (that is, if find was simply cut), from & to will be
 ; set to the character before the cut, or if the b flag was passed to
 ; the character after the cut (in support of a backward scan).
 ;
 ; See findex^%tsef & setex^%tses for complete descriptions of how
 ; the parameters control the scan & replacement.
 ;
 ; Find & Replace All: setfind^%ts supports an "a" flag that will repeat
 ; the find & replace until the entire string has been scanned. It
 ; returns string("extract")=1 if at least one successful find+replace
 ; was done, otherwise 0. from & to nodes will always be returned = 0
 ; after Find & Replace All.
 ;
 ;@stanza 2 find & replace
 ;
 set flags=$get(flags)
 new all set all=flags["a"!(flags["A") ; find & replace all?
 set:all flags=$translate(flags,"aA") ; findex & setex don't use A flag
 ;
 new success set success=0 ; did we succeed at least once? not yet
 ;
 new done set done=0
 for  do  quit:done
 . do findex^%ts(.string,$get(find),$get(flags))
 . set done=$get(string("extract"))=0 ; failed to find substring?
 . quit:done  ; if not found, can't replace
 . do setex^%ts(.string,$get(replace),$get(flags)) ; replace
 . set done=$get(string("extract"))=0 ; failed to replace substring?
 . quit:done  ; if failed to replace, can't continue
 . set success=1 ; at least one successful find + replace = success
 . set done='all ; if not replacing all, done after first pass
 . quit
 ;
 set string("extract")=success ; return success or failure
 ;
 set:all flags="a"_flags ; restore A flag when done
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of setfind^%ts
 ;
 ;
 ;
eor ; end of routine %tsfs

%tsfwr
%tsfwr ;ven/toad-type string: findReplace^%ts ;2018-03-18T17:0Z
 ;;1.8;Mash;
 ;
 ; %tsfwr implements MASH String Library ppi findReplace^%ts, which
 ; is a simplified substring find & replace call; it is part of the
 ; String Find Library. It is a wrapper around setfind^%ts.
 ; See %tsutfwr for unit tests for findReplace^%ts.
 ; See %tsud for an introduction to the String library, including an
 ; intro to the String Find Library.
 ; See %tsudf for a detailed map of the String Find library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsfwr contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, gpl&toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;@original-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;
 ;@last-updated: 2018-03-18T17:0Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@to-do
 ; write detailed description of findReplace^%ts
 ; convert to standardized success or failure flag
 ; apply standard string-length protection consistently
 ; develop more examples
 ; write unit tests
 ;
 ;
 ;
 ;@section 1 code
 ;
 ;
 ;
 ;@ppi-code findReplace^%ts
findReplace ; simple substring find & replace
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl&toad;private;procedure;clean;silent;sac;NO tests
 ;@signature
 ; do findReplace^%ts(.string,find,replace,flags)
 ;@branches-from
 ; findReplace^%ts
 ;@ppi-called-by
 ; check^%wf
 ; insError^%wf
 ; putErrMsg2^%wf
 ; $$replaceHref^%wf [deprecated]
 ; uncheck^%wf
 ; value^%wf
 ; wsGetForm^%wf
 ; wsCASE^SAMICAS2
 ; wsNuForm^SAMICAS2
 ; SAMISUBS^SAMIFRM
 ; SAMISUB2^SAMIFRM2
 ; getHome^SAMIHOM2
 ;@called-by: none
 ;@calls
 ; setfind^%ts
 ;@throughput
 ;.string = string to scan & change
 ;@input
 ; find = substring to find in string
 ; replace = substring to replace it with
 ; flags = [deprecated] ignored, will be removed in future version
 ;@examples
 ;
 ;  new string set string="totototo"
 ;  do findReplace^%ts(.string,"Kansas","Dorothy")
 ; produces
 ;  string="totototo"
 ;
 ;  new string set string="totototo"
 ;  do findReplace^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="Dorothytoto"
 ;
 ; followed by
 ;  do findReplace^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="DorothyDorothy"
 ;
 ;  do findReplace^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string="Dorothytoto"
 ;
 ; followed by
 ;  do findReplace^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string="DorothyDorothy"
 ;
 ;  new string
 ;  do findReplace^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string=""
 ;
 ;  new string set string=""
 ;  do findReplace^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string=""
 ;
 ;  new string set string="totototo"
 ;  do findReplace^%ts(.string,"","Dorothy")
 ; produces
 ;  string="totototo"
 ;
 ;  new string set string=""
 ;  do findReplace^%ts(.string,"","Dorothy")
 ; produces
 ;  string=""
 ;
 ;  new string set string="totototo"
 ;  do findReplace^%ts(.string,"toto")
 ; produces
 ;  string="toto"
 ;
 ;  new string set string="totototo"
 ;  do findReplace^%ts(.string)
 ; produces
 ;  string="totototo"
 ;
 ;  new string
 ;  do findReplace^%ts(.string)
 ; produces
 ;  string=""
 ;
 ;@tests: in %tsutfwr
 ; findrep01: no next match
 ; findrep02: find first & next
 ; findrep03: find case-insensitive
 ; findrep04: undefined string
 ; findrep05: empty string
 ; findrep06: empty find
 ; findrep07: empty find & string
 ; findrep08: empty replace
 ; findrep09: empty find & replace
 ; findrep10: empty string, find, & replace
 ;
 ; find a substring w/in a string & replace w/another, case-insensitive
 ;
 ; If string contains find, ignoring the case of any letters included,
 ; the first instance of it w/in string will be replaced by replace. If
 ; the new substring is the empty string (that is, if find was simply
 ; cut), the first instance of find w/in string will be removed. If
 ; string or find are empty, findReplace^%ts will not change string,
 ; other than to ensure it is defined.
 ;
 ;@stanza 2 call setfind^%ts
 ;
 new result set result=$get(string)
 do setfind^%ts(.result,$get(find),$get(replace),"i")
 set string=result
 ;
 ;@stanza 5 termination
 ;
 quit  ; end of findReplace^%ts
 ;
 ;
 ;
eor ; end of routine %tsfwr

%tsfwra
%tsfwra ;ven/toad-type string: findReplaceAll^%ts ;2018-03-18T16:48Z
 ;;1.8;Mash;
 ;
 ; %tsfwra implements MASH String Library ppi findReplaceAll^%ts,
 ; which is a simplified substring find & replace call; it is part of
 ; the String Find Library. It is a wrapper around setfind^%ts.
 ; See %tsutfwra for unit tests for findReplaceAll^%ts.
 ; See %tsud for an introduction to the String library, including an
 ; intro to the String Find Library.
 ; See %tsudf for a detailed map of the String Find library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsfwra contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, gpl&toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;@original-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;
 ;@last-updated: 2018-03-18T16:48Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@to-do
 ; write detailed description of findReplaceAll^%ts
 ; convert to standardized success or failure flag
 ; apply standard string-length protection consistently
 ; develop more examples
 ; write unit tests
 ;
 ;
 ;
 ;@section 1 code
 ;
 ;
 ;
 ;@ppi-code findReplaceAll^%ts
findReplaceAll ; simple substring find & replace all
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl&toad;private;procedure;clean;silent;sac;NO tests
 ;@signature
 ; do findReplaceAll^%ts(.string,find,replace)
 ;@branches-from
 ; findReplaceAll^%ts
 ;@ppi-called-by
 ; $$replaceSrc^%wf [deprecated]
 ; wsCASE^SAMICASE
 ; wsNuForm^SAMICASE
 ; fixHref^SAMIFRM
 ; fixSrc^SAMIFRM
 ; SAMISUBS^SAMIFRM
 ; fixHref^SAMIFRM2
 ; fixSrc^SAMIFRM2
 ; getHome^SAMIHOME
 ;@called-by: none
 ;@calls
 ; setfind^%ts
 ;@throughput
 ;.string = string to scan & change
 ;@input
 ; find = substring to find in string
 ; replace = substring to replace it with
 ;@examples
 ;
 ;  new string set string="totototo"
 ;  do findReplaceAll^%ts(.string,"Kansas","Dorothy")
 ; produces
 ;  string="totototo"
 ;
 ;  new string set string="totototo"
 ;  do findReplaceAll^%ts(.string,"toto","Dorothy")
 ; produces
 ;  string="DorothyDorothy"
 ;
 ;  do findReplaceAll^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string="DorothyDorothy"
 ;
 ;  new string
 ;  do findReplaceAll^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string=""
 ;
 ;  new string set string=""
 ;  do findReplaceAll^%ts(.string,"Toto","Dorothy")
 ; produces
 ;  string=""
 ;
 ;  new string set string="totototo"
 ;  do findReplaceAll^%ts(.string,"","Dorothy")
 ; produces
 ;  string="totototo"
 ;
 ;  new string set string=""
 ;  do findReplaceAll^%ts(.string,"","Dorothy")
 ; produces
 ;  string=""
 ;
 ;  new string set string="totototo"
 ;  do findReplaceAll^%ts(.string,"toto")
 ; produces
 ;  string=""
 ;
 ;  new string set string="totototo"
 ;  do findReplaceAll^%ts(.string)
 ; produces
 ;  string="totototo"
 ;
 ;  new string
 ;  do findReplaceAll^%ts(.string)
 ; produces
 ;  string=""
 ;
 ;
 ;@tests: in %tsutfwra
 ; findrepa01: no next match
 ; findrepa02: find first & next
 ; findrepa03: find case-insensitive
 ; findrepa04: undefined string
 ; findrepa05: empty string
 ; findrepa06: empty find
 ; findrepa07: empty find & string
 ; findrepa08: empty replace
 ; findrepa09: empty find & replace
 ; findrepa10: empty string, find, & replace
 ;
 ; find a substring w/in a string & replace every instance of it
 ; w/another, case-insensitive
 ;
 ; If string contains find, ignoring the case of any letters included,
 ; every instance of it w/in string will be replaced by replace. If
 ; the new substring is the empty string (that is, if find was simply
 ; cut), every instance of find w/in string will be removed. If
 ; string or find are empty, findReplaceAll^%ts will not change string,
 ; other than to ensure it is defined.
 ;
 ;@stanza 2 call setfind^%ts
 ;
 new result set result=$get(string)
 do setfind^%ts(.result,$get(find),$get(replace),"ai")
 set string=result
 ;
 ;@stanza 5 termination
 ;
 quit  ; end of findReplaceAll^%ts
 ;
 ;
 ;
eor ; end of routine %tsfwra

%tsjt
%tsjt ;ven/toad-type string: $$trim^%ts ;2018-03-05T20:49Z
 ;;1.8;Mash;
 ;
 ; %tsjt implements MASH String Library ppi $$trim^%ts, trim character
 ; from end(s) of string; it is part of the String Justify Library.
 ; See %tsutjt for unit tests for $$trim^%ts.
 ; See %tsudj for notes on the String Justify Library.
 ; See %tsud for an introduction to the String library, including an
 ; intro to the String Justify library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsjt contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-05T20:49Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@original-dev: R. Wally Fort (rwf)
 ;@original-dev-org: U.S. Department of Veterans Affairs
 ; prev. Veterans Administration
 ; National Development Office in San Francisco (vaisf)
 ;
 ;@to-do
 ; apply standard string-length protection consistently
 ;
 ;
 ;
 ;@section 1 code
 ;
 ;
 ;
 ;@ppi-code $$trim^%ts
trim ; trim character from end(s) of string
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;isf/rwf,ven/toad;private;function;clean;silent;sac;100% tests
 ;@signatures
 ; $$trim^%ts(string)
 ; $$trim^%ts(string,end)
 ; $$trim^%ts(string,end,char)
 ;@branches-from
 ; $$trim^%ts
 ;@called-by: none
 ;@calls
 ; $$u^%ts
 ;@input
 ; string = string to edit
 ; end = L for left, R for right, LR for both, default to both
 ; char = character to trim, default to space
 ;@output = edited string
 ;@examples
 ; write "[",$$trim^%ts("  A B C  "),"]" => [A B C]
 ; write "[",$$trim^%ts("  A B C  ","LR"),"]" => [A B C]
 ; write "[",$$trim^%ts("  A B C  ","L"),"]" => [A B C  ]
 ; write "[",$$trim^%ts("  A B C  ","R"),"]" => [  A B C]
 ; write "[",$$trim^%ts("  A B C  ",""),"]" => [  A B C  ]
 ; write "[",$$trim^%ts("      "),"]" => []
 ; write "[",$$trim^%ts("  A B C  ",,"/"),"]" => [  A B C  ]
 ; write "[",$$trim^%ts("//A B C//",,"/"),"]" => [A B C]
 ; write "[",$$trim^%ts("","LR","/"),"]" => []
 ;@tests: in %tsutrt
 ; trim01: trim spaces from both ends
 ; trim02: trim spaces from both ends
 ; trim03: trim spaces from both ends
 ; trim04: trim spaces from beginning
 ; trim05: trim spaces from beginning
 ; trim06: trim spaces from end
 ; trim07: trim spaces from end
 ; trim08: no-op
 ; trim09: something other than a space
 ; trim10: missing second argument
 ; trim11: trim to nothing
 ;
 ;@stanza 2 calculate trim characters from ends
 ;
 ; trim space (or other char) from left, right, or both ends of string
 ;
 set string=$get(string) ; ensure string defined
 set char=$get(char," ") ; default to trimming spaces
 if $translate(string,char)="" quit "" ; nothing but trim?
 set end=$$u^%ts($get(end,"LR")) ; default to both ends
 ;
 new %nr set %nr=$length(string) ; start at right end
 if end["R" do  ; if trimming right end
 . for %nr=$length(string):-1:1 quit:$extract(string,%nr)'=char
 . quit
 ;
 new %nl set %nl=1 ; start at left end
 if end["L" do  ; if trimming left end
 . for %nl=1:1:$length(string) quit:$extract(string,%nl)'=char
 . quit
 ;
 set string=$extract(string,%nl,%nr) ; trim string
 ;
 ;@stanza 3 return & termination
 ;
 quit string ; return trimmed string; end of $$trim^%ts
 ;
 ;
 ;
eor ; end of routine %tsjt

%tsud
%tsud ;ven/toad-type string: documentation ;2018-03-05T20:16Z
 ;;1.8;Mash;
 ;
 ; %tsud is the Mumps String Library's inroductory documentation.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; It contains no executable software.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-05T20:16Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;
 ;
 ;@section 1 string datatype library alphabet
 ;
 ;
 ;
 ; a = ?
 ; b = ?
 ; c = case conversion [& character?]
 ; d = ?
 ; e = extract
 ;   el = left extract
 ;   er = right extract
 ;   em = mid extract
 ; f = find
 ;   fl = left find
 ;   fr = right find
 ;   fm = mid find
 ; f = format
 ; g = ?
 ; h = ?
 ; i = ?
 ; j = justify?
 ; k = ?
 ; l = ?
 ; m = merge
 ; n = ?
 ; o = ?
 ; p = piece
 ; p = pattern
 ; q = ?
 ; r = ?
 ; r = regular expression [x? p for pattern? m for match? f for find?]
 ; s = slice
 ; t = table
 ; u = utility
 ; v = validation
 ; w = walk
 ; x = ?
 ; y = mumps user (programmer) extensions
 ; z = mumps implementor extensions
 ; ? = masking
 ; ? = javascript string library (likewise other std string libraries)
 ;
 ; Case is a concept specific to some alphabets but not others, and
 ; not to any abjads, nor to ideographic or logographic systems,
 ; generally speaking. But it is so important to our alphabets that
 ; we have to leave top-level alphabet room for these functions, which
 ; are called more than any other string functions. It applies to
 ; letters, and includes more cases than Mumps or Unicode supports
 ; (such as small-caps case). It also applies to numbers, though
 ; Mumps & Unicode don't support that either, and even to punctuation.
 ; The Mumps $transform function is important to this library.
 ;
 ; Extract is a Mumps concept that conceives of a string as partitioned
 ; into individual characters. An extract identifies a substring within
 ; a string based on start & end position. Mash generalizes this to 
 ; also include substrings based on start or end position & length. If a
 ; method conceives of strings in terms of characters & substrings in
 ; terms of character positions, then it belongs in the string-extract
 ; library. The Mumps $extract & $find & $length functions, _ operator,
 ; & set $extract command are important to the Extract Library. See also
 ; Slice & Table, & contrast with Find.
 ;
 ; Find conceives of a string as made up of substrings whose values
 ; matter but positions matter only secondarily or not at all; that is,
 ; they can be found and changed. A found substring is called a find, as
 ; in "What a find!" These methods never return character position. Finds
 ; can be replaced (set) or removed (cut) or so on, once or repeatedly,
 ; from part or all of the string. The Mumps [ operator & $transform
 ; function & the Extract Library is important to the Find Library.
 ;
 ; Format is a Mash-wide concept that values can have different
 ; representations, depending on the context. In the case of strings,
 ; Mumps represents them as values w/in Mumps symbol tables and as
 ; string literals w/in Mumps text; indirection operations often
 ; require converting back & forth between these two formats. Likewise,
 ; unix string literals are another common format Mumps software must
 ; be able to convert to and from, as are html string literals, and so
 ; on. This library provides these conversion methods. Although it
 ; (currently) occupies the same alphabet letter with Find, its methods
 ; are named differently, more like the Merge Library. Perhaps
 ; eventualy it should be moved into the Validation Library, which
 ; should be renamed the Value Library, or to a new Representation
 ; Library along with Merge.
 ;
 ; Merge is to structure what Format is to values; the components of a
 ; string may be characters, slices, columns, pieces, & so on, & Mumps
 ; software often needs to convert them from one representation to
 ; another - or to or from arrays or individual named variables. All of
 ; these fan-in & fan-out methods belong in this library.
 ;
 ; Piece is a Mumps concept that conceives of a string as partitioned
 ; into substrings separated by a defined delimiter; these methods all
 ; need to know the value of that delimiter, so the string's pieces can
 ; be counted & identified by their count number. Pieces are analogous
 ; to words & delimiters to spaces (though human-language word parsing
 ; is much more complicated than the Piece Library can handle well.)
 ; The Mumps $piece & $length functions, set $piece command, & _
 ; operator are important to the Piece Library.
 ;
 ; Pattern is a Mumps concept of an abstract representation of the
 ; syntax of a string, used to perform sophisticated string validation
 ; & extraction that other languages accomplish with regular expressions.
 ; The Mumps ? operator is important to the Pattern Library, which has
 ; been extended to include the many pattern-match extensions approved
 ; by the mdc. If the Merge & Format libraries end up moved to a new
 ; Representation Library, Pattern may be moved to a new Match Library.
 ;
 ; Regular Expression is most other languages' equivalent to Mumps
 ; pattern matching. It may join Pattern as part of a new Match Library.
 ;
 ; Slice conceives of a string as made up of some number of substrings
 ; all of which have the same length; these methods all need to know
 ; the slice length, which Extract & Piece & Table can also do but
 ; Find cannot. Slices of 255 characters (to respect 1995 Mumps portable
 ; string length) or 80 or 132 (to respect standard terminal row widths)
 ; or other such slice sizes help to illustrate the value of this
 ; library. Since the slice-length is fixed, slices can be counted &
 ; identified by their count number. The Mumps $extract & $length
 ; functions & [ & _ operators & Extract Library are important to the
 ; Slice library. Slice is a generalization of extract; an extract is
 ; just a group of slices, each of which is 1 character long. See also
 ; Extract & Table.
 ;
 ; Table conceives of a string as made up of some number of fields
 ; arranged into columns, possibly padded (with spaces) in the process;
 ; that is, a string is a row of a table. The difference between slices
 ; & column fields is that slices are all the same length, but each
 ; column can be a different length. These methods all need access to a
 ; column definition that defines each column's length. Like slices,
 ; columns can be counted and identified by their count number. The Mumps
 ; $extract & $length functions & _ operator & the Extract & Justify
 ; libraries are important to the Table Library. The Extract & Slice
 ; libraries are neutral about whether a string is made up of discrete
 ; fields, so they neither require nor rule out the use of padding
 ; operations when inserting or removing substrings; Piece's use of
 ; delimiters strongly suggests the string is made up of fields, but 
 ; thanks to the delimiters no padding is required to insert or remove
 ; those fields; but except in rare cases of fixed-length fields, Table
 ; conceives of columns as fixed-length containers for potentially
 ; variable-length fields, so the Justify Library methods are important
 ; to Table for padding a field to create a column & the Find Library's
 ; Trim method is important to retrieving the field from within the column
 ; by trimming its padding (if any) back off.
 ;
 ; Utility is a Mash concept that includes concepts related not to the
 ; structure of a routine but to its execution & lifecycle, such as errors,
 ; logging, testing, version control, and so on. Every Mash module
 ; includes a utility library.
 ;
 ; Validation is the broader concept of string syntax checking, including
 ; potentially not just the string's patter but also its length & other
 ; characteristics. It is related to subtyping, allowing for more
 ; restrictions to be placed upon a string's contents & for a string to
 ; be tested against those restrictions. For example, the Mumps subscript
 ; type disallows control characters, & the Mumps namevalue type must
 ; adhere to the syntactic requirements of a Mumps name. The Validation
 ; Library is the gateway to all such string checking that goes beyond
 ; pattern matching & regular expressions without yet rising to the
 ; level of named data types. This may be generalized to a Value Library
 ; & fold in the current Format Library.
 ;
 ; Walking is a Mash concept of traversal, which applies to most of its
 ; libraries, in which the primary data structure(s) of its library can
 ; be enumerated and traversed, with operations of some kind performed
 ; on each element in the prescribed order. Walkers are the foundational
 ; components of Mash's more sophisticated extensible frameworks. Strings
 ; may be traversed as characters, finds, pieces, slices, or table
 ; columns, & future such component types may be developed.
 ;
 ; Mumps User (Programmer) Extensions is an MDC concept that every
 ; standard library must include room for local Mumps programming
 ; organizations (which the MDC refers to as Mumps users) to extend
 ; that library with their own innovations. For example, if VA wishes to
 ; add their own VA-specific string methods to Mash, they belong in the
 ; %tsy namespace. Y is the MDC standard prefix for such user extensions,
 ; so %tsy will be the interface routine for any such user-defined
 ; library of string methods, & the code for such methods will be located
 ; w/in %tsy routines.
 ;
 ; Mumps Implementor Extensions is an MDC concept that every
 ; standard library must include room for Mumps implementors to extend
 ; that library with their own innovations. Z is the MDC standard
 ; prefix for such implementor extensions, so %tsz will be the interface
 ; routine for any such implementor-defined library of string methods, &
 ; the code for such methods will be located w/in the %tsz routines.
 ;
 ; Mask is a computer-science concept in which a string may be
 ; accompanied by an abstract version of itself containing characters
 ; that map position by position back to the original string. A mask
 ; may be used to assign truth values to each character, or to hold
 ; case-independent (all upper or all lower, for example) copies of the
 ; same characters, to facilitate case-insensitive find & replace, or
 ; to record pattern codes for each character, or so on, to aid in
 ; complex string analysis & computations. We do not yet know where
 ; in the Mash String Alphabet the Mask functions belong
 ;
 ;
 ;
 ;@section 2 string datatype library vocabulary
 ;
 ;
 ;
 ; Because the String Library is large & growing, creating many points
 ; of contractual rigidity between this library and the rest of the
 ; Mumps system, it is vital to name these methods in ways that leave
 ; plenty of room for future growth. The use of stereotyped method
 ; names that follow predictable patterns overall and patterns within
 ; each sublibrary is encouraged for all Mash libraries, since that
 ; leaves available to future method developers all other possible
 ; method names.
 ;
 ; Likewise, because many of these are fundamental methods likely to
 ; be used often & to be combined into single-line complex expressions,
 ; short names are preferred, so long as clarity is not sacrificed, &
 ; where long names are necessary for clarity, equivalent shorter names
 ; will also be made available. Where conventional string libraries
 ; exist in other languages that are well known or at least likely to be
 ; used often by bilingual Mumps developers, additional method names
 ; will be added to match those standard string-library names. Given the
 ; lack of naming discipline in most such string libraries, this will
 ; come at the cost of future extensibility of the Mash string library,
 ; so it must be done with discretion. The canonical name for each
 ; method will be eight characters or less, with shorter, longer, &
 ; conventional synonyms available for ease of use.
 ;
 ; Consistent with the Mumps language & Mash library patterns, no
 ; function may produce a side effect other than calculating &
 ; returning a value. Procedures will be used for all other methods, so
 ; changes to the Mumps system need not be searched for within Mumps
 ; expressions, only within commands & procedure calls.
 ;
 ; To simplify the structure of this library & make locating desired
 ; functionality more intuitive, a consistent set of string concepts
 ; has been developed, which may be combined to identify methods.
 ; For example, a string is composed of components, which may take
 ; the form of foreground (a substring to be found) & background
 ; (the uninteresting matrix within which the substring exists) or
 ; similarly as interesting pieces & uninteresting delimiters or
 ; interesting fields & uninteresting column padding or as equally
 ; interesting characters or slices. A string may be thought of as
 ; easily assembleable or disassembleable into these components, &
 ; the components may be searched for, located, identified, changed,
 ; & so on.
 ;
 ; If those components are the nouns, the verbs are the operations,
 ; which where possible follow a standard pattern of syntax regardless
 ; of the component being operated upon, such as:
 ;
 ; get: copy values of component from string
 ; set: change values of component in string (or create new ones)
 ; mat: change values of component to background values
 ; cut: remove component from string
 ; put: insert new component into string
 ; net: remove component(s) from string and assign to variable
 ; cnt: count component(s) (string length in component(s))
 ; bld: build some or all of a string from scratch
 ; len: length of component(s) (component length in characters)
 ;
 ; So, for example, getslice will get us the value of the identified
 ; slice of a string, getcol will get us the value of the identified
 ; column, getpiece the value of the piece, and so on. Where get &
 ; mat generally manipulate the values of existing components, cut &
 ; put manipulate the number of such components, set can do either, &
 ; net combines get & cut for convenience of a certain kind of
 ; parsing.
 ;
 ; For methods that do not fit this pattern, intuitive names will be
 ; sought out that fit & extend the suite of methods. Where possible,
 ; new patterns will be developed to continue to make it easy to learn
 ; where to look for any given method.
 ;
 ;
 ;
 ;@section 3 string datatype method-naming patterns
 ;
 ;
 ;
 ; 3.1. The canonical names for the Case-conversion Library elements
 ; will consist of two or three letters to identify the case followed by
 ; the word "case":
 ;
 ; $$upcase^%ts = uppercase
 ; $$lowcase^%ts = lowercase
 ; $$capcase^%ts = capitalized case (capitalize 1st letter of each)
 ; $$invcase^%ts = inverse case (uppers to lowers & lowers to uppers)
 ; $$sencase^%ts = sentence-case (1st letter)
 ;
 ; Their abbreviated forms end in c:
 ;
 ; $$uc^%ts
 ; $$lc^%ts
 ; $$cc^%ts
 ; $$ic^%ts
 ; $$sc^%ts
 ;
 ; Their full names are these:
 ;
 ;    $$upperCase^%ts
 ;    $$lowerCase^%ts
 ;  $$capitalCase^%ts
 ;  $$inverseCase^%ts
 ; $$sentenceCase^%ts
 ;
 ; That left the problem of what to name the two primitive methods for
 ; case conversion; one returns the lowercase alphabet, the other the
 ; uppercase alphabet. For the moment, we decided on:
 ;
 ; $$alphabet^%ts
 ; $$ALPHABET^%ts
 ;
 ; Although these two are trivial functions for now, when Mash is
 ; extended to included character set profiles and localization, they will
 ; become more complex. Eventually - since we may support uppercase
 ; alternate method names - this distinction may fail, so we're looking
 ; at instead using this naming schema:
 ;
 ; $$lowalpha
 ; $$upalpha
 ;
 ; $$lowerAlphabet
 ; $$upperAlphabet
 ;
 ;
 ; 3.2. The canonical names for the Extract Library elements:
 ;
 ; $$getex^%ts = get extract
 ;   setex^%ts = set extract
 ;   matex^%ts = mat extract
 ;   cutex^%ts = cut extract
 ;   putex^%ts = put extract
 ;   netex^%ts = net extract
 ;  findex^%ts = find extract
 ;
 ; Their abbreviated names:
 ;
 ; $$ge^%ts
 ;   se^%ts
 ;   me^%ts
 ;   ce^%ts
 ;   pe^%ts
 ;   ne^%ts
 ;   fe^%ts
 ;
 ; Their full names:
 ;
 ; $$getExtract^%ts
 ;   setExtract^%ts
 ;   matExtract^%ts
 ;   cutExtract^%ts
 ;   putExtract^%ts
 ;   netExtract^%ts
 ;  findExtract^%ts
 ;
 ; Plus industry-convention names, where appropriate:
 ;
 ;  find^%ts = findex^%ts
 ; place^%ts = setex^%ts
 ;
 ; In addition, there will be at least three new groups of extract
 ; functions that are wrappers around the above suite:
 ;
 ; left extracts (1st n characters):
 ;
 ; $$getlex^%ts
 ;   setlex^%ts
 ;   matlex^%ts
 ;   cutlex^%ts
 ;   putlex^%ts
 ;   netlex^%ts
 ;
 ; $$gle^%ts
 ;   sle^%ts
 ;   mle^%ts
 ;   cle^%ts
 ;   ple^%ts
 ;   nle^%ts
 ;
 ; $$getLeftExtract^%ts
 ;   setLeftExtract^%ts
 ;   matLeftExtract^%ts
 ;   cutLeftExtract^%ts
 ;   putLeftExtract^%ts
 ;   netLeftExtract^%ts
 ;
 ; right extracts (last n characters):
 ;
 ; $$getrex^%ts
 ;   setrex^%ts
 ;   matrex^%ts
 ;   cutrex^%ts
 ;   putrex^%ts
 ;   netrex^%ts
 ;
 ; $$gre^%ts
 ;   sre^%ts
 ;   mre^%ts
 ;   cre^%ts
 ;   pre^%ts
 ;   nre^%ts
 ;
 ; $$getRightExtract^%ts
 ;   setRightExtract^%ts
 ;   matRightExtract^%ts
 ;   cutRightExtract^%ts
 ;   putRightExtract^%ts
 ;   netRightExtract^%ts
 ;
 ; mid extracts (n characters starting at position p):
 ;
 ; $$getmex^%ts
 ;   setmex^%ts
 ;   matmex^%ts
 ;   cutmex^%ts
 ;   putmex^%ts
 ;   netmex^%ts
 ;
 ; $$gme^%ts
 ;   sme^%ts
 ;   mme^%ts
 ;   cme^%ts
 ;   pme^%ts
 ;   nme^%ts
 ;
 ; $$getMidExtract^%ts
 ;   setMidExtract^%ts
 ;   matMidExtract^%ts
 ;   cutMidExtract^%ts
 ;   putMidExtract^%ts
 ;   netMidExtract^%ts
 ;
 ; Industry convention names:
 ;
 ;  $$left^%ts = $$getlex
 ; $$right^%ts = $$getrex
 ;   $$mid^%ts = $$getmex
 ;
 ;
 ; 3.3. The canonical names for the Find Library elements:
 ;
 ; $$getfind^%ts = get found substring
 ;   setfind^%ts = set found substring
 ;   matfind^%ts = mat found substring
 ;   cutfind^%ts = cut found substring
 ;   putfind^%ts = put found substring
 ;   netfind^%ts = net found substring
 ;
 ; Their abbreviated names:
 ;
 ; $$gf^%ts
 ;   sf^%ts
 ;   mf^%ts
 ;   cf^%ts
 ;   pf^%ts
 ;   nf^%ts
 ;
 ; Their full names (only different in capitalization):
 ;
 ; $$getFind^%ts
 ;   setFind^%ts
 ;   matFind^%ts
 ;   cutFind^%ts
 ;   putFind^%ts
 ;   netFind^%ts
 ;
 ; Plus industry-convention names, where appropriate:
 ;
 ;     replace^%ts = setfind^%ts
 ; findReplace^%ts = setfind^%ts
 ;  findDelete^%ts = cutfind^%ts
 ;
 ; In addition, there will be at least three new groups of find
 ; functions that are wrappers around the above suite:
 ;
 ; left finds (everything to the left of a found substring):
 ;
 ; $$getlfind^%ts
 ;   setlfind^%ts
 ;   matlfind^%ts
 ;   cutlfind^%ts
 ;   putlfind^%ts
 ;   netlfind^%ts
 ;
 ; $$glf^%ts
 ;   slf^%ts
 ;   mlf^%ts
 ;   clf^%ts
 ;   plf^%ts
 ;   nlf^%ts
 ;
 ; $$getLeftFind^%ts
 ;   setLeftFind^%ts
 ;   matLeftFind^%ts
 ;   cutLeftFind^%ts
 ;   putLeftFind^%ts
 ;   netLeftFind^%ts
 ;
 ; right finds (everything to the right of a found substring):
 ;
 ; $$getrfind^%ts
 ;   setrfind^%ts
 ;   matrfind^%ts
 ;   cutrfind^%ts
 ;   putrfind^%ts
 ;   netrfind^%ts
 ;
 ; $$grf^%ts
 ;   srf^%ts
 ;   mrf^%ts
 ;   crf^%ts
 ;   prf^%ts
 ;   nrf^%ts
 ;
 ; $$getRightFind^%ts
 ;   setRightFind^%ts
 ;   matRightFind^%ts
 ;   cutRightFind^%ts
 ;   putRightFind^%ts
 ;   netRightFind^%ts
 ;
 ; mid finds (everything between two found substrings):
 ;
 ; $$getmfind^%ts
 ;   setmfind^%ts
 ;   matmfind^%ts
 ;   cutmfind^%ts
 ;   putmfind^%ts
 ;   netmfind^%ts
 ;
 ; $$gmf^%ts
 ;   smf^%ts
 ;   mmf^%ts
 ;   cmf^%ts
 ;   pmf^%ts
 ;   nmf^%ts
 ;
 ; $$getMidFind^%ts
 ;   setMidFind^%ts
 ;   matMidFind^%ts
 ;   cutMidFind^%ts
 ;   putMidFind^%ts
 ;   netMidFind^%ts
 ;
 ; We also two functions that have only conventional names, not
 ; systematic ones.
 ;
 ;   $$produce^%ts = repeat find & replace substrings
 ;   $$replace^%ts = find & replace substrings
 ;
 ; setfind's features will be expanded to include $$replace, so that
 ; $$replace can become just an alternate name of findrep. The same
 ; may be done with $$produce.
 ;
 ;
 ; 3.4. For the string-format conversions, again we need both short
 ; & long names. For the short names, we adopt the convention of
 ; identifying the format in question with a secondary alphabet:
 ;
 ; s = Mumps string value (aka "normal" string)
 ; l = Mumps string literal
 ; u = Unix string literal
 ; h = html string literal
 ;
 ; then use the t as a delimiter meaning to:
 ;
 ; $$stl^%ts = Mumps string value => Mumps string literal
 ; $$stu^%ts = Mumps string value => Unix string literal
 ; $$sth^%ts = Mumps string value => HTML string literal
 ; $$lts^%ts = Mumps string literal => Mumps string value
 ; $$uts^%ts = Unix string literal => Mumps string value
 ; $$hts^%ts = HTML string literal => Mumps string value
 ;
 ; The longer, clearer names prepend the word "form" for format:
 ;
 ; $$formstl^%ts
 ; $$formstu^%ts
 ; $$formsth^%ts
 ; $$formlts^%ts
 ; $$formuts^%ts
 ; $$formhts^%ts
 ;
 ; These names need to be standardized.
 ;
 ;
 ; 3.5. String justification is perhaps the second-most used suite of
 ; methods:
 ;
 ; $$rj^%ts = right justify
 ; $$lj^%ts = left justify
 ; $$cj^%ts = center justify
 ;
 ; and for the longer, clearer names:
 ;
 ; $$rjustify^%ts
 ; $$ljustify^%ts
 ; $$cjustify^%ts
 ;
 ; $$$repeat & $$trim need to live here too, because they are used for
 ; the same purposes as the justify functions, to read & write reports
 ; & tables:
 ;
 ; $$repeat^%ts = repeat a character
 ; $$trim^%ts = trim character from end(s) of string
 ;
 ;
 ; 3.6. Merging has its own subalphabet of structural formats:
 ;
 ; a = array
 ; p = pieces
 ; s = slices
 ; t = table
 ; v = variables
 ;
 ; The abbreviations are named on the Merge X=Y metaphor. Some of these
 ; change structures rather than just calculate values, others just
 ; calculate a value, so some are functions & others are procedures.
 ; Most of the combos are not yet written, but these are done or in
 ; progress:
 ;
 ;   aep^%ts = array <= pieces
 ; $$pea^%ts = pieces <= array
 ;   vep^%ts = variables <= pieces
 ; $$pev^%ts = pieces <= variables
 ;   ves^%ts = variables <= slices [unfinished]
 ; $$sev^%ts = slices <= variables [unfinished]
 ;
 ; The longer, clearer names prepend "merge":
 ;
 ;   mergeaep^%ts
 ; $$mergepea^%ts
 ;   mergevep^%ts
 ; $$mergepev^%ts
 ;   mergeves^%ts
 ; $$mergesev^%ts
 ;
 ;
 ; 3.7. The Piece Library does not yet exist, but its core methods will
 ; follow the component-method naming schema for abbreviations:
 ;
 ; $$gp^%ts = get piece, copy value of delimited substring
 ;   sp^%ts = set piece, change (or create) value of delimited substring
 ;   mp^%ts = mat piece, change value of delimited substring to spaces
 ;   cp^%ts = cut piece, remove delimited substring
 ;   pp^%ts = put piece, insert new delimited substring
 ;   np^%ts = net piece, remove delimited substring & assign to variable
 ;
 ; and longer, clearer names:
 ;
 ; $$getpiece^%ts
 ;   setpiece^%ts
 ;   matpiece^%ts
 ;   cutpiece^%ts
 ;   putpiece^%ts
 ;   netpiece^%ts
 ;
 ;
 ; 3.8. The Pattern library will be called often, so we go back to
 ; two-letter abbreviations. Currently, they start with p, but that's
 ; not a sustainable pattern; it should probably be changed to follow
 ; the component pattern using m or pm as its suffix. There's only one
 ; so far:
 ;
 ;      $$pm^%ts = get pattern mask
 ; $$patmask^%ts
 ;
 ; 3.9. The Slice library follows the component-method naming schema:
 ;
 ; $$gs^%ts = get slice(s) of string
 ;   ss^%ts = set slice(s) of string
 ;   ms^%ts = mat-out slice(s) in string
 ;   cs^%ts = cut slice(s) from string
 ;   ps^%ts = put new slice(s) into string
 ;
 ; and
 ;
 ; $$getslice^%ts
 ;   setslice^%ts
 ;   matslice^%ts
 ;   cutslice^%ts
 ;   putslice^%ts
 ;
 ;
 ; 3.9. The Table Library is also named according to the component-
 ; method schema, where the component is a column:
 ;
 ; $$hc^%ts = build header row of columns from table definition
 ; $$rc^%ts = build row of columns from table definition
 ;   sc^%ts = set column into table row
 ; $$lc^%ts = length of column
 ; $$jc^%ts = justify a field to create a column
 ;
 ; $$hdrcolumn^%ts
 ; $$rowcolumn^%ts
 ;   setcolumn^%ts
 ; $$lencolumn^%ts
 ; $$juscolumn^%ts
 ;
 ; There are a lot more methods planned for tables, but their names
 ; have not yet fully been baked as ideal extensions of this suite.
 ;
 ;
 ; 3.10. The Validation Library is not yet named coherently & so far
 ; includes but a single function:
 ;
 ;       $$vg^%ts = validate graphic string
 ; $$vgraphic^%ts
 ;
 ; And then there are these two functions that probably belong in the
 ; Validation Library
 ;
 ;      $$only^%ts = only keep character(s) in string
 ;     $$strip^%ts = strip character(s) from string
 ;
 ;
 ; 3.11. The map of these apis with the code that implements them
 ; can be found in routine ^%ts.
 ;
 ;
 ;
 ;@section 4 string datatype library contents & to-do
 ;
 ;
 ;
 ; On 2018-02-22 I reset the contents of the String library to only
 ; include methods with 90% or better coverage by unit tests.
 ;
 ;@module-contents
 ; %ts: mumps string library apis
 ; %tsc: string-case tools
 ;[%tse: string-extract tools]
 ;  %tsef: find position of substring
 ;  $tses: set extract, change value of positional substring
 ;[%tsf: string-find tools]
 ;  %tsfs: setfind, find & replace substring
 ;[%tsj: string-justify tools]
 ;  $tsjt: trim character from end(s) of string
 ;[%tsu: utilities for the string datatype library]
 ;  %tsud: documentation
 ;   %tsudf: find notes
 ;  %tsul: primary development log
 ;  %tsut: nunit (unit tests & code coverage for string methods)
 ;   %tsutef: unit tests for find^%ts
 ;   $tsutes: unit tests for setextract^%ts
 ;   %tsutfs: unit tests for findrep^%ts
 ;   %tsutjt: unit tests for $$trim^%ts
 ;   %tsutvs: unit tests for $$strip^%ts
 ;[%tsv: string-validation tools]
 ;  %tsvs: strip character(s) from string
 ;
 ;@to-do
 ; bring over methods & create unit tests for them
 ; %tse: get extract, set extract, cut extract, put extract
 ;   $$left
 ;   $$right
 ;   $$mid
 ; %tsp: get piece, set piece, cut piece, put piece
 ; %tspm: pattern-match extensions
 ;   get pattern
 ;   get pattern mask
 ;   pattern-match string extraction
 ;   pattern negation
 ;   pattern alternation
 ;   character-set-driven pattern codes
 ; %tsre?: regular expressions
 ; %tsw: string walkers
 ; %ts?: masking functions
 ; Javascript methods:
 ;   http://www.w3schools.com/js/js_string_methods.asp
 ; make negative work from end backward
 ;
 ;@module-contents [on shelf]
 ; %ts: mumps string library apis [larger shelved version]
 ; %tsf: string-find tools
 ;  %tsfp: produce, repeat find & replace substrings, fold into setfind
 ;  %tsfs: replace, find & replace substrings, fold into %tsfs, setfind
 ; %tsf: string-format tools
 ;  %tsfhs: format html string as normal string
 ;  %tsfls: format string literal as normal string
 ;  %tsfsh: format string as html string
 ;  %tsfsl: format string as string literal
 ;  %tsfsu: format string as unix string
 ;  %tsfus: format unix string as normal string
 ; %tsj: string-justify tools
 ; %tsm: string-merge tools
 ;  %tsmap: merge array = pieces
 ;  %tsmpa: merge pieces = array
 ;  %tsmpv: merge pieces = variables
 ;  %tsmsv: merge slices = variables
 ;  %tsmvp: merge variables = pieces
 ;  %tsmvs: merge variables = slices
 ; %tsp: string-piece tools
 ; %tspm: string-pattern-match tools
 ; %tss: string-slice tools
 ;  %tssc: cut slice(s) from string
 ;  %tssg: get slice(s) of string
 ;  %tssm: mat-out slice(s) in string
 ;  %tssp: put new slices into string
 ;  %tsss: set slice(s) of string
 ; %tst: string-table tools
 ;  %tsthc: build header row of columns from table definition
 ;  %tstjc: justify a field to create a column
 ;  %tstlc: length of column
 ;  %tstrc: build row of columns from table definition
 ;  %tstsc: set column into table row
 ; %tsv: string-validation tools
 ;  %tsvo: only keep character(s) in string
 ; %tsu: utilities for the string datatype library
 ;  %tsum: meters (timers for string methods)
 ;
 ;
 ;
eor ; end of routine %tsud

%tsudf
%tsudf ;ven/toad-type string: documentation, find ;2018-03-18T16:37Z
 ;;1.8;Mash;
 ;
 ; %tsud introduces the public string datatype Find Library,
 ; whose code is implemented in the %tsf* routines.
 ; See %tsud for documentation introducing the String Library,
 ; including an intro to the String Find library.
 ; See %tsutf* for the unit tests for the Find Library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; It contains no executable software.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-18T16:37Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@contents
 ;
 ;        setfind^%ts = set found substring (find & replace)
 ;             sf^%ts
 ;        setFind^%ts
 ;  code = %tsfs
 ;  tests = %tsutfs
 ;
 ;    findReplace^%ts
 ;  code = %tsfwr
 ;  tests = %tsutfwr
 ;
 ; findReplaceAll^%ts
 ;  code = %tsfwra
 ;  tests = %tsutfwra
 ;
 ;
 ;
 ;@section 1 Find Library notes
 ;
 ;
 ;
 ;@alphabet
 ;
 ; a = ?
 ; b = ?
 ; c = cut find [cf]
 ;   cl = cut left find [clf]
 ;   cr = cut right find [crf]
 ;   cm = cut mid find [cmf]
 ; d = ?
 ; e = ?
 ; f = ?
 ; g = get find? [gf]
 ;   gl = get left find [glf]
 ;   gr = get right find [grf]
 ;   gm = get mid find [gmf]
 ; h = ?
 ; i = ?
 ; j = ?
 ; k = ?
 ; l = ?
 ; m = mat find [mf]
 ;   ml = mat left find [mlf]
 ;   mr = mat right find [mrf]
 ;   mm = mat mid find [mmf]
 ; n = net find [nf]
 ;   nl = net left find [nlf]
 ;   nr = net right find [nrf]
 ;   nm = net mid find [nmf]
 ; o = ?
 ; p = put find [pf]
 ;   pl = put left find [plf]
 ;   pr = put right find [prf]
 ;   pm = put mid find [pmf]
 ; r = ?
 ; s = set find (findReplace) [sf]
 ;   sl = set left find [slf]
 ;   sr = set right find [srf]
 ;   sm = set mid find [smf]
 ; t = ?
 ; u = utilities
 ; v = ?
 ; w = wrappers [simplified ways of calling main calls]
 ;   wd = findDelete
 ;   wdb = findDeleteBetween
 ;   wr = findReplace
 ;   wra = findReplaceAll
 ; x = ?
 ; y = user extensions
 ; z = implementor extensions
 ;
 ;
 ;@to-do
 ;
 ; create cutMidFind [deleteBetween]
 ; bring over & write unit tests for:
 ;  $$produce^%ts
 ;  $$replace^%ts
 ; revise $$replace to accept multiple strings [JJOHCASE & DILF]
 ; revise $$produce to accept multiple strings
 ; write the rest of the methods
 ; add max length protection to $$produce
 ;
 ;
 ; compare typical namespacing schema
 ;
 ; get: copy values of component from string
 ; set: change values of component in string (or create new ones)
 ; mat: change values of component to background values
 ; cut: remove component from string
 ; put: insert new component into string
 ; net: remove component(s) from string and assign to variable
 ; cnt: count component(s) (string length in component(s))
 ; bld: build some or all of a string from scratch
 ; len: length of component(s) (component length in characters)
 ;
 ;
 ; on the shelf
 ;
 ; $$produce^%ts
 ;  code = %tsrp => %tsfs
 ;  tests = %tsutp => %tsutfs
 ;
 ; $$replace^%ts
 ;  code = %tsrr => %tsfs
 ;  tests = %tsutr => %tsutfs
 ;
 ; setfind's features will be expanded to include $$replace, so that
 ; $$replace can become just an alternate name of setfind. The same
 ; may be done with $$produce.
 ;
 ;
 ; The canonical names for the Find Library elements:
 ;
 ; $$getfind^%ts = get found substring
 ;   matfind^%ts = mat found substring
 ;   cutfind^%ts = cut found substring
 ;   putfind^%ts = put found substring
 ;   netfind^%ts = net found substring
 ;
 ; Their abbreviated names:
 ;
 ; $$gf^%ts
 ;   mf^%ts
 ;   cf^%ts
 ;   pf^%ts
 ;   nf^%ts
 ;
 ; Their full names (only different in capitalization):
 ;
 ; $$getFind^%ts
 ;   matFind^%ts
 ;   cutFind^%ts
 ;   putFind^%ts
 ;   netFind^%ts
 ;
 ; Plus industry-convention names, where appropriate:
 ;
 ; findReplace^%ts = setfind^%ts
 ; findDelete^%ts = cutfind^%ts
 ;
 ; In addition, there will be at least three new groups of find
 ; functions that are wrappers around the base suite:
 ;
 ; left finds (everything to the left of a found substring):
 ;
 ; $$getlfind^%ts
 ;   setlfind^%ts
 ;   matlfind^%ts
 ;   cutlfind^%ts
 ;   putlfind^%ts
 ;   netlfind^%ts
 ;
 ; $$glf^%ts
 ;   slf^%ts
 ;   mlf^%ts
 ;   clf^%ts
 ;   plf^%ts
 ;   nlf^%ts
 ;
 ; $$getLeftFind^%ts
 ;   setLeftFind^%ts
 ;   matLeftFind^%ts
 ;   cutLeftFind^%ts
 ;   putLeftFind^%ts
 ;   netLeftFind^%ts
 ;
 ; right finds (everything to the right of a found substring):
 ;
 ; $$getrfind^%ts
 ;   setrfind^%ts
 ;   matrfind^%ts
 ;   cutrfind^%ts
 ;   putrfind^%ts
 ;   netrfind^%ts
 ;
 ; $$grf^%ts
 ;   srf^%ts
 ;   mrf^%ts
 ;   crf^%ts
 ;   prf^%ts
 ;   nrf^%ts
 ;
 ; $$getRightFind^%ts
 ;   setRightFind^%ts
 ;   matRightFind^%ts
 ;   cutRightFind^%ts
 ;   putRightFind^%ts
 ;   netRightFind^%ts
 ;
 ; mid finds (everything between two found substrings):
 ;
 ; $$getmfind^%ts
 ;   setmfind^%ts
 ;   matmfind^%ts
 ;   cutmfind^%ts
 ;   putmfind^%ts
 ;   netmfind^%ts
 ;
 ; $$gmf^%ts
 ;   smf^%ts
 ;   mmf^%ts
 ;   cmf^%ts
 ;   pmf^%ts
 ;   nmf^%ts
 ;
 ; $$getMidFind^%ts
 ;   setMidFind^%ts
 ;   matMidFind^%ts
 ;   cutMidFind^%ts
 ;   putMidFind^%ts
 ;   netMidFind^%ts
 ;
 ;
 ;
eor ; end of routine %tsudf

%tsul
%tsul ;ven/toad-type string: development log ;2018-03-24T22:02Z
 ;;1.8;Mash;
 ;
 ; %tsul is the Mumps String Library's primary-development log.
 ; See %tsud for documentation introducing the library.
 ; See %ts for the module's ppis & apis.
 ; It contains no executable software.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-24T22:02Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@module-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@original-dev: Ed de Moel (edm)
 ;@additional-dev: Richard Walters (rw)
 ;@additional-dev: Alfons Puig (ap)
 ;@additional-dev: Jon Diamond (jd)
 ;@additional-dev: Arthur B. Smith (abs)
 ;@additional-dev: David J. Marcus (djm)
 ;@additional-dev: David J. Whitten (djw)
 ;@additional-dev: Alan Frank (af)
 ;@additional-dev: Victor Grishkan (vg)
 ;@additional-dev: R. Wally Fort (rwf)
 ;@additional-dev: Zach Gonzales (kbaz/zag)
 ;@additional-dev: Ed de Moel (edm)
 ;@additional-dev: Ken McGlothlen (mcglk)
 ; mcglk@vistaexpertise.net
 ;@additional-dev: Linda M. R. Yaw (lmry)
 ; lmry@vistaexpertise.net
 ;
 ;@original-dev-org: Mumps Development Committee (mdc)
 ;@additional-dev-org: U.S. Department of Veterans Affairs
 ; prev. Veterans Administration
 ; National Development Office in San Francisco (vaisf)
 ;@additional-dev-org: VA Puget Sound Health Care System (vapug) 
 ; [many more, fill in later]
 ;
 ;@project-credits
 ;@project: Mumps Development Committee (mdc)
 ;@project: eHealth Exchange Prefetch (ehex)
 ;@project: Electronic Health Management Platform (ehmp)
 ;@project: Taskman Version 9 (tm9)
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (va-pals)
 ; http://va-pals.org/
 ;
 ;@funding: 1987/1998, many many mdc organizations & individuals
 ;@funding: 1994/2006, vaisf
 ;@funding: 2002, vapug
 ;@funding: 2012/2018, toad
 ;@funding: 2012/2018, ven
 ;@funding: 2016/2017, Electronic Health Solutions (ehs)
 ; http://ehs.com.jo
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 1987-11/1995-10 mdc/edm: create PRODUCE Library Function & REPLACE
 ; Library Function to add to standard code library $%PRODUCE^STRING &
 ; $%REPLACE^STRING, proposals based on separate initial proposals by
 ; Richard Walters (mdc) and Alfons Puig (mdcc-e), include sample code
 ; for implementing these functions, approved by mdc, final extension
 ; documents x11/95-11 & x11/95-112.
 ;
 ; 1988-12/1998-06 mdc/djm&djw: create Data Record Functions to add to
 ; standard language $DPIECE & $DEXTRACT intrinsic functions, approved
 ; by mdc, final extension document x11/sc13/tg3/98-4.
 ;
 ; 1992/1996-02 mdc/af&djw&jd&vg: create Pattern Negation to upgrade
 ; standard language pattern-language operator, approved by mdc, final
 ; extension document x11/96-9.
 ;
 ; 1992/1997-01 mdc/af&djw&jd&vg: create Pattern Ranges to upgrade
 ; standard language pattern-language operator, approved by mdc, final
 ; extension document x11/97-3.
 ;
 ; 1993-07/1998-08 mdc/abs: create Pattern Match String Extraction to
 ; extend mumps patter-match operator, approved by mdc, final extension
 ; document x11/98-27.
 ;
 ; 1994-11-04 vaisf/rwf XU*8.0 XLFSTR: create routine. $$UP, $$LOW,
 ; $$STRIP, $$REPEAT, $$INVERT, $$REPLACE, $$RJ, $$LJ, $$CJ, $$QUOTE.
 ;
 ; ca. 1995 vaisf/toad DILF: create $$HTML to convert ^ and & in
 ; strings for use in HTML; create $$TRANSL8 to implement
 ; $%REPLACE to support $$HTML.
 ;
 ; 1996-03/1998-07 mdc/jd: create Miscellaneous Character Functions to
 ; formalize extending mumps standard to add to standard code library
 ; $%UPPER^STRING, $%LOWER^STRING, & $%PATCODE^STRING, approved by mdc,
 ; final extension document x11/98-21.
 ;
 ; 1999-02-23 vaisf/rwf XU*8*112 XLFSTR: add $$TRIM(x[,"[L][R]"]) to trim
 ; spaces from left, right, or both of string.
 ;
 ; 1999-06-17 vaisf/rwf XU*8*120 XLFSTR: add third param to $$TRIM to
 ; trim character other than space.
 ;
 ; 2002-03-13/14 vapug/toad ARJT*8*2 XLFSTR2: create routine. $$SEN,
 ; $$CAP, FIELDX.
 ;
 ; 2005-12-28 vaisf/rwf XU*8*400 XLFSTR: add $$SENTENCE & $$TITLE.
 ; based on design by sea/toad.
 ;
 ; 2006-12-19 vaisf/rwf XU*8*437 XLFSTR: add $$SPLIT. Fix bug in
 ; $$TRIM to trim spaces from " " properly.
 ;
 ; 2009-08-01/31 kbaz/zag v1.0 JJOHCASE: create routine as part of
 ; Paideia training, incl multiple string case-conversion & translation
 ; subroutines.
 ;
 ; 2012-04-24 kbaz/zag & ven/toad XVDSTR: create routine with FIELDX.
 ; add $$ESCAPE to convert strings for use with the unix enviroment to
 ; escape special characters.
 ;
 ; 2012-06-07 kbaz/zag & ven/toad XVDSTR: add ";" to the list of
 ; characters to escape.
 ;
 ; 2012-06-08 kbaz/zag & ven/toad %*0.1 XVDSTR: add "|" to the list of
 ; characters to escape.
 ;
 ; 2013-08-23 ven/toad XU*8.0*local XLFSTR2: add $$VALID, change
 ; history, header, EOR.
 ;
 ; 2015-06-05 ven/toad %*1.0 %sm: create routine. pta.
 ;
 ; 2015-11-12/13 ven/toad %*0.5 %s: fix version at 0.5; create routine
 ; w/ functions from XLFSTR, XLFSTR2, XVDSTR, & %sm. lowercase labels.
 ; delete fieldx; keep pta. upgrade & refactor $$title; remove $$cap.
 ; refactor $$sentence; remove $$sen. refactor $$up, $$low, $$strip,
 ; $$repeat. rename $$up -> $$uc, $$low -> $$lc, wrap w/ $$upcase,
 ; $$lowcase, rename $$sentence -> $$sc, $$title -> $$cc, wrap w/
 ; $$sencase, $$capcase. wrap pta w/ mergepta. convert $$split to
 ; procedure. rename split -> ptv, wrap w/ mergeptv.
 ;
 ; 2015-12-18/22 ven/toad %*0.5 %s: add missing string-merge tools to
 ; to-do list; finish building contents section; add to-do items from
 ; routine JJOHCASE; add it & produce & replace to history; delete
 ; $$quote & add to to-do list; rename $$escape -> $$unix; add $$HTML
 ; from routine DILF to to-do list; create $$alphabet & $$ALPHABET &
 ; use them; create $$ic & $$invcase from INVERT^JJOHCASE. Fix calls to
 ; $$lc & $$uc in $$sc & $$cc; comment %%uc, %%lc, $$ic, $$sc, $$cc;
 ; refactor $$rj, $$rjustify, $$lj, $$ljustify, $$cj, $$cjustify; create
 ; padtrunc, ctv, mergectv.
 ;
 ; 2016-01-31/02-09 ven/toad %*0.6 %ts: bump version to 0.6; create
 ; from %s; renamespace from %a* to %g*; add column-merge subroutines
 ; to to-do list; loosen namespaces of local variables, keep w/in %,
 ; focus on readability & brevity; refine comments; refactor & add
 ; defaults & max lengths to padtrunc, $$rj, $$lj, $$cj, $$repeat,
 ; $$strip; refactor $$trim; rewrite $$replace based on mdc/edm's
 ; $%replace^string proposal x11/1995-112, add isf/rwf's first few
 ; lines, split %spec into %find & %replace to support top-level
 ; params, define $$replace using examples in comments; temporarily
 ; fold in TRANSL8* subroutines for reference; create $$produce based
 ; on mdc/edm's $%produce^string proposal x11/1995-111, add rwf's 1st
 ; few lines from $$replace, split spec into %find & %replace, add
 ; support for top-level params; refactor $$unix -> $$stu; bring back &
 ; refactor rwf's $$QUOTE as $$stl; create $$sth from $$HTML^DILF,
 ; refactor, change encoded characters to the five standard ones -
 ; "&<>' - of modern html and xml; also create $$hts from $$HTML^DILF;
 ; create $$lts to convert a string literal back to a normal string
 ; (we've written this before in Fileman, though examples currently
 ; escape me); make $$stu only allow a single character (not a
 ; substring) to be used to escape; create $$uts to undo $$stu;
 ; refactor $$valid; add new to $$pta, more comments in pta, ptv, ctv;
 ; overhaul ptv and ctv; write $$atp; invert order of target and source
 ; in merge params to match merge command, rename from sourceTtarget to
 ; targetEsource, e.g., vec, edit call to $$ctv in $$cj to $$vec;
 ; overhaul aep; write $$pev; rename chunks to slices; write $$sev,
 ; $$mergesev, $$getslice, $$gs, add primitive operations (get, set,
 ; cut, put for extracts, pieces, slices, columns) to to-do list, add
 ; to to-do list negative positional params, distinguish slice length
 ; from string length in slices; $$uc -> $$u, $$lc -> $$l, $$ic -> $$i,
 ; $$sc -> $$s, $$cc -> $$c; write setslice, ss; add matslice &
 ; netslice to to-do list; write $$ms, $$matslice, cs, cutslice, ps,
 ; putslice. in $$s, $$l, $$i, $$s, $$c, padtrunc, $$rj, $$lj, $$cj,
 ; $$repeat, $$strip, $$trim, $$replace, $$TRANSL81, $$TRANSL8,
 ; $$TRNSL8S, $$produce, $$stu, $$uts, $$sth, $$hts, $$stl, $$lts,
 ; $$valid, $$gs, $$getslice, ss, setslice, ms, matslice, ps, putslice,
 ; aep, $$pea, $$mergepea, vep, $$pev, ves.
 ;
 ; 2016-03-01 ven/toad %*1.5 %ts: bump version to 1.5; upgrade comments
 ; to providing testing examples & list missing apis.
 ;
 ; 2016-03-11 ven/toad %*1.5 %ts,%tslice,%tslog: in contents, map out
 ; names of routines to break %ts content into. Add header
 ; introduction. Move bodies of string-slice subroutines to new routine
 ; %tslice. Move primary-development history to routine %tslog.
 ;
 ; 2016-03-11 ven/mcglk&toad %*1.5 %tsu: created routine to hold unit
 ; tests for MASH's string-type library, starting with $$trim &
 ; $$strip.
 ;
 ; 2016-04-04/05 ven/toad %*1.5 %ts,%tscol,%tslice: created routine %tscol to
 ; hold string-column subroutines; fix bug with set $extract in $$stl;
 ; fix bug with call to $$repeat^%ts in ms^%tslice; fix examples in
 ; $$stl^%ts.
 ;
 ; 2016-12-23/24 ven/toad %*1.7D01 %ts,%tsc,%tse,%tsf,%tsfhs,%tsfls,%tsfsh,
 ; %tsfsl,%tsfsu,%tsfus,%tsj,%tsm,%tsmap,%tsmpa,%tsmpv,%tsmsv,%tsmvp,
 ; %tsmvs,%tslice,%tsr,%tsrp,%tsrr,%tss,%tssc,%tssg,%tssm,%tssp,%tsss,
 ; %tst,%tsthc,%tstjc,%tstlc,%tstrc,%tstsc,%tsv: 
 ; design more methodical routine organization based on string
 ; alphabet, break up big string-library routines into small routines;
 ; replace %tscol with %tst* routines; apply new @API standard; fix
 ; breakup bugs in $$trim^%ts & throughout %tsc.
 ;
 ; 2017-04-27 ven/lmry %*1.7T02 %ts*: bump version to 1.7T02; stdize
 ; hdr lines.
 ;
 ; 2017-04-27 ven/lmry %*1.7T02 %tsfhs,tsfsh: update $$replace w/
 ; $$replace^%tsrr.
 ;
 ; 2017-04-27 ven/lmry %*1.7T02 %tsj: update ves w/ mergeves^%tsmvs.
 ;
 ; 2017-04-27 ven/lmry %*1.7T02 %tssp: update ss w/ setslice^%tsss.
 ;
 ; 2017-05-25 ven/toad %*1.7T02 %ts*: update dates & chg history.
 ;
 ; 2017-08-31 ven/toad %*1.7T03 %ts,%tsp: bump version to 1.7T03; add
 ; patmask^%ts & pm^%ts & patmask^%tspm; move $$strip & $$trim from
 ; %tse to %tsrs & %tsrt, update to using @tags, add examples to
 ; $$strip; reorder apis in %ts alphabetically; add $$only^%ts &
 ; only^%tsro; create %tsurs & %tsurt to hold unit tests for $$strip &
 ; $$trim^%ts, change %tsu into a unit-test shell routine, & add
 ; cover^%tsu to run code-coverage.
 ;
 ; 2018-02-21/03-04 ven/toad %*1.8T04 %tsul,%tsud: rename %tslog =>
 ; %tsul; create %tsud; bump version to 1.8T04; update to more modern
 ; mash style; expand history to include rest of mdc string library &
 ; function extensions; move to-do to %tsul; list Javascript string
 ; methods. Reset String library to only include methods that have
 ; unit tests. Move to-do & module-contents to %tsud.
 ;  %tsudr: move %tsr => %tsudr, update style, cut redundant, add to
 ; notes.
 ;  %tsrt: update style, clearer variable names, protect vs. undef
 ; string, stanza notation.
 ;  %ts: reset w/no apis, restore $$trim,$$strip, case-conversion
 ; apis. add setextract,se,place,find.
 ;  %tsut: rename %tsu => %tsut, update style, chg cover^%tsut to use
 ; new unit-test routine, add cover## tests for no-entry-at-top quits,
 ; exclude cover^%tsut from coverage.
 ;  %tsurt: rename %tsurt => %tsutrt, update style.
 ;  $tsrs: update style, clearer variable names, stanza notation.
 ;  %tsutrs: rename %tsurs => %tsutrs, update style.
 ;  %tsc: update style, clearer variable names, stanza notation.
 ;  %tses: move fr/place^%wfhfind & finish to be code for
 ; setextract^%ts.
 ;  %tsef: move fr/find^%wfhfind & finish to be code for find^%ts.
 ;  %tsrf: create from findReplace^%wfhfind, merge findReplaceAll
 ; features into findReplace.
 ;  %tsutrf: create w/unit tests for %tsrf.
 ;
 ; 2018-02-22 ven/lmry %*1.8T04 %tsutc: start %tsutc, wrote 32 unit 
 ; tests for string-case functions. Added to %tsut XTROU list for M-unit
 ; testing. One test fails for sencase06, but it's because I used a
 ; proper noun (France) which was de-capitalized in the process. This
 ; may be desired behavior but I'm going to check with toad to make
 ; sure.
 ;
 ; 2018-02-23 ven/lmry %*1.8T04 %tsutc, %tsut, %tses: change sencase06
 ; to not use a proper noun since the expected behavior is for all non
 ; first letter words should be lowercased. Added cover09 to %tsut for
 ; %tsc. Broke %tsutc into sections, updated subroutine header lines in
 ; %tsc. Update contents listing and fix a few non-significant typos in
 ; %tsut. Fixed type, added to to-do list in %tses.
 ;
 ; 2018-02-24/03-03 ven/lmry %*1.8T04 %tsutes, %tses: Build unit tests in
 ; %tsutes to cover %tses. Correct errors in %tses examples found while
 ; testing new unit tests. Jennifer Hackett helped significantly in 
 ; reformatting examples into unit tests.
 ;
 ; 2018-03-04 ven/lmry %*1.8T04 %tsut, %tsutef: Add no-entry-from-top
 ; tests for %tses & %tsef. Convert examples in %tsef into unit tests.
 ;
 ; 2018-03-05 ven/toad %*1.8T04 %tsud: document reorg of string methods.
 ;  %tsudr => %tsudf: document new Find Library.
 ;  %tsrs => %tsvs, %tsutrs => %tsutvs
 ;  %tsrf => %tsfs, %tsutrf => %tsutfs
 ;  %tsrt => %tsjt, %tsutrt => %tsutjt
 ;  %ts: repoint to moved code, refine apis.
 ;
 ; 2018-03-08 ven/lmry %*1.8T04 %tsutef, %tsutes, %tsutc: Fuss with tests,
 ; add tests for synonyms.
 ;
 ; 2018-03-09/10 ven/lmry %*1.8T04 %tsutfs: Add a synoym test. %tsutes: fix
 ; test.
 ;
 ; 2018-03-12 ven/lmry %*1.8T04 %tsutes: Fuss w/tests, add some
 ; descriptions. Add tests to increase coverage. %tsutef: add unit test
 ; for uppercase flag coverage=100%.
 ;
 ; 2018-03-14/15 ven/lmry %*1.8T04 %tsut: Exclude unit test routines from
 ; reports, make clarifications in comments.
 ;
 ; 2018-03-18 ven/toad %*1.8t04 %tsudf: map out new plan for findReplace
 ; findReplaceAll, & deleteBetween.
 ;  %tsfwr: create new routine with code for findReplace^%ts.
 ;  %tsfwra: create new routine with code for findReplaceAll^%ts.
 ;  %ts: repoint findReplace^%ts to findReplace^%tswr, create
 ; findReplaceAll^%ts.
 ;
 ; 2018-03-20 ven/lmry %*1.8T04 %tsef: new from and to variables in stanza 3 to
 ; repair leak
 ;
 ; 2018-03-24 ven/lmry %*1.8T04 %tsut: newed %tsuexcl
 ; 
 ;
eor ; end of routine %tsul

%tsut
%tsut ;ven/mcglk&toad-type string: unit tests ;2018-03-24T22:00Z
 ;;1.8;Mash;
 ;
 ; %tsut implements unit tests for the Mash String Library.
 ; See %tsud for documentation introducing the String library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; It contains two direct-mode interfaces for running unit tests
 ; & reporting code coverage.
 ; %tsut contains no public entry points.
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Ken McGlothlen (mcglk)
 ; mcglk@vistaexpertise.net
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@additional-dev: Linda M. R. Yaw (lmry)
 ; lmry@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2016/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-24T22:00Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@to-do
 ; create unit tests for entire %ts type-string library
 ;
 ;@contents
 ; ^%tsut: dmi to run Mash String Datatype library unit-test suite
 ; cover^%tsut: dmi to run tests & calculate code coverage
 ; no-entry-from-top code-coverage tests
 ; listing of unit-test routines for the String library
 ;
 ;
 ;@section 1 dmi to run Mash String Datatype library unit-test suite
 ;
 ;
 ;
 do EN^%ut($text(+0),2) ; invoke M-Unit
 ;
 quit  ; end of call from top
 ;
 ;
 ;
 ;@section 2 dmi to run tests & calculate code coverage
 ;
 ;
 ;
cover ; run tests & calculate code coverage
 ;
 ;ven/toad;dmi;procedure;clean;report;sac
 ;
 new namespace
 set namespace="%ts*" ; set namespace for routines being tested
 ;
 ; add routines here in preferred order; this enables us to easily
 ; rearrange these in whatever order we like
 ;----------------------------------------------------------------------------
 new %tsuincl
 set %tsuincl(1)="^%tsutc"
 ;----------------------------------------------------------------------------
 ; note that routine references may be specified as:
 ;   * routine        : calls EN^%ut with name as argument
 ;   * ^routine       : calls top of routine
 ;   * label^routine  : calls label in routine
 ; we generally prefer middle form
 ;
 ; to exclude specific routines, do that here:
 ;----------------------------------------------------------------------------
 ;new %tsuexcl
 ;set %tsuexcl(1)="cover^%tsut"
 ; set %tsuexcl(#)="EXCLUDEME^TESTROUTINE"
 ;----------------------------------------------------------------------------
 ;
 ; add %tsuexcl values to ^TMP, which tracks this coverage test
 merge ^TMP("%tsu",$job,"XCLUDE")=%tsuexcl
 ;
 ; cover %ts* namespace; '3' specifies verbosity: this will show values
 ; showing total coverage, plus values for each routine in namespace,
 ; plus totals for everything analyzed, along with coverage values
 ; for each tag within routines, as well as lines under each tag that
 ; were *not* covered in analysis. This may be quite a bit of info,
 ; & we may have to modify namespace and/or verbosity to pare this down
 ; until we have a lot more unit tests written.
 ;
 do COVERAGE^%ut(namespace,.%tsuincl,.%tsuexcl,3)
 ;
 quit  ; end of cover
 ;
 ;
 ;
 ;@section 3 no-entry-from-top code-coverage tests
 ;
 ;
 ;
cover01 ; @TEST no entry from top
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 do ^%ts ; all of these are for 100% code coverage
 do ^%tsc
 do ^%tsef
 do ^%tses
 do ^%tsfs
 do ^%tsfwr
 do ^%tsfwra
 do ^%tsjt
 do ^%tsvs
 do CHKEQ^%ut(1,1)
 ;
 quit  ; end of cover01
 ;
 ;
 ;
 ;@section 4 unit-test routines for the String library
 ;
 ;
 ;
 ;
 ;
eor ; end of routine %tsut

%tsutc
%tsutc ;ven/lmry&mcglk&toad-type string-case: test string-case apis ^%tsc ;2018-03-09T02:49Z
 ;;1.8;Mash;
 ;
 ; This Mumps Advanced Shell (mash) routine implements unit tests for
 ; Mash String Library string-case apis in %ts. It contains no public entry
 ; points.
 ;
 ; primary development: see routine %tsul
 ;
 ;@primary-dev: Linda M. R. Yaw (lmry)
 ;@additional-dev: Ken McGlothlen (mcglk)
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ;@primary-dev-org: Vista Expertise Network (ven)
 ;@copyright: 2016/2017/2018, ven, all rights reserved
 ;@license: Apache 2.0
 ;
 ;@last-updated: 2018-03-09T02:49Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.7T03
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;
 ;
 ;@contents
 ; Group 1: Alphabet
 ;  alpha01 = unit test for $$alphabet^%ts
 ;  ALPHA01 = unit test for $$ALPHABET^%ts
 ; Group 2: Upper Case
 ;  upcase* = unit tests for $$upcase^%ts
 ;  u01 = unit test for $$u^%ts
 ;  upper = unit test for $$upperCase^%ts
 ; Group 3: Lower Case
 ;  lowcase* = unit tests for $$lowcase^%ts
 ;  l01 = unit test for $$l^%ts
 ;  lower = unit test for $$lowerCase^%ts
 ; Group 4: Capital Case
 ;  capcase* = unit tests for $$capcase^%ts
 ;  c01 = unit test for $$c^%ts
 ;  capital = unit test for $$capitalCase^%ts
 ; Group 5: Inverse Case
 ;  invcase* = unit tests for $$invcase^%ts
 ;  i01 = unit test for $$i^%ts
 ;  inverse = unit test for $$inverseCase^%ts
 ; Group 6: Sentence Case
 ;  sencase* = unit tests for $$sencase^%ts
 ;  s01 = unit test for $$s^%ts
 ;  sentence = unit test for $$sentenceCase^%ts
 ; 
 ;@called-by:
 ; M-Unit
 ;  EN^%ut (called by ^%tsut)
 ;  COVERAGE^%ut (called by cover^%tsut)
 ;
 ;
 ; Group 1: Alphabet
 ;
 ;
alpha01 ; @TEST $$alphabet^%ts(): return lower case English alphabet
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new result set result="abcdefghijklmnopqrstuvwxyz"
 do CHKEQ^%ut($$alphabet^%ts,result)
 ;
 quit  ; end of alpha01
 ;
 ;
ALPHA01 ; @TEST $$ALPHABET^%ts(%s,%c): Return upper case English alphabet
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new result set result="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 do CHKEQ^%ut($$ALPHABET^%ts,result)
 ;
 quit  ; end of ALPHA01
 ;
 ;
 ;
 ; Group 2: Upper Case
 ;
 ;
upcase01 ; @TEST $$upcase^%ts(%s): Convert string to uppercase
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="Terrarium"                     
 new result set result="TERRARIUM"
 do CHKEQ^%ut($$upcase^%ts(%s),result)
 ;
 quit  ; end of upcase01
 ;
 ;
upcase02 ; @TEST $$upcase^%ts(%s): Convert phrase string to uppercase
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="Snow falls on the trees."
 new result set result="SNOW FALLS ON THE TREES."
 do CHKEQ^%ut($$upcase^%ts(%s),result)
 ;
 quit  ; end of upcase02
 ;
 ;
upcase03 ; @TEST $$upcase^%ts(%s): See what happens with the empty string
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s=""
 new result set result=%s
 do CHKEQ^%ut($$upcase^%ts(%s),result)
 ;
 quit  ; end of upcase03
 ;
 ;
upcase04 ; @TEST $$upcase^%ts(%s): what happens with non-alpha characters
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="23,980"
 new result set result=%s
 do CHKEQ^%ut($$upcase^%ts(%s),result)
 ;
 quit  ; end of upcase04
 ;
 ;
upcase05 ; @TEST $$upcase^%ts(%s): mixed alpha and non-alpha characters
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="34 trucks, 53 tractors"
 new result set result="34 TRUCKS, 53 TRACTORS"
 do CHKEQ^%ut($$upcase^%ts(%s),result)
 ;
 quit  ; end of upcase05
 ;
 ;
u01 ; @TEST $$u^%ts(%s): Convert string to uppercase
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="Terrarium"                     
 new result set result="TERRARIUM"
 do CHKEQ^%ut($$u^%ts(%s),result)
 ;
 quit  ; end of u01
 ;
 ;
upper ; @TEST $$upperCase^%ts(%s): Convert string to uppercase
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="Terrarium"                     
 new result set result="TERRARIUM"
 do CHKEQ^%ut($$upperCase^%ts(%s),result)
 ;
 quit  ; end of upper
 ;
 ;
 ;
 ; Group 3: Lower Case
 ;
 ;
lowcase01 ; @TEST $$lowcase^%ts(%s): Convert string to lowercase
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="TERRARIUM"                     
 new result set result="terrarium"
 do CHKEQ^%ut($$lowcase^%ts(%s),result)
 ;
 quit  ; end of lowcase01
 ;
 ;
lowcase02 ; @TEST $$lowcase^%ts(%s): Convert phrase string to lowercase
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="SNOW FALLS ON THE TREES."
 new result set result="snow falls on the trees."
 do CHKEQ^%ut($$lowcase^%ts(%s),result)
 ;
 quit  ; end of lowcase02
 ;
 ;
lowcase03 ; @TEST $$lowcase^%ts(%s): See what happens with the empty string
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s=""
 new result set result=%s
 do CHKEQ^%ut($$lowcase^%ts(%s),result)
 ;
 quit  ; end of lowcase03
 ;
 ;
lowcase04 ; @TEST $$lowcase^%ts(%s): what happens with non-alpha characters
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="23,980"
 new result set result=%s
 do CHKEQ^%ut($$lowcase^%ts(%s),result)
 ;
 quit  ; end of lowcase04
 ;
 ;
lowcase05 ; @TEST $$lowcase^%ts(%s): mixed alpha and non-alpha characters
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="34 TRUCKS, 53 TRACTORS"
 new result set result="34 trucks, 53 tractors"
 do CHKEQ^%ut($$lowcase^%ts(%s),result)
 ;
 quit  ; end of lowcase05
 ;
 ;
l01 ; @TEST $$l^%ts(%s): Test synonym $$l^%ts
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="TERRARIUM"                     
 new result set result="terrarium"
 do CHKEQ^%ut($$l^%ts(%s),result)
 ;
 quit  ; end of l01
 ;
 ;
lower ; @TEST $$lowerCase^%ts(%s): test synonym $$lowerCase^%t
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="TERRARIUM"                     
 new result set result="terrarium"
 do CHKEQ^%ut($$lowerCase^%ts(%s),result)
 ;
 quit  ; end of lower
 ;
 ;
 ;
 ; Group 4: Capital Case
 ;
 ;
capcase01 ; @TEST $$capcase^%ts(%s): Convert uppercase string to Capitalized
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="TERRARIUM"                     
 new result set result="Terrarium"
 do CHKEQ^%ut($$capcase^%ts(%s),result)
 ;
 quit  ; end of capcase01
 ;
 ;
capcase02 ; @TEST $$capcase^%ts(%s): Convert lowercase phrase to Capitalized
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="snow falls on the trees."
 new result set result="Snow Falls On The Trees."
 do CHKEQ^%ut($$capcase^%ts(%s),result)
 ;
 quit  ; end of capcase02
 ;
 ;
capcase03 ; @TEST $$capcase^%ts(%s): See what happens with the empty string
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s=""
 new result set result=%s
 do CHKEQ^%ut($$capcase^%ts(%s),result)
 ;
 quit  ; end of capcase03
 ;
 ;
capcase04 ; @TEST $$capcase^%ts(%s): what happens with non-alpha characters
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="23,980"
 new result set result=%s
 do CHKEQ^%ut($$capcase^%ts(%s),result)
 ;
 quit  ; end of capcase04
 ;
 ;
capcase05 ; @TEST $$capcase^%ts(%s): mixed upper and lowercase characters
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="JeNNifer siTs in ThE WinDow Seat."
 new result set result="Jennifer Sits In The Window Seat."
 do CHKEQ^%ut($$capcase^%ts(%s),result)
 ;
 quit  ; end of capcase05
 ;
 ;
c01 ; @TEST $$c^%ts(%s): test synonym $$c^%ts
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="JeNNifer siTs in ThE WinDow Seat."
 new result set result="Jennifer Sits In The Window Seat."
 do CHKEQ^%ut($$c^%ts(%s),result)
 ;
 quit  ; end of c01
 ;
 ;
capital ; @TEST $$capitalCase^%ts(%s): test synonym $$capitalCase^%ts
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="JeNNifer siTs in ThE WinDow Seat."
 new result set result="Jennifer Sits In The Window Seat."
 do CHKEQ^%ut($$capitalCase^%ts(%s),result)
 ;
 quit  ; end of capital
 ;
 ;
 ;
 ;Group 5: Inverse Case
 ;
 ;
invcase01 ; @TEST $$invcase^%ts(%s): Invert uppercase and lowercase string
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="tERRARIUM"                     
 new result set result="Terrarium"
 do CHKEQ^%ut($$invcase^%ts(%s),result)
 ;
 quit  ; end of invcase01
 ;
 ;
invcase02 ; @TEST $$invcase^%ts(%s): Invert mixed case phrase.
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="sNOW fALLS oN tHE tREES."
 new result set result="Snow Falls On The Trees."
 do CHKEQ^%ut($$invcase^%ts(%s),result)
 ;
 quit  ; end of invcase02
 ;
 ;
invcase03 ; @TEST $$invcase^%ts(%s): See what happens with the empty string
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s=""
 new result set result=%s
 do CHKEQ^%ut($$invcase^%ts(%s),result)
 ;
 quit  ; end of invcase03
 ;
 ;
invcase04 ; @TEST $$invcase^%ts(%s): what happens with non-alpha characters
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="23,980"
 new result set result=%s
 do CHKEQ^%ut($$invcase^%ts(%s),result)
 ;
 quit  ; end of invcase04
 ;
 ;
i01 ; @TEST $$i^%ts(%s): Test synonym $$i^%ts
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="sNOW fALLS oN tHE tREES."
 new result set result="Snow Falls On The Trees."
 do CHKEQ^%ut($$i^%ts(%s),result)
 ;
 quit  ; end of i01
 ;
 ;
inverse ; @TEST $$i^%ts(%s): Test synonym $$inverseCase^%ts
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="sNOW fALLS oN tHE tREES."
 new result set result="Snow Falls On The Trees."
 do CHKEQ^%ut($$inverseCase^%ts(%s),result)
 ;
 quit  ; end of inverse
 ;
 ;
 ;
 ; Group 6: Sentence Case
 ;
 ;
sencase01 ; @TEST $$sencase^%ts(%s): Convert uppercase string to Sentence case
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="TERRARIUM"                     
 new result set result="Terrarium"
 do CHKEQ^%ut($$sencase^%ts(%s),result)
 ;
 quit  ; end of sencase01
 ;
 ;
sencase02 ; @TEST $$sencase^%ts(%s): Convert lowercase phrase to Sentence case
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="snow falls on the trees."
 new result set result="Snow falls on the trees."
 do CHKEQ^%ut($$sencase^%ts(%s),result)
 ;
 quit  ; end of sencase02
 ;
 ;
sencase03 ; @TEST $$sencase^%ts(%s): See what happens with the empty string
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s=""
 new result set result=%s
 do CHKEQ^%ut($$sencase^%ts(%s),result)
 ;
 quit  ; end of sencase03
 ;
 ;
sencase04 ; @TEST $$sencase^%ts(%s): what happens with non-alpha characters
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="23,980"
 new result set result=%s
 do CHKEQ^%ut($$sencase^%ts(%s),result)
 ;
 quit  ; end of sencase04
 ;
 ;
sencase05 ; @TEST $$sencase^%ts(%s): mixed upper and lowercase characters to Sentence.
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="JeNNifer siTs in ThE WinDow Seat."
 new result set result="Jennifer sits in the window seat."
 do CHKEQ^%ut($$sencase^%ts(%s),result)
 ;
 quit  ; end of sencase05
 ;
 ;
sencase06 ; @TEST $$sencase^%ts(%s): more than one Sentence, different puncuation
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="hello from outer space. wish you were here! what are you doing now? nothing?"
 new result set result="Hello from outer space. Wish you were here! What are you doing now? Nothing?"
 do CHKEQ^%ut($$sencase^%ts(%s),result)
 ;
 quit  ; end of sencase06
 ;
 ;
s01 ; @TEST $$s^%ts(%s): test synonym $$s^%ts
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="JeNNifer siTs in ThE WinDow Seat."
 new result set result="Jennifer sits in the window seat."
 do CHKEQ^%ut($$s^%ts(%s),result)
 ;
 quit  ; end of s01
 ;
 ;
sentence ; @TEST $$sentenceCase^%ts(%s): test synonym $$sentenceCase^%ts
 ;
 ;ven/lmry;test;procedure;clean;silent;sac
 ;
 new %s set %s="JeNNifer siTs in ThE WinDow Seat."
 new result set result="Jennifer sits in the window seat."
 do CHKEQ^%ut($$sentenceCase^%ts(%s),result)
 ;
 quit  ; end of sentence
 ;
 ;
 ;
eor ; end of routine %tsutc

%tsutef
%tsutc ;ven/lmry&mcglk&toad-type string-case: test string-case apis ^%tsc ;2018-03-12T01:29Z
 ;;1.8;Mash;
 ;
 ; This Mumps Advanced Shell (mash) routine implements unit tests for
 ; Mash String Library string-case apis in %ts. It contains no public entry
 ; points.
 ;
 ; primary development: see routine %tsul
 ;
 ;@primary-dev: Linda M. R. Yaw (lmry)
 ;@additional-dev: Ken McGlothlen (mcglk)
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ;@primary-dev-org: Vista Expertise Network (ven)
 ;@copyright: 2016/2017/2018, ven, all rights reserved
 ;@license: Apache 2.0
 ;
 ;@last-updated: 2018-03-12T01:29Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;
 ;
 ;@contents
 ; group 1: Find First & Find Next
 ; group 2: absolute addressing w/in string
 ; group 3: Find Case-Insensitive
 ; group 4: Boundary Cases
 ; group 5: Synonyms
 ;
 ;
 ;
 ;@called-by
 ; M-Unit
 ;  EN^%ut (called by ^%tsut)
 ;  COVERAGE^%ut (called by cover^%tsut)
 ;@calls
 ;  CHKEQ^%ut
 ;  findex^%ts
 ;  fe^%ts
 ;  findExtract^%ts
 ;  find^%ts
 ;
 ;
 ;
 ; group 1: Find First & Find Next
 ;
 ;
find101 ; @TEST findex^%ts(.string,"Kansas"): missing substring
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findex^%ts(.string,"Kansas")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find101
 ;
 ;
find102 ; @TEST findex^%ts(.string,"toto"): multiple substrings present
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findex^%ts(.string,"toto")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),4)
 ;
 ; followed by
 do findex^%ts(.string,"toto")
 do CHKEQ^%ut(string("extract","from"),5)
 do CHKEQ^%ut(string("extract","to"),8)
 ;
 ; followed by
 do findex^%ts(.string,"toto")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find102
 ;
 ;
find103 ; @TEST findex^%ts(.string,"toto"): multiple substrings present start 
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=1
 set string("extract","to")=2
 do findex^%ts(.string,"toto")
 do CHKEQ^%ut(string("extract","from"),3)
 do CHKEQ^%ut(string("extract","to"),6)
 ;
 quit  ; end of find103
 ;
 ;
find104 ; @TEST findex^%ts(.string,"toto"): search for substring that exists in subject
 ; string more than once but starting after start of last instance of substring
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=6
 set string("extract","to")=7
 do findex^%ts(.string,"toto")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find104
 ;
 ;
 ; group 2: Find Last & Find Previous
 ;
 ;
find201 ; @TEST findex^%ts(.string,"Kansas","b"): search for substring that does not
 ; exist in string from end instead of beginning
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findex^%ts(.string,"Kansas","b")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find201
 ;
 ;
find202 ; @TEST findex^%ts(.string,"toto","b"): search for substring backwards
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findex^%ts(.string,"toto","b")
 do CHKEQ^%ut(string("extract","from"),5)
 do CHKEQ^%ut(string("extract","to"),8)
 ;
 do findex^%ts(.string,"toto","b")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),4)
 ;
 do findex^%ts(.string,"toto","b")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find202
 ;
 ;
find203 ; @TEST findex^%ts(.string,"toto","b"): findex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=7
 set string("extract","to")=8
 do findex^%ts(.string,"toto","b")
 do CHKEQ^%ut(string("extract","from"),3)
 do CHKEQ^%ut(string("extract","to"),6)
 ;
 quit  ; end of find203
 ;
 ;
find204 ; @TEST findex^%ts(.string,"toto","b"): findex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=1
 set string("extract","to")=2
 do findex^%ts(.string,"toto","b")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find204
 ;
 ;
find205 ; @TEST findex^%ts(.string,"toto","B"): use "B" flag
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=1
 set string("extract","to")=2
 do findex^%ts(.string,"toto","B")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find205
 ;
 ;
 ;
 ; group 3: Find Case-Insensitive
 ;
 ;
find301 ; @TEST findex^%ts(.string,"Toto","i"): string non-cap, sub capped
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findex^%ts(.string,"Toto")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 do findex^%ts(.string,"Toto","i")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),4)
 ;
 do findex^%ts(.string,"Toto","i")
 do CHKEQ^%ut(string("extract","from"),5)
 do CHKEQ^%ut(string("extract","to"),8)
 ;
 quit  ; end of 301
 ;
 ;
find302 ; @TEST findex^%ts(.string,"Toto","i"): string cap, sub non-cap
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="TotoToto"
 do findex^%ts(.string,"toto")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 do findex^%ts(.string,"toto","i")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),4)
 ;
 do findex^%ts(.string,"toto","i")
 do CHKEQ^%ut(string("extract","from"),5)
 do CHKEQ^%ut(string("extract","to"),8)
 ;
 quit  ; end of 302
 ; 
 ;
 ; group 4: Boundary Cases
 ;
 ;
 ; group 5: Synonyms
 ;
 ;
find501 ; @TEST fe^%ts(.string,"toto"): test fe^%ts
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=6
 set string("extract","to")=7
 do fe^%ts(.string,"toto")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find501
 ;
 ;
find502 ; @TEST FindExtract^%ts(.string,"toto"): test FindExtract^%ts
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=6
 set string("extract","to")=7
 do findExtract^%ts(.string,"toto")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find502
 ;
 ;
find503 ; @TEST find^%ts(.string,"toto"): test find^%ts
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=6
 set string("extract","to")=7
 do find^%ts(.string,"toto")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of find503
 ;
 ;
 ;
eor ; end of routine %tsutef

%tsutes
%tsutes ;ven/lmry&mcglk&toad-type string-case: test string-case apis ^%tsc ;2018-03-12T04:39Z
 ;;1.8;Mash;
 ;
 ; This Mumps Advanced Shell (mash) routine implements unit tests for
 ; Mash String Library api $$setextract^%ts. It contains no public entry
 ; points.
 ;
 ; primary development: see routine %tsul
 ;
 ;@primary-dev: Linda M. R. Yaw (lmry)
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ;@additional-dev: Ken McGlothlen (mcglk)
 ;@additional-dev: Jennifer Hackett
 ;@primary-dev-org: Vista Expertise Network (ven)
 ;@copyright: 2016/2017/2018, ven, all rights reserved
 ;@license: Apache 2.0
 ;
 ;@last-updated: 2018-03-12T04:39Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;
 ;
 ;@contents
 ; group 1: default addressing
 ; group 2: absolute addressing w/in string
 ; group 3: absolute addressing before string
 ; group 4: absolute addressing after string
 ; group 5: relative addressing
 ; group 6: from & to, absolute addressing w/in string [tbd]
 ; group 7: synonyms
 ;
 ;
 ;@called-by
 ; M-Unit
 ;  EN^%ut (called by ^%tsut)
 ;  COVERAGE^%ut (called by cover^%tsut)
 ;@calls
 ; CHKEQ^%ut
 ; setex^%ts
 ; se^%ts
 ; setExtract^%ts
 ; place^%tst
 ;
 ;
 ; group 1: default addressing
 ;
 ;
setex101 ; @TEST setex^%ts(.string,.replace): string & substring undefined
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string,replace
 do setex^%ts(.string,.replace)
 do CHKEQ^%ut(string,"")
 do CHKEQ^%ut(replace,"")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex101
 ;
 ;
setex102 ; @TEST setex^%ts(.string,""): string undefined, substring is empty string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex102
 ;
 ;
setex103 ; @TEST setex^%ts(.string,.replace): string is empty, substring undefined
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string=""
 new replace
 do setex^%ts(.string,.replace)
 do CHKEQ^%ut(string,"")
 do CHKEQ^%ut(replace,"")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex103
 ;
 ;
setex104 ; @TEST setex^%ts(.string,""): string and substring are empty string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string=""
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex104
 ;
 ;
setex105 ; @TEST setex^%ts(.string,"*"): string is empty, substring is punctuation
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string=""
 do setex^%ts(.string,"*")
 do CHKEQ^%ut(string,"*")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),1)
 ;
 quit  ; end of setex105
 ;
 ;
setex106 ; @TEST setex^%ts(.string,"Sparrowhawk"): string empty, substring is word
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string=""
 do setex^%ts(.string,"Sparrowhawk")
 do CHKEQ^%ut(string,"Sparrowhawk")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),11)
 ;
 quit  ; end of setex106
 ;
 ;
setex107 ; @TEST setex^%ts(.string,""): string is phrase, substring is empty
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="Never the way he can follow grows narrower"
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"ever the way he can follow grows narrower")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex107
 ;
 ;
setex108 ; @TEST setex^%ts(.string,"o"): string is phrase, substring is letter
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="In the empty sky."
 do setex^%ts(.string,"o")
 do CHKEQ^%ut(string,"on the empty sky.")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),1)
 ;
 quit  ; end of setex108
 ;
 ;
setex109 ; @TEST setex^%ts(.string,"bright"): no from/to, replaces first char of string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="O the hawk's flight"
 do setex^%ts(.string,"bright")
 do CHKEQ^%ut(string,"bright the hawk's flight")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),6)
 ;
 quit  ; end of setex109
 ;
 ;
 ;
 ; group 2: absolute addressing w/in string
 ;
 ;
setex201 ; @TEST setex^%ts(.string,""): empty substring w/in string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="She lay thus dark and dumb"
 set string("from")=1
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"he lay thus dark and dumb")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex201
 ;
 ;
setex202 ; @TEST setex^%ts(.string,"A"): from set, no to, replaces first letter
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="O Wizard of Earthsea"
 set string("extract","from")=1
 do setex^%ts(.string,"A")
 do CHKEQ^%ut(string,"A Wizard of Earthsea")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),1)
 ;
 quit  ; end of setex202
 ;
 ;
setex203 ; @TEST setex^%ts(.string,"To"): from set, no to, replaces first letter
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="I hear, one must be silent."
 set string("extract","from")=1
 do setex^%ts(.string,"To")
 do CHKEQ^%ut(string,"To hear, one must be silent.")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),2)
 ;
 quit  ; end of setex203
 ;
 ;
setex204 ; @TEST setex^%ts(.string,""): remove letter w/in string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="until at lEast he chooses nothing"
 set string("extract","from")=11
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"until at last he chooses nothing")
 do CHKEQ^%ut(string("extract","from"),10)
 do CHKEQ^%ut(string("extract","to"),10)
 ;
 quit  ; end of setex204
 ;
 ;
setex205 ; @TEST setex^%ts(.string,"c"): replace letter w/in string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="To light a Sandle is to cast a shadow."
 set string("extract","from")=12
 do setex^%ts(.string,"c")
 do CHKEQ^%ut(string,"To light a candle is to cast a shadow.")
 do CHKEQ^%ut(string("extract","from"),12)
 do CHKEQ^%ut(string("extract","to"),12)
 ;
 quit  ; end of setex205
 ;
 ;
setex206 ; @TEST setex^%ts(.string,"y and wholly"): replace letter with phrase
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="does onlY what he must do"
 set string("extract","from")=9
 do setex^%ts(.string,"y and wholly")
 do CHKEQ^%ut(string,"does only and wholly what he must do")
 do CHKEQ^%ut(string("extract","from"),9)
 do CHKEQ^%ut(string("extract","to"),20)
 ;
 quit  ; end of setex206
 ;
 ;
setex207 ; @TEST setex^%ts(.string,""): remove last letter
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="For a word to be spoken there must be silenceS"
 set string("extract","from")=46
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"For a word to be spoken there must be silence")
 do CHKEQ^%ut(string("extract","from"),45)
 do CHKEQ^%ut(string("extract","to"),45)
 ;
 quit  ; end of setex207
 ;
 ;
setex208 ; @TEST setex^%ts(.string,"s"): replace last letter
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="there must be darkness to see the starT"
 set string("extract","from")=39
 do setex^%ts(.string,"s")
 do CHKEQ^%ut(string,"there must be darkness to see the stars")
 do CHKEQ^%ut(string("extract","from"),39)
 do CHKEQ^%ut(string("extract","to"),39)
 ;
 quit  ; end of setex208
 ;
 ;
setex209 ; @TEST setex^%ts(.string,"o evil"): replace last letter with phrase
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="only men do"
 set string("extract","from")=11
 do setex^%ts(.string,"o evil")
 do CHKEQ^%ut(string,"only men do evil")
 do CHKEQ^%ut(string("extract","from"),11)
 do CHKEQ^%ut(string("extract","to"),16)
 ;
 quit  ; end of setex209
 ;
 ;
 ;
 ; group 3: absolute addressing before string
 ;
 ;
setex301 ; @TEST setex^%ts(.string,""): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="She wept in pain, because she was free"
 set string("extract","from")=0
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"She wept in pain, because she was free")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex301
 ;
 ;
setex302 ; @TEST setex^%ts(.string,"w"): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="eight of liberty"
 set string("extract","from")=0
 do setex^%ts(.string,"w")
 do CHKEQ^%ut(string,"weight of liberty")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),1)
 ;
 quit  ; end of setex302
 ;
 ;
setex303 ; @TEST setex^%ts(.string,"A"): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="Wizard of Earthsea"
 set string("extract","from")=-1
 do setex^%ts(.string,"A")
 do CHKEQ^%ut(string,"A Wizard of Earthsea")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),1)
 ;
 quit  ; end of setex303
 ;
 ;
setex304 ; @TEST setex^%ts(.string,"The"): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="Tombs of Atuan"
 set string("extract","from")=-3
 do setex^%ts(.string,"The")
 do CHKEQ^%ut(string,"The Tombs of Atuan")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),3)
 ;
 quit  ; end of setex304
 ;
 ;
setex305 ; @TEST setex^%ts(.string,"The"): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="Farthest Shore"
 set string("extract","from")=-5
 do setex^%ts(.string,"The")
 do CHKEQ^%ut(string,"The   Farthest Shore")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),3)
 ;
 quit  ; end of setex305
 ;
 ;
setex306 ; @TEST setex^%ts(.string,""): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="Tehanu"
 set string("extract","from")=-4
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"    Tehanu")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex306
 ;
 ;
setex307 ; @TEST setex^%ts(.string,"The O"): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="Another Wind"
 set string("extract","from")=-1
 do setex^%ts(.string,"The O")
 do CHKEQ^%ut(string,"The Other Wind")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),5)
 ;
 quit  ; end of setex307
 ;
 ;
 ;
 ; group 4: absolute addressing after string
 ;
 ;
setex401 ; @TEST setex^%ts(.string,""): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="muddle, mystery, mumbling"
 set string("extract","from")=26
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"muddle, mystery, mumbling")
 do CHKEQ^%ut(string("extract","from"),25)
 do CHKEQ^%ut(string("extract","to"),25)
 ;
 quit  ; end of setex401
 ;
 ;
setex402 ; @TEST setex^%ts(.string,""): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="There's no way to use power for good."
 set string("extract","from")=39
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"There's no way to use power for good. ")
 do CHKEQ^%ut(string("extract","from"),38)
 do CHKEQ^%ut(string("extract","to"),38)
 ;
 quit  ; end of setex402
 ;
 ;
setex403 ; @TEST setex^%ts(.string,""): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="All times are changing times"
 set string("extract","from")=32
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string("extract","from"),31)
 do CHKEQ^%ut(string("extract","to"),31)
 ;
 quit  ; end of setex403
 ;
 ;
setex404 ; @TEST setex^%ts(.string," from Earthsea"): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="Tales"
 set string("extract","from")=6
 do setex^%ts(.string," from Earthsea")
 do CHKEQ^%ut(string,"Tales from Earthsea")
 do CHKEQ^%ut(string("extract","from"),6)
 do CHKEQ^%ut(string("extract","to"),19)
 ;
 quit  ; end of setex404
 ;
 ;
setex405 ; @TEST setex^%ts(.string,"is to unmake power"): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac 
 ;
 new string set string="to make love"
 set string("extract","from")=14
 do setex^%ts(.string,"is to unmake power")
 do CHKEQ^%ut(string,"to make love is to unmake power")
 do CHKEQ^%ut(string("extract","from"),14)
 do CHKEQ^%ut(string("extract","to"),31)
 ;
 quit  ; end of setex405
 ;
 ;
setex406 ; @TEST setex^%ts(.string,"cy"): setex test
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac 
 ;
 new string set string="The solution lies in secret"
 set string("extract","from")=27
 do setex^%ts(.string,"cy")
 do CHKEQ^%ut(string,"The solution lies in secrecy")
 do CHKEQ^%ut(string("extract","from"),27)
 do CHKEQ^%ut(string("extract","to"),28)
 ;
 quit  ; end of setex406
 ;
 ;
 ;
 ; group 5: relative addressing
 ;
 ;
setex501 ; @TEST setex^%ts(.string,""): use "b" flag with empty replace
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="The road goes upward towards the light"
 set string("extract","from")="b"
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"The road goes upward towards the light")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex501
 ;
 ;
setex502 ; @TEST setex^%ts(.string,"A"): setex test use "b" flag to prepend character
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string=" dark hand had let go its lifelong hold"
 set string("extract","from")="b"
 do setex^%ts(.string,"A")
 do CHKEQ^%ut(string,"A dark hand had let go its lifelong hold")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),1)
 ;
 quit  ; end of setex502
 ;
 ;
setex503 ; @TEST setex^%ts(.string,"It is not "): use "b" flag to prepend phrase
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="a gift given, but a choice made"
 set string("extract","from")="b"
 do setex^%ts(.string,"It is not ")
 do CHKEQ^%ut(string,"It is not a gift given, but a choice made")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),10)
 ;
 quit  ; end of setex503
 ;
 ;
setex504 ; @TEST setex^%ts(.string,"Injustice makes the rules, and "): "B" flag
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac 
 ;
 new string set string="courage breaks them."
 set string("extract","from")="B"
 do setex^%ts(.string,"Injustice makes the rules, and ")
 do CHKEQ^%ut(string,"Injustice makes the rules, and courage breaks them.")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),31)
 ;
 quit  ; end of setex504
 ;
 ;
setex505 ; @TEST setex^%ts(.string,""): use "a" flag with empty string for replace
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac 
 ;
 new string set string="when you eat illusions you end up hungrier"
 set string("extract","from")="a"
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"when you eat illusions you end up hungrier")
 do CHKEQ^%ut(string("extract","from"),42)
 do CHKEQ^%ut(string("extract","to"),42)
 ;
 quit  ; end of setex505
 ;
 ;
setex506 ; @TEST setex^%ts(.string,"."): use "a" flag to append period
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac 
 ;
 new string set string="Manipulated, one manipulates others"
 set string("extract","from")="a"
 do setex^%ts(.string,".")
 do CHKEQ^%ut(string,"Manipulated, one manipulates others.")
 do CHKEQ^%ut(string("extract","from"),36)
 do CHKEQ^%ut(string("extract","to"),36)
 ;
 quit  ; end of setex506
 ;
 ;
setex507 ; @TEST setex^%ts(.string," selectively"): use "a" flag to append word
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac 
 ;
 new string set string="Statesmen remember things"
 set string("extract","from")="a"
 do setex^%ts(.string," selectively")
 do CHKEQ^%ut(string,"Statesmen remember things selectively")
 do CHKEQ^%ut(string("extract","from"),26)
 do CHKEQ^%ut(string("extract","to"),37)
 ;
 quit  ; end of setex507
 ;
 ;
setex508 ; @TEST setex^%ts(.string," that made me live"): use "A" flag to append phrase
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="I can breathe back the breath"
 set string("extract","from")="A"
 do setex^%ts(.string," that made me live")
 do CHKEQ^%ut(string,"I can breathe back the breath that made me live")
 do CHKEQ^%ut(string("extract","from"),30)
 do CHKEQ^%ut(string("extract","to"),47)
 ;
 quit  ; end of setex508
 ;
 ;
setex509 ; @TEST setex^%ts(.string,""): Use "f" flag with empty string to replace
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="Ignorant power is a bane!"
 set string("extract","from")="f"
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"Ignorant power is a bane!")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex509
 ;
 ;
setex510 ; @TEST setex^%ts(.string,"I"): Use "f" flag to replace beginning character
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="U can give them back to the world"
 set string("extract","from")="f"
 do setex^%ts(.string,"I")
 do CHKEQ^%ut(string,"I can give them back to the world")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),1)
 ;
 quit  ; end of setex510
 ;
 ;
setex511 ; @TEST setex^%ts(.string,"Despair"): Use "f" flag to replace beginning
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="MANHOOD speaks evenly, in a quiet voice"
 set string("extract","from")="f"
 do setex^%ts(.string,"Despair")
 do CHKEQ^%ut(string,"Despair speaks evenly, in a quiet voice")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),7)
 ;
 quit  ; end of setex511
 ;
 ;
setex512 ; @TEST setex^%ts(.string,"Injustice"): Use "F" flag to replace beginning
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="AUTHORITY makes the rules"
 set string("extract","from")="F"
 do setex^%ts(.string,"Injustice")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),9)
 ;
 quit  ; end of setex512
 ;
 ;
setex513 ; @TEST setex^%ts(.string,""): use "l" flag with empty replace
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac 
 ;
 new string set string="To which Silence of course made no reply"
 set string("extract","from")="l"
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string,"To which Silence of course made no reply")
 do CHKEQ^%ut(string("extract","from"),40)
 do CHKEQ^%ut(string("extract","to"),40)
 ;
 quit  ; end of setex513
 ;
 ;
setex514 ; @TEST setex^%ts(.string,"n"): use "l" flag to replace end character
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="Greed puts out the suM"
 set string("extract","from")="l"
 do setex^%ts(.string,"n")
 do CHKEQ^%ut(string,"Greed puts out the sun")
 do CHKEQ^%ut(string("extract","from"),22)
 do CHKEQ^%ut(string("extract","to"),22)
 ;
 quit  ; end of setex514
 ;
 ;
setex515 ; @TEST setex^%ts(.string,"strange"): use "l" flag to replace end of string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac 
 ;
 new string set string="The world's vast and ANCIENT"
 set string("extract","from")="l"
 do setex^%ts(.string,"strange")
 do CHKEQ^%ut(string,"The world's vast and strange")
 do CHKEQ^%ut(string("extract","from"),22)
 do CHKEQ^%ut(string("extract","to"),28)
 ;
 quit  ; end of setex515
 ;
 ;
setex516 ; @TEST setex^%ts(.string,"life"): use "L" flag to replace end of string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="To refuse death is to refuse DOOM"
 set string("extract","from")="L"
 do setex^%ts(.string,"life")
 do CHKEQ^%ut(string("extract","from"),30)
 do CHKEQ^%ut(string("extract","to"),33)
 ;
 quit  ; end of setex516
 ;
 ;
setex517 ; @TEST setex^%ts(.string,"life"): use bad flag
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="To refuse death is to refuse DOOM"
 set string("extract","from")="z"
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex517
 ;
 ;
setex518 ; @TEST setex^%ts(.string,"life"): use uppercase bad flag
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="To refuse death is to refuse DOOM"
 set string("extract","from")="Z"
 do setex^%ts(.string,"")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex518
 ;
 ;
setex519 ; @TEST setex^%ts(.string,"life"): use two flags
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="To refuse death is to refuse DOOM"
 set string("extract","from")="li"
 do setex^%ts(.string,"Life")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex519
 ;
 ;
setex520 ; @TEST setex^%ts(.string,"life"): use two flags
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="To refuse death is to refuse DOOM"
 set string("extract","from")="bf"
 do setex^%ts(.string,"Life")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex520
 ;
 ;
setex521 ; @TEST setex^%ts(.string,"life"): use reserved flag
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="To refuse death is to refuse DOOM"
 set string("extract","from")="r"
 do setex^%ts(.string,"Life")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex521
 ;
 ;
 ;
 ; group 6: from & to, absolute addressing w/in string
 ;
 ;
setex601 ; @TEST setex^%ts(.string," boredom of "): insert replace within string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="the terrible pain"
 set string("extract","from")=13
 do setex^%ts(.string," boredom of ")
 do CHKEQ^%ut(string,"the terrible boredom of pain")
 do CHKEQ^%ut(string("extract","from"),13)
 do CHKEQ^%ut(string("extract","to"),24)
 ;
 quit  ; end of setex601
 ;
 ;
setex602 ; @TEST setex^%ts(.string,"banality"): set "to" to replace within string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="admit the ATTRACTION of evil"
 set string("extract","from")=11
 set string("extract","to")=20
 do setex^%ts(.string,"banality")
 do CHKEQ^%ut(string,"admit the banality of evil")
 do CHKEQ^%ut(string("extract","from"),11)
 do CHKEQ^%ut(string("extract","to"),18)
 ;
 quit  ; end of setex602
 ;
 ;
setex603 ; @TEST setex^%ts(.string,"that of life"): Use "L" flag to replace end of string
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="the victory they celebrate is WAR WON WELL"
 set string("extract","from")="L"
 do setex^%ts(.string,"that of life")
 do CHKEQ^%ut(string,"the victory they celebrate is that of life")
 do CHKEQ^%ut(string("extract","from"),31)
 do CHKEQ^%ut(string("extract","to"),42)
 ;
 quit  ; end of setex603
 ;
 ;
setex604 ; @TEST setex^%ts(.string,"to make love "): from relative, to absolute
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
  new string set string="is to unmake power"
 set string("extract","from")="b"
 set string("extract","to")=3
 do setex^%ts(.string,"to make love ")
 do CHKEQ^%ut(string,"to make love is to unmake power")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),13)
 ;
 quit  ; end of setex604
 ;
 ;
setex605 ; @TEST setex^%ts(.string,"to make love "): put flag in from and to
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
  new string set string="is to unmake power"
 set string("extract","from")="b"
 set string("extract","to")="b"
 do setex^%ts(.string,"to make love ")
 do CHKEQ^%ut(string,"to make love is to unmake power")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),13)
 ;
 quit  ; end of setex605
 ;
 ;
setex606 ; @TEST setex^%ts(.string,"to make love "): put flag in to
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
  new string set string="is to unmake power"
 set string("extract","from")="0"
 set string("extract","to")="b"
 do setex^%ts(.string,"to make love ")
 do CHKEQ^%ut(string,"")
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setex606
 ;
 ;
 ; group 7: synonyms
 ;
 ;
setex701 ; @TEST se^%ts(.string,"bright"): test se^%ts synonym
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="O the hawk's flight"
 do se^%ts(.string,"bright")
 do CHKEQ^%ut(string,"bright the hawk's flight")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),6)
 ;
 quit  ; end of setex701
 ;
 ;
setex702 ; @TEST setExtract^%ts(.string,"bright"): test setExtract^%ts synonym
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="O the hawk's flight"
 do setExtract^%ts(.string,"bright")
 do CHKEQ^%ut(string,"bright the hawk's flight")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),6)
 ;
 quit  ; end of setex702
 ;
 ;
setex703 ; @TEST place^%ts(.string,"bright"): test place^%ts synonym
 ;
 ;ven/toad&lmry;test;procedure;clean;silent;sac
 ;
 new string set string="O the hawk's flight"
 do place^%ts(.string,"bright")
 do CHKEQ^%ut(string,"bright the hawk's flight")
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),6)
 ;
 quit  ; end of setex703
 ;
 ;
eor ; end of routine %tsutes

%tsutfs
%tsutfs ;ven/toad-type string: test setfind^%ts ;2018-03-18T16:38Z
 ;;1.8;Mash;
 ;
 ; %tsutfs implements unit tests for ppi setfind^%ts.
 ; See %tsfs for the code for setfind^%ts.
 ; See %tsut for the whole unit-test library.
 ; See %tsud for documentation introducing the String library,
 ; including an intro to the String Find library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsutfs contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@additional-dev: Linda M. R. Yaw (lmry)
 ; lmry@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2016/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-18T16:38Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@contents
 ; [all unit tests]
 ;
 ;
 ;
 ;@section 1 unit tests for setfind^%ts
 ;
 ;
 ;
 ;@called-by
 ; M-Unit
 ;  EN^%ut (called by ^%tsut)
 ;  COVERAGE^%ut (called by cover^%tsut)
 ;@calls
 ; CHKEQ^%ut
 ; setfind^%ts
 ; sf^%ts
 ; setFind^%ts
 ; replace^%ts
 ;
 ;
 ;
 ; group 1: Find First & Find Next
 ;
 ;
 ;
setfind01 ; @TEST setfind^%ts: no next match
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"Kansas","Dorothy")
 do CHKEQ^%ut(string,"totototo")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind01
 ;
 ;
 ;
setfind02 ; @TEST setfind^%ts: find first & next
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"Dorothytoto")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),7)
 ;
 do setfind^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),8)
 do CHKEQ^%ut(string("extract","to"),14)
 ;
 do setfind^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind02
 ;
 ;
 ;
setfind03 ; @TEST setfind^%ts: find next from
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=1
 set string("extract","to")=2
 do setfind^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"toDorothyto")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),3)
 do CHKEQ^%ut(string("extract","to"),9)
 ;
 quit  ; end of setfind03
 ;
 ;
 ;
setfind04 ; @TEST setfind^%ts: no match next from
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=6
 set string("extract","to")=7
 do setfind^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"totototo")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind04
 ;
 ;
 ;
 ; group 2: Find Last & Find Previous
 ;
 ;
 ;
setfind05 ; @TEST setfind^%ts: no previous match
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"Kansas","Dorothy","b")
 do CHKEQ^%ut(string,"totototo")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind05
 ;
 ;
 ;
setfind06 ; @TEST setfind^%ts: find last & previous
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"toto","Dorothy","b")
 do CHKEQ^%ut(string,"totoDorothy")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),5)
 do CHKEQ^%ut(string("extract","to"),11)
 ;
 do setfind^%ts(.string,"toto","Dorothy","b")
 do CHKEQ^%ut(string,"DorothyDorothy")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),7)
 ;
 do setfind^%ts(.string,"toto","Dorothy","b")
 do CHKEQ^%ut(string,"DorothyDorothy")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind06
 ;
 ;
 ;
setfind07 ; @TEST setfind^%ts: find previous from
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=7
 set string("extract","to")=8
 do setfind^%ts(.string,"toto","Dorothy","b")
 do CHKEQ^%ut(string,"toDorothyto")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),3)
 do CHKEQ^%ut(string("extract","to"),9)
 ;
 quit  ; end of setfind07
 ;
 ;
 ;
setfind08 ; @TEST setfind^%ts: no match previous from
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 set string("extract","from")=1
 set string("extract","to")=2
 do setfind^%ts(.string,"toto","Dorothy","b")
 do CHKEQ^%ut(string,"totototo")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind08
 ;
 ;
 ;
 ; group 3: Find Case-Insensitive
 ;
 ;
 ;
setfind09 ; @TEST setfind^%ts: find case-insensitive
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"Toto","Dorothy")
 do CHKEQ^%ut(string,"totototo")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 do setfind^%ts(.string,"Toto","Dorothy","i")
 do CHKEQ^%ut(string,"Dorothytoto")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),7)
 ;
 do setfind^%ts(.string,"toto","Dorothy","i")
 do CHKEQ^%ut(string,"DorothyDorothy")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),8)
 do CHKEQ^%ut(string("extract","to"),14)
 ;
 quit  ; end of setfind09
 ;
 ;
 ;
 ; group 4: Boundary Cases
 ;
 ;
 ;
setfind10 ; @TEST setfind^%ts: undefined string
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string
 do setfind^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind10
 ;
 ;
 ;
setfind11 ; @TEST setfind^%ts: empty string
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string=""
 do setfind^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind11
 ;
 ;
 ;
setfind12 ; @TEST setfind^%ts: empty find
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"","Dorothy")
 do CHKEQ^%ut(string,"totototo")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind12
 ;
 ;
 ;
setfind13 ; @TEST setfind^%ts: empty find & string
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string=""
 do setfind^%ts(.string,"","Dorothy")
 do CHKEQ^%ut(string,"")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind13
 ;
 ;
 ;
setfind14 ; @TEST setfind^%ts: empty replace
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"toto")
 do CHKEQ^%ut(string,"toto")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind14
 ;
 ;
 ;
setfind15 ; @TEST setfind^%ts: empty replace backward
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"toto","","b")
 do CHKEQ^%ut(string,"toto")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind15
 ;
 ;
 ;
setfind16 ; @TEST setfind^%ts: empty find & replace
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string)
 do CHKEQ^%ut(string,"totototo")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind16
 ;
 ;
 ;
setfind17 ; @TEST setfind^%ts: empty string, find, & replace
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string
 do setfind^%ts(.string)
 do CHKEQ^%ut(string,"")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind17
 ;
 ;
 ;
setfind18 ; @TEST setfind^%ts: bad flag
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"toto","Dorothy","badflag")
 do CHKEQ^%ut(string,"totototo")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind18
 ;
 ;
 ;
 ; group 5: Alternate Signatures
 ;
 ;
 ;
setfind19 ; @TEST setfind^%ts: alternate signatures
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do sf^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"Dorothytoto")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),1)
 do CHKEQ^%ut(string("extract","to"),7)
 ;
 do setFind^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),8)
 do CHKEQ^%ut(string("extract","to"),14)
 ;
 quit  ; end of setfind19
 ;
 ;
 ;
 ; group 6: Find & Replace All
 ;
 ;
 ;
setfind20 ; @TEST setfind^%ts: all backward case-insensitive
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"toto","Dorothy","abir")
 do CHKEQ^%ut(string,"DorothyDorothy")
 do CHKEQ^%ut(string("extract"),1)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind20
 ;
 ;
 ;
setfind21 ; @TEST setfind^%ts: all but no next match
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do setfind^%ts(.string,"Kansas","Dorothy","a")
 do CHKEQ^%ut(string,"totototo")
 do CHKEQ^%ut(string("extract"),0)
 do CHKEQ^%ut(string("extract","from"),0)
 do CHKEQ^%ut(string("extract","to"),0)
 ;
 quit  ; end of setfind21
 ;
 ;
 ;
eor ; end of routine %tsutfs

%tsutfwr
%tsutfwr ;ven/toad-type string: test findReplace^%ts ;2018-03-18T16:30Z
 ;;1.8;Mash;
 ;
 ; %tsutfwr implements unit tests for ppi findReplace^%ts.
 ; See %tsfwr for the code for findReplace^%ts.
 ; See %tsut for the whole unit-test library.
 ; See %tsud for documentation introducing the String library,
 ; including an intro to the String Find library.
 ; See %tsudf for a detailed map of the String Find library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsutfwr contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@additional-dev: Linda M. R. Yaw (lmry)
 ; lmry@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2016/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-18T16:30Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@contents
 ; [all unit tests]
 ;
 ;
 ;
 ;@section 1 unit tests for findReplace^%ts
 ;
 ;
 ;
 ;@called-by
 ; M-Unit
 ;  EN^%ut (called by ^%tsut)
 ;  COVERAGE^%ut (called by cover^%tsut)
 ;@calls
 ; CHKEQ^%ut
 ; findReplace^%ts
 ;
 ;
 ;
findrep01 ; @TEST findReplace^%ts: no next match
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplace^%ts(.string,"Kansas","Dorothy")
 do CHKEQ^%ut(string,"totototo")
 ;
 quit  ; end of findrep01
 ;
 ;
 ;
findrep02 ; @TEST findReplace^%ts: find first & next
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplace^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"Dorothytoto")
 ;
 do findReplace^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 ;
 do findReplace^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 ;
 quit  ; end of findrep02
 ;
 ;
 ;
findrep03 ; @TEST findReplace^%ts: find case-insensitive
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplace^%ts(.string,"Toto","Dorothy")
 do CHKEQ^%ut(string,"Dorothytoto")
 ;
 do findReplace^%ts(.string,"Toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 ;
 quit  ; end of findrep03
 ;
 ;
 ;
findrep04 ; @TEST findReplace^%ts: undefined string
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string
 do findReplace^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrep04
 ;
 ;
 ;
findrep05 ; @TEST findReplace^%ts: empty string
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string=""
 do findReplace^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrep05
 ;
 ;
 ;
findrep06 ; @TEST findReplace^%ts: empty find
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplace^%ts(.string,"","Dorothy")
 do CHKEQ^%ut(string,"totototo")
 ;
 quit  ; end of findrep06
 ;
 ;
 ;
findrep07 ; @TEST findReplace^%ts: empty find & string
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string=""
 do findReplace^%ts(.string,"","Dorothy")
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrep07
 ;
 ;
 ;
findrep08 ; @TEST findReplace^%ts: empty replace
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplace^%ts(.string,"toto")
 do CHKEQ^%ut(string,"toto")
 ;
 do findReplace^%ts(.string,"toto")
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrep08
 ;
 ;
 ;
findrep09 ; @TEST findReplace^%ts: empty find & replace
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplace^%ts(.string)
 do CHKEQ^%ut(string,"totototo")
 ;
 quit  ; end of findrep09
 ;
 ;
 ;
findrep10 ; @TEST findReplace^%ts: empty string, find, & replace
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string
 do findReplace^%ts(.string)
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrep10
 ;
 ;
 ;
eor ; end of routine %tsutfwr

%tsutfwra
%tsutfwra ;ven/toad-type string: test findReplaceAll^%ts ;2018-03-18T17:39Z
 ;;1.8;Mash;
 ;
 ; %tsutfwra implements unit tests for ppi findReplaceAll^%ts.
 ; See %tsfwra for the code for findReplaceAll^%ts.
 ; See %tsut for the whole unit-test library.
 ; See %tsud for documentation introducing the String library,
 ; including an intro to the String Find library.
 ; See %tsudf for a detailed map of the String Find library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsutfwra contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@additional-dev: Linda M. R. Yaw (lmry)
 ; lmry@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2016/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-18T17:39Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@contents
 ; [all unit tests]
 ;
 ;
 ;
 ;@section 1 unit tests for findReplaceAll^%ts
 ;
 ;
 ;
 ;@called-by
 ; M-Unit
 ;  EN^%ut (called by ^%tsut)
 ;  COVERAGE^%ut (called by cover^%tsut)
 ;@calls
 ; CHKEQ^%ut
 ; findReplaceAll^%ts
 ;
 ;
 ;
findrepa01 ; @TEST findReplaceAll^%ts: no match
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplaceAll^%ts(.string,"Kansas","Dorothy")
 do CHKEQ^%ut(string,"totototo")
 ;
 quit  ; end of findrepa01
 ;
 ;
 ;
findrepa02 ; @TEST findReplaceAll^%ts: find & replace all
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplaceAll^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 ;
 do findReplaceAll^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 ;
 quit  ; end of findrepa02
 ;
 ;
 ;
findrepa03 ; @TEST findReplaceAll^%ts: find case-insensitive
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplaceAll^%ts(.string,"Toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 ;
 do findReplaceAll^%ts(.string,"Toto","Dorothy")
 do CHKEQ^%ut(string,"DorothyDorothy")
 ;
 quit  ; end of findrepa03
 ;
 ;
 ;
findrepa04 ; @TEST findReplaceAll^%ts: undefined string
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string
 do findReplaceAll^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrepa04
 ;
 ;
 ;
findrepa05 ; @TEST findReplaceAll^%ts: empty string
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string=""
 do findReplaceAll^%ts(.string,"toto","Dorothy")
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrepa05
 ;
 ;
 ;
findrepa06 ; @TEST findReplaceAll^%ts: empty find
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplaceAll^%ts(.string,"","Dorothy")
 do CHKEQ^%ut(string,"totototo")
 ;
 quit  ; end of findrepa06
 ;
 ;
 ;
findrepa07 ; @TEST findReplaceAll^%ts: empty find & string
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string=""
 do findReplaceAll^%ts(.string,"","Dorothy")
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrepa07
 ;
 ;
 ;
findrepa08 ; @TEST findReplaceAll^%ts: empty replace
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplaceAll^%ts(.string,"toto")
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrepa08
 ;
 ;
 ;
findrepa09 ; @TEST findReplaceAll^%ts: empty find & replace
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string set string="totototo"
 do findReplaceAll^%ts(.string)
 do CHKEQ^%ut(string,"totototo")
 ;
 quit  ; end of findrepa09
 ;
 ;
 ;
findrepa10 ; @TEST findReplaceAll^%ts: empty string, find, & replace
 ;
 ;ven/toad;test;procedure;clean;silent;sac
 ;
 new string
 do findReplaceAll^%ts(.string)
 do CHKEQ^%ut(string,"")
 ;
 quit  ; end of findrepa10
 ;
 ;
 ;
eor ; end of routine %tsutfwra

%tsutjt
%tsutjt ;ven/mcglk&toad-type string: test $$trim ;2018-03-05T20:47Z
 ;;1.8;Mash;
 ;
 ; %tsutjt implements eleven unit tests for api $$trim^%ts.
 ; See %tsjt for the code for $$trim^%ts.
 ; See %tsut for the whole unit-test library.
 ; See %tsud for documentation introducing the String library,
 ; including an intro to the String Justify library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsutjt contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Ken McGlothlen (mcglk)
 ; mcglk@vistaexpertise.net
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2016/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-05T20:47Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@contents
 ; [all unit tests]
 ;
 ;
 ;
 ;@section 1 unit tests for $$trim^%ts
 ;
 ;
 ;
 ;@called-by
 ; M-Unit
 ;  EN^%ut (called by ^%tsut)
 ;  COVERAGE^%ut (called by cover^%tsut)
 ;@calls
 ; CHKEQ^%ut
 ; $$trim^%ts
 ;
 ;
 ;
trim01 ; @TEST $$trim^%ts(%s): trim spaces from both ends
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="     May the hair on your toes never fall out!     "
 new result set result="May the hair on your toes never fall out!"
 do CHKEQ^%ut($$trim^%ts(%s),result)
 ;
 quit  ; end of trim01
 ;
 ;
 ;
trim02 ; @TEST $$trim^%ts(%s,"LR"): trim spaces from both ends
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="     May the hair on your toes never fall out!     "
 new %e set %e="LR"
 new result set result="May the hair on your toes never fall out!"
 do CHKEQ^%ut($$trim^%ts(%s,%e),result)
 ;
 quit  ; end of trim02
 ;
 ;
 ;
trim03 ; @TEST $$trim^%ts(%s,"LR"," "): trim spaces from both ends
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="     May the hair on your toes never fall out!     "
 new %e set %e="LR"
 new %c set %c=" "
 new result set result="May the hair on your toes never fall out!"
 do CHKEQ^%ut($$trim^%ts(%s,%e,%c),result)
 ;
 quit  ; end of trim03
 ;
 ;
 ;
trim04 ; @TEST $$trim^%ts(%s,"L"): trim spaces from beginning
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="     May the hair on your toes never fall out!     "
 new %e set %e="L"
 new result set result="May the hair on your toes never fall out!     "
 do CHKEQ^%ut($$trim^%ts(%s,%e),result)
 ;
 quit  ; end of trim04
 ;
 ;
 ;
trim05 ; @TEST $$trim^%ts(%s,"L"," "): trim spaces from beginning
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="     May the hair on your toes never fall out!     "
 new %e set %e="L"
 new %c set %c=" "
 new result set result="May the hair on your toes never fall out!     "
 do CHKEQ^%ut($$trim^%ts(%s,%e,%c),result)
 ;
 quit  ; end of trim05
 ;
 ;
 ;
trim06 ; @TEST $$trim^%ts(%s,"R"): trim spaces from end
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="     May the hair on your toes never fall out!     "
 new %e set %e="R"
 new result set result="     May the hair on your toes never fall out!"
 do CHKEQ^%ut($$trim^%ts(%s,%e),result)
 ;
 quit  ; end of trim06
 ;
 ;
 ;
trim07 ; @TEST $$trim^%ts(%s,"R"," "): trim spaces from end
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="     May the hair on your toes never fall out!     "
 new %e set %e="R"
 new %c set %c=" "
 new result set result="     May the hair on your toes never fall out!"
 do CHKEQ^%ut($$trim^%ts(%s,%e,%c),result)
 ;
 quit  ; end of trim07
 ;
 ;
 ;
trim08 ; @TEST $$trim^%ts(%s,"ZQ"," "): no-op
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="     May the hair on your toes never fall out!     "
 new %e set %e="ZQ"
 new %c set %c=" "
 new result set result=%s
 do CHKEQ^%ut($$trim^%ts(%s,%e,%c),result)
 ;
 quit  ; end of trim08
 ;
 ;
 ;
trim09 ; @TEST $$trim^%ts(%s,"LR","*"): something other than a space
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="*****May the hair on your toes never fall out!*****"
 new %e set %e="LR"
 new %c set %c="*"
 new result set result="May the hair on your toes never fall out!"
 do CHKEQ^%ut($$trim^%ts(%s,%e,%c),result)
 ;
 quit  ; end of trim09
 ;
 ;
 ;
trim10 ; @TEST $$trim^%ts(%s,," "): missing second argument
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="     May the hair on your toes never fall out!     "
 new %c set %c=" "
 new result set result="May the hair on your toes never fall out!"
 do CHKEQ^%ut($$trim^%ts(%s,,%c),result)
 ;
 quit  ; end of trim10
 ;
 ;
 ;
trim11 ; @TEST $$trim^%ts(%s,," "): trim to nothing
 ;
 ;ven/mcglk&toad;test;procedure;clean?;silent?;sac
 ;
 new %s set %s="                                    "
 new %c set %c=" "
 new result set result=""
 do CHKEQ^%ut($$trim^%ts(%s,,%c),result)
 do CHKEQ^%ut($$trim^%ts(%s,"L",%c),result)
 do CHKEQ^%ut($$trim^%ts(%s,"R",%c),result)
 do CHKEQ^%ut($$trim^%ts(%s,"LR",%c),result)
 ;
 quit  ; end of trim11
 ;
 ;
 ;
eor ; end of routine %tsutjt

%tsutvs
%tsutvs ;ven/mcglk&toad-type string: test $$strip ;2018-03-05T19:35Z
 ;;1.8;Mash;
 ;
 ; %tsutvs implements seven unit tests for api $$strip^%ts.
 ; See %tsvs for the code for $$strip^%ts.
 ; See %tsut for the whole unit-test library.
 ; See %tsud for documentation introducing the String library,
 ; including an intro to the String Validation library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsutvs contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Ken McGlothlen (mcglk)
 ; mcglk@vistaexpertise.net
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2016/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-05T19:35Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@contents
 ; [all unit tests]
 ;
 ;
 ;
 ;@section 1 unit tests for $$strip^%ts
 ;
 ;
 ;
 ;@called-by
 ; M-Unit
 ;  EN^%ut (called by ^%tsut)
 ;  COVERAGE^%ut (called by cover^%tsut)
 ;@calls
 ; CHKEQ^%ut
 ; $$strip^%ts
 ;
 ;
 ;
strip01 ; @TEST $$strip^%ts(%s): strip single character
 ;
 ;ven/mcglk&toad;test;procedure;clean;silent;sac
 ;
 new %s set %s="In a hole in the ground, there lived a hobbit."
 new result set result="Inaholeintheground,therelivedahobbit."
 do CHKEQ^%ut($$strip^%ts(%s),result)
 ;
 quit  ; end of strip01
 ;
 ;
 ;
strip02 ; @TEST $$strip^%ts(%s,%c): strip single character
 ;
 ;ven/mcglk&toad;test;procedure;clean;silent;sac
 ;
 new %s set %s="In a hole in the ground, there lived a hobbit."
 new %c set %c="h"
 new result set result="In a ole in te ground, tere lived a obbit."
 do CHKEQ^%ut($$strip^%ts(%s,%c),result)
 ;
 quit  ; end of strip02
 ;
 ;
 ;
strip03 ; @TEST $$strip^%ts(%s,%c): strip multiple characters
 ;
 ;ven/mcglk&toad;test;procedure;clean;silent;sac
 ;
 new %s set %s="In a hole in the ground, there lived a hobbit."
 new %c set %c="hd"
 new result set result="In a ole in te groun, tere live a obbit."
 do CHKEQ^%ut($$strip^%ts(%s,%c),result)
 ;
 quit  ; end of strip03
 ;
 ;
 ;
strip04 ; @TEST $$strip^%ts(%s): strip non-existent characters
 ;
 ;ven/mcglk&toad;test;procedure;clean;silent;sac
 ;
 new %s set %s="Inaholeintheground,therelivedahobbit."
 new result set result=%s
 do CHKEQ^%ut($$strip^%ts(%s),result)
 ;
 quit  ; end of strip04
 ;
 ;
 ;
strip05 ; @TEST $$strip^%ts(%s,%c): strip non-existent characters
 ;
 ;ven/mcglk&toad;test;procedure;clean;silent;sac
 ;
 new %s set %s="In a hole in the ground, there lived a hobbit."
 new %c set %c="qx"
 new result set result=%s
 do CHKEQ^%ut($$strip^%ts(%s,%c),result)
 ;
 quit  ; end of strip05
 ;
 ;
 ;
strip06 ; @TEST $$strip^%ts(%s): strip from empty string
 ;
 ;ven/mcglk&toad;test;procedure;clean;silent;sac
 ;
 new %s set %s=""
 new result set result=%s
 do CHKEQ^%ut($$strip^%ts(%s),result)
 ;
 quit  ; end of strip06
 ;
 ;
 ;
strip07 ; @TEST $$strip^%ts(%s,%c): strip from empty string
 ;
 ;ven/mcglk&toad;test;procedure;clean;silent;sac
 ;
 new %s set %s=""
 new %c set %c="qx"
 new result set result=%s
 do CHKEQ^%ut($$strip^%ts(%s,%c),result)
 ;
 quit  ; end of strip07 ;
 ;
 ;
eor ; end of routine %tsutvs

%tsvs
%tsvs ;ven/toad-type string: $$strip^%ts ;2018-03-05T19:39Z
 ;;1.8;Mash;
 ;
 ; %tsvs implements MASH String Library ppi $$strip^%ts, strip
 ; character(s) from string; it is part of the String Validation
 ; sublibrary.
 ; See %tsutvs for unit tests for $$strip^%ts.
 ; See %tsudv for notes on the String Validation sublibrary.
 ; See %tsud for an introduction to the String library, including an
 ; intro to the String Validation library.
 ; See %tsul for the module's primary-development log.
 ; See %ts for the module's ppis & apis.
 ; %tsvs contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2012/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-05T19:39Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Type String - %ts
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@original-dev: R. Wally Fort (rwf)
 ;@original-dev-org: U.S. Department of Veterans Affairs
 ; prev. Veterans Administration
 ; National Development Office in San Francisco (vaisf)
 ;
 ;@to-do
 ; apply standard string-length protection consistently
 ;
 ;
 ;
 ;@section 1 code
 ;
 ;
 ;
 ;@ppi-code $$strip^%ts
strip ; strip character(s) from string
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;isf/rwf,ven/toad;private;function;clean;silent;sac;100% tests
 ;@signatures
 ; $$strip^%ts(string)
 ; $$strip^%ts(string,char)
 ;@branches-from
 ; $$strip^%ts
 ;@called-by: none
 ;@calls: none
 ;@input
 ; string = string to edit
 ; char = characters to strip, defaults to space
 ;@output = edited string
 ;@examples
 ; write "[",$$strip^%ts("  A B C  "),"]" => [ABC]
 ; write "[",$$strip^%ts("//A B C//","/"),"]" => [A B C]
 ; write "[",$$strip^%ts("//A B C//","/ "),"]" => [ABC]
 ; write "[",$$strip^%ts("//A B C//","@"),"]" => [//A B C//]
 ; write "[",$$strip^%ts("//A B C//",""),"]" => [//A B C//]
 ; write "[",$$strip^%ts("","/"),"]" => []
 ;@tests: in %tsutrs
 ; strip01: strip single character
 ; strip02: strip single character
 ; strip03: strip multiple characters
 ; strip04: strip non-existent characters
 ; strip05: strip non-existent characters
 ; strip06: strip from empty string
 ; strip07: strip from empty string
 ;
 ;@stanza 2 strip characters from string
 ;
 set string=$get(string) ; avoid undefined error
 set char=$get(char," ") ; default to stripping spaces
 set string=$translate(string,char,"")
 ;
 ;@stanza 3 return & termination
 ;
 quit string ; return stripped string; end of $$strip^%ts
 ;
 ;
eor ; end of routine %tsvs

%wd
%wd ;ven/gpl-write dialog: ppi & api library ;2018-02-06T19:33Z
 ;;1.8;Mash;
 ;
 ; %wd is the Write Dialog Library's ppi & api routine. It currently
 ; supports the suite of tools for graphstore-format datasets, which will
 ; eventually be moved over to %sf & %sfg. Graphstores are Mash's primary
 ; dataset format.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-02-06T19:33Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Write Dialog - %wd
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@module-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-09-24 ven/gpl %*1.8t01 %wd: create routine as ppi & api library.
 ;
 ; 2018-02-06 ven/toad %1.8t04 %wd: passim add white space & hdr comments,
 ; tag w/Apache license & attribution & to-do to shift to %sf later.
 ;
 ;@to-do
 ; convert entry points to ppi/api style
 ; %wdgraph: r/all local calls w/calls through ^%wd
 ; renamespace under %sf & %sfg
 ;
 ;@contents
 ; all private programming interfaces for now
 ; some public web services & apis later
 ;
 ;
 ;
 ;@section 1 graph-handling ppis
 ;
 ;
 ;
setroot(graph) ; root of working storage
 ;
 quit $$setroot^%wdgraph(graph) ; end of $$setroot^%wd
 ;
 ;
 ;
rootOf(graph) ; return the root of graph named graph
 ;
 quit $$rootOf^%wdgraph(graph) ; end of $$rootOf^%wd
 ;
 ;
 ;
addgraph(graph) ; makes a place in the graph file for a new graph
 ;
 do addgraph^%wdgraph(graph)
 ;
 quit  ; end of addgraph^%wd
 ;
 ;
 ;
purgegraph(graph) ; delete a graph
 ;
 do purgegraph^%wdgraph(graph)
 ;
 quit  ; end of purgegraph^%wd
 ;
 ;
 ;
insert2graph(ary,graph,replace) ; insert a new entry to a graph
 ;
 do insert2graph^%wdgraph(.ary,graph,replace)
 ;
 quit  ; end of insert2graph^%wd
 ;
 ;
 ;
nameThis(altname) ; returns the id to be used for altname
 ;
 ; this will eventually use the context graph and the 
 ; local variable context to query the altname and obtain an id
 ;
 quit $$nameThis^%wdgraph(altname) ; end of $$nameThis^%wd
 ;
 ;
 ;
getThis(rary,fn,nocache) ; find a file and read it into rary array
 ;
 do getThis^%wdgraph(rary,fn,$get(nocache))
 ;
 quit  ; end of getThis^%wd
 ;
 ;
 ;
queryContext(context,locator,property) ; look up project specific
 ;
 ; names and values from the context graph
 ; tbd
 ;
 quit $$queryContext^%wdgraph(context,locator,property) ; end of $$queryContext^%wd
 ;
 ;
 ;
queryTag(rtn,tag) ; returns a json/mumps array of tagged items
 ;
 do queryTag^%wdgraph(rtn,tag)
 ;
 quit  ; end of queryTag^%wd
 ;
 ;
 ;
fromCache(rary,name,graph) ; return a file from the cache
 ;
 do fromCache^%wdgraph(rary,name,graph)
 ;
 quit  ; end of fromCache^%wd
 ;
 ;
 ;
toCache(arry,name,graph) ; put a file in the cache
 ;
 do toCache^%wdgraph(arry,name,graph)
 ;
 quit  ; end of toCache^%wd
 ;
 ;
 ;
beautify(inary,outary) ; pretty print a line of json
 ;
 do beautify^%wdgraph(inary,outary)
 ;
 quit  ; end of beautify^%wd
 ;
 ;
 ;
ary2file(ary,dir,file) ;
 ;
 do ary2file^%wdgraph(.ary,dir,file)
 ;
 quit  ; end of ary2file^%wd
 ;
 ;
 ;
file2ary(ary,dir,file)
 ;
 do file2ary^%wdgraph(.ary,dir,file)
 ;
 quit  ; end of file2ary^%wd
 ;
 ;
 ;
 ;@section 2 csv-handling ppis
 ;
 ;
 ;
csv2graph(source,graph,noindex) ; import a csv file to a graph
 ;
 ; graph is optional, will default to csvGraph
 ; source is either a filename which will be found in seeGraph
 ; or a global passed by name usually loaded with FTG^%ZISH
 ;
 do csv2graph^%wdcsv(source,$get(graph),$g(noindex))
 ;
 quit  ; end of csv2graph^%wd
 ;
 ;
 ;
prune(txt) ; extrinsic removes extra quotes
 ;
 quit $$prune^%wdcsv(txt) ; end of $$prune^%wd
 ;
 ;
 ;
delim(ary) ; figures out the cvs delimiter
 ;
 ; return -1 if there not found
 ; ary is passed by reference
 ; returns the delimiter
 ;
 quit $$delim^%wdcsv(.ary) ; end of $$delim^%wd
 ;
 ;
 ;
wellformed(ary,delim) ; extrinsic returns 1 if ary is well formed
 ;
 ; checks to see that the count of the delimiter is the same
 ; on every line
 ; ary is passed by reference
 ;
 quit $$wellformed^%wdcsv(.ary,delim) ; end of $$wellformed^%wd
 ;
 ;
 ;
eor ; end of routine %wd

%wdcsv
%wdcsv  ;ven/gpl-write dialog: csv processing ;2018-02-06T21:47Z
 ;;1.8;Mash;
 ;
 ; %wdcsv implements the Write Document Library's csv ppis & apis.
 ; These will eventually be moved to another Mash namespace, tbd.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-02-06T21:47Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Write Dialog - %wd
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@module-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-09-24 ven/gpl %*1.8t01 %wdcsv: create routine to hold
 ; all csv methods.
 ;
 ; 2018-02-06 ven/toad %*1.8t04 %wdcsv: passim add white space &
 ; hdr comments, tag w/Apache license & attribution & to-do to shift
 ; to %sf later.
 ;
 ;@to-do
 ; %wd: convert entry points to ppi/api style
 ; r/all local calls w/calls through ^%wd
 ; break up into smaller routines & change branches from %wd
 ; renamespace under %sfg? under %sfh? research best choice
 ;
 ;@contents
 ; csv2graph: import csv file to graph
 ; $$prune = extrinsic removes extra quotes
 ; $$delim = figures out csv delimiter
 ; $$rename = extrinsic returns new name or old name if not found
 ; $$wellformed = extrinsic returns 1 if csv ary is well formed
 ;
 ;
 ;
 ;@section 1 code to implement ppis & apis
 ;
 ;
 ;
csv2graph(source,graph,noindex) ; import a csv file to a graph
 ;
 ; graph is optional, will default to csvGraph
 ; source is either a filename which will be found in seeGraph
 ; or a global passed by name usually loaded with FTG^%ZISH
 ; if noindex=1 an index will not be generated
 ;
 new %wary,%wi,%wgraph
 if $extract(source,1)="^" merge %wary=@$name(source)
 else  do getThis^%wdgraph("%wary",source)
 new delim s delim=$$delim(.%wary)
 if delim=-1 do  quit  ;
 . write !,"error, delimiter not found"
 . quit
 if '$$wellformed(.ary,delim) do  quit  ;
 . write !,"error, csv file not well formed delimiter="_delim
 . quit
 new %wgraph,%wcol,%wid ; place to store the graph and the id of the graph
 ; %wcol contains the column names in order
 set %wid=$$nameThis^%wdgraph(source) ; get the id from the context
 ; first get the column names from row 1
 ;for %wi=1:1:$length(%wary(1),delim) set %wcol(%wi)=$$rename($translate($$prune($piece(%wary(1),delim,%wi))," ","_"))
 for %wi=1:1:$length(%wary(1),delim) set %wcol(%wi)=$translate($$prune($piece(%wary(1),delim,%wi))," ","_")
 set %wi=1
 for  set %wi=$order(%wary(%wi)) quit:+%wi=0  do  ;
 . new %wj
 . ; write !,%wary(%wi)
 . for %wj=1:1:$length(%wary(%wi),delim) do  ;
 . . new %wval set %wval=$piece(%wary(%wi),delim,%wj)
 . . if %wval'="" set %wgraph(%wid,%wi,%wcol(%wj))=$$prune(%wval)
 . . quit
 . quit
 if $get(graph)="" set graph="csvGraph"
 merge %wgraph(%wid,"order")=%wcol
 new rpl set rpl=1
 do insert2graph^%wdgraph("%wgraph",graph,rpl)
 ;
 i $g(noindex)'=1 d  ; we want in index
 . n root s root=$$setroot^%wd(graph)
 . s groot=$na(@root@("graph",source))
 . d index(groot)
 . s @root@("index","root")=groot
 . 
 ;
 quit  ; end of csv2graph^%wd
 ;
 ;
 ;
prune(txt) ; extrinsic removes extra quotes
 ;
 ;if txt'["""" quit  ; no extra quotes 
 if txt'["""" quit txt  ; no extra quotes - fix by gpl 
 new %w1,%return set %return=""
 for %w1=1:1:$length(txt,"""") do  ;
 . set %return=%return_$piece(txt,"""",%w1)
 . quit
 ;
 quit %return ; end of prune^%wd
 ;
 ;
 ;
delim(ary) ; figures out the csv delimiter
 ;
 ; return -1 if there not found
 ; ary is passed by reference
 ; returns the delimiter
 ;
 new %wdlim,%wfound,%return set %wfound=0
 for %wdlim=$char(9),",","|" quit:%wfound  do  ; for each common delimiter
 . new %count set %count=$length(ary(1),%wdlim) ; how many in line 1
 . if %count<2 quit  ;
 . if $length(ary(2),%wdlim)=%count s %wfound=1 s %return=%wdlim
 . if $data(ary(3)) if $length(ary(3),%wdlim)='%count set %wfound=0 kill %return
 . if $data(ary(4)) if $length(ary(4),%wdlim)='%count set %wfound=0 kill %return
 . quit
 if %wfound=0 quit -1
 ;
 quit %return ; end of $$delim^%wd
 ;
 ;
 ;
rename(name) ; extrinsic returns new name or old name if not found
 q  ; this routine needs to be rewritten - gpl
 ;
 ; this is a temporary routine until the csv files are updated
 ;
 new nam
 set nam("Sub._#")="sub#"
 set nam("Field_Name")="fieldName"
 set nam("Title")="fieldTitle"
 set nam("Data_Type")="dataType"
 set nam("Value")="value"
 set nam("Definition")="definition"
 set nam("m-class-#")="mClass#"
 set nam("m-prop-#")="mProp#"
 set nam("m-prop-name")="mPropName"
 set nam("m-prop-title")="mPropTitle"
 set nam("m-prop-loc")="mPropLoc"
 set nam("m-prop-type")="mPropType"
 set nam("m-prop-det")="mPropDet"
 set nam("m-delim-check")="mDlimCheck"
 new namtmp set namtmp=$get(nam(name))
 if namtmp="" set namtmp=name
 ;
 quit namtmp ; end of $$rename^%wd
 ;
 ;
 ;
wellformed(ary,delim) ; extrinsic returns 1 if csv ary is well formed
 ;
 ; checks to see that the count of the delimiter is the same
 ; on every line
 ; ary is passed by reference
 ;
 new %wi,%count,%result set %wi=0 set %result=1
 for  set %wi=$order(ary(%wi)) quit:+%wi=0  do  ;
 . if '$data(%count) set %count=$length(ary(%wi),delmin) quit  ;
 . if $length(ary(%wi))'=%count set %result=0
 . quit
 ;
 quit %result ; end of $$wellformed^%wd
 ;
 ;
index(zgraph) ; will create a pos and ops index at the place pointed to by graph
 ; zgraph is passed by name
 ; 
 i $d(@zgraph@("pos")) k @zgraph@("pos")
 i $d(@zgraph@("ops")) k @zgraph@("ops")
 n zi s zi=0
 f  s zi=$o(@zgraph@(zi)) q:+zi=0  d  ;
 . n zj,zv
 . s zj=""
 . f  s zj=$o(@zgraph@(zi,zj)) q:zj=""  d  ;
 . . s zv=$g(@zgraph@(zi,zj))
 . . q:zv=""
 . . s @zgraph@("pos",zj,zv,zi)=""
 . . s @zgraph@("ops",zv,zj,zi)=""
 q
 ;
 ;
eor ; end of routine %wdcsv

%wdgraph
%wdgraph ;ven/gpl-write dialog: graphstore ;2018-03-07T18:47Z
 ;;1.8;Mash;
 ;
 ; %wdgraph implements the Write Document Library's ppis & apis. At
 ; present, these are all graphstore-format dataset methods, which
 ; will eventually be moved to the %sfg namespace. Mash's primary
 ; dataset format is the graphstore.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-07T18:47Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Write Dialog - %wd
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@module-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-09-24 ven/gpl %*1.8t01 %wdgraph: create routine to hold
 ; all graphstore methods.
 ;
 ; 2018-02-06 ven/toad %*1.8t04 %wdgraph: passim add white space &
 ; hdr comments, tag w/Apache license & attribution & to-do to shift
 ; to %sf later.
 ;
 ; 2018-03-07 ven/toad %*1.8t04 %wdgraph: in setroot add header.
 ;
 ;@to-do
 ; %wd: convert entry points to ppi/api style
 ; r/all local calls w/calls through ^%wd
 ; break up into smaller routines & change branches from %wd
 ; renamespace under %sfg
 ;
 ;@contents
 ; [too big, break up]
 ;
 ;
 ;
 ;@section 1 code to implement ppis & apis
 ;
 ;
 ;
setroot(graph) ; root of working storage
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;function;
 ;@called-by
 ; $$setroot^%wd
 ; $$field2Var^%wffiler
 ; initFmap^%wffmap
 ; $$getFmapGlb^%wffmap
 ; getVals^%wfhform
 ; setVals^%wfhform
 ; wsPostForm^%wfhform
 ; queryPred^%yottaq
 ; importsami^%yottaq
 ; wsCASE^SAMICASE
 ; getItems^SAMICASE
 ; wsNuForm^SAMICASE
 ; makeCeform^SAMICASE
 ; INITFRMS^SAMIFRM
 ; loadData^SAMIFRM
 ; patlist^SAMIHOME
 ; wsNewCase^SAMIHOME
 ; nextNum^SAMIHOME
 ; prefill^SAMIHOME
 ; makeSbform^SAMIHOME
 ; makeSiform^SAMIHOME
 ; wsLookup^SAMISRCH
 ;@calls
 ; $$addgraph
 ;@input
 ; graph = name of graph
 ;@output = root for graph's working storage
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ;@stanza 2 calculate graph's root
 ;
 new %y set %y=$order(^%wd(17.040801,"B",graph,""))
 if %y="" set %y=$$addgraph(graph) ; if graph is not present, add it
 new root set root=$name(^%wd(17.040801,%y)) ; root for graph
 ;
 ;@stanza 3 return & termination
 ;
 quit root ; return root; end of $$setroot^%wd
 ;
 ;
 ;
rootOf(graph) ; return the root of graph named graph
 ;
 new %x1 set %x1=$order(^%wd(17.040801,"B",graph,""))
 if %x1="" quit -1
 ;
 quit $name(^%wd(17.040801,%x1,"graph")) ; end of rootOf^%wd
 ;
 ;
 ;
addgraph(graph) ; makes a place in the graph file for a new graph
 ;
 new fda set fda(17.040801,"?+1,",.01)=graph
 new %yerr
 do UPDATE^DIE("","fda","","%yerr")
 new %y set %y=$order(^%wd(17.040801,"B",graph,""))
 ;
 quit %y ; end of $$addgraph^%wd
 ;
 ;
 ;
purgegraph(graph) ; delete a graph
 ;
 new %y set %y=$order(^%wd(17.040801,"B",graph,""))
 if %y="" quit 0
 new fda set fda(17.040801,%y_",",.01)="@"
 new %yerr
 do UPDATE^DIE("","fda","","%yerr")
 if '$data(%yerr) quit 1
 zwrite %yerr
 ;
 quit 0 ; end of $$purgegraph^%wd
 ;
 ;
 ;
insert2graph(ary,graph,replace) ; insert a new entry to a graph
 ;
 ; ary is passed by name, graph is the name of the graph
 ; if replace=1 the graph will be killed first before merge
 ;
 new root set root=$$setroot(graph)
 new groot set groot=$name(@root@("graph"))
 new id set id=$order(@ary@(""))
 if replace=1 kill @groot@(id) 
 merge @groot=@ary
 ;
 quit  ; end of insert2graph^%wd
 ;
 ;
 ;
nameThis(altname) ; returns the id to be used for altname
 ;
 ; this will eventually use the context graph and the 
 ; local variable context to query the altname and obtain an id
 ;
 new result
 if $data(context) set result=$$queryContext(context,"id",altname) quit result
 if altname="background-dd-map" set result="sbform" quit result
 ;
 quit altname ; end of $$nameThis^%wd
 ;
 ;
 ;
getThis(rary,fn,nocache) ; find a file and read it into rary array
 ;
 new ary
 if '$get(nocache) do fromCache("ary",fn)
 if $data(ary) do  quit  ;
 . merge @rary=ary
 . quit
 do queryTag("ary",fn)
 if '$data(ary) do  quit  ;
 . write !,"error retrieving array ",fn
 . quit
 new file set file=$order(ary(1,"file",""))
 new dir set dir=$order(ary(1,"localdir",""))_"/"
 new tmp set tmp=$name(^TMP("yottawrk",$J))
 kill @tmp
 new tmp1 set tmp1=$name(@tmp@(1))
 new ok set ok=$$FTG^%ZISH(dir,file,tmp1,3)
 if 'ok do  quit  ;
 . write !,"error loading file ",dir_file
 . quit
 if '$get(nocache) do toCache(tmp,fn,"html-cache")
 merge @rary=@tmp
 kill @tmp
 ;
 quit  ; end of getThis^%wd
 ;
 ;
 ;
queryContext(context,pred,obj) ; look up project specific
 ;
 ; names and values from the context graph
 ; tbd
 ;
 quit obj ; end of $$queryContext^%wd
 ;
 ;
 ;
queryTag(rtn,tag) ; returns a json/mumps array of tagged items
 ;
 new graph set graph="seeGraph"
 kill @rtn
 new root set root=$$setroot(graph)
 new groot set groot=$na(@root@("graph"))
 if '$d(@groot@("pos","tag",tag)) quit
 new x1,y1 set (x1,y1)=""
 new cnt set cnt=0
 for  set x1=$order(@groot@("pos","tag",tag,x1)) quit:x1=""  do  ;
 . for  set y1=$order(@groot@("pos","tag",tag,x1,y1)) quit:y1=""  do  ;
 . . set cnt=cnt+1
 . . merge @rtn@(cnt)=@groot@(x1,y1)
 . . quit
 . quit
 ;
 quit  ; end of queryTag^%wd
 ;
 ;
 ;
fromCache(rary,name,graph) ; return a file from the cache
 ;
 if '$d(graph) set graph="html-cache"
 new zgn set zgn=$$setroot(graph)
 quit:'$data(@zgn@("graph","B",name))
 new zien set zien=$order(@zgn@("graph","B",name,""))
 quit:zien=""
 merge @rary=@zgn@("graph",zien)
 ;
 quit  ; end of fromCache^%wd
 ;
 ;
 ;
toCache(arry,name,graph) ; put a file in the cache
 ;
 if '$d(graph) set graph="html-cache"
 new zgn set zgn=$$setroot(graph)
 new zien
 if $data(@zgn@("graph","B",name)) do  ;
 . set zien=$order(@zgn@("graph","B",name,""))
 . kill @zgn@("graph",zien)
 . kill @zgn@("graph","B",name,zien)
 . quit
 if $get(zien)="" do  ;
 . set zien=$order(@zgn@("graph"," "),-1)+1
 . quit
 merge @zgn@("graph",zien)=@arry
 set @zgn@("graph","B",name,zien)=""
 ;
 quit  ; end of toCache^%wd
 ;
 ;
 ;
beautify(inary,outary) ; pretty print a line of json
 ;
 new zg,zi set (zg,zi)=""
 for  set zi=$order(@inary@(zi)) quit:zi=""  set zg=zg_@inary@(zi)
 do ary2file("zg",^%WHOME,"json.json")
 zsystem "python -m json.tool "_^%WHOME_"json.json > "_^%WHOME_"pretty-json.json"
 do file2ary(outary,^%WHOME,"pretty-json.json")
 ;
 quit  ; end of beautify^%wd
 ;
 ;
 ;
ary2file(ary,dir,file) ;
 ;
 new tmp set tmp=$name(^TMP("yottawrk",$J))
 kill @tmp
 if '$data(@ary@(1)) do  ; not really an array
 . if $get(@ary)="" quit ; not a string either
 . merge @tmp@(1)=@ary ; input was a string
 . quit
 else   merge @tmp=@ary
 new tmp1 set tmp1=$name(@tmp@(1))
 new ok set ok=$$GTF^%ZISH(tmp1,3,dir,file)
 if 'ok do  quit  ;
 . write !,"error saving file ",dir_file
 . quit
 ;
 quit  ; end of ary2file^%wd
 ;
 ;
 ;
file2ary(ary,dir,file) ;
 ;
 new tmp set tmp=$name(^TMP("yottawrk",$J))
 kill @tmp
 new tmp1 set tmp1=$name(@tmp@(1))
 new ok set ok=$$FTG^%ZISH(dir,file,tmp1,3)
 if 'ok do  quit  ;
 . write !,"error loading file ",dir_file
 . quit
 merge @ary=@tmp
 kill @tmp
 ;
 quit  ; end of file2ary^%wd
 ;
 ;
 ;
eor ; end of routine %wdgraph

%wdgrtrans
%wdgrtrans        ;ven/gpl - mash graph utilities ; 9/24/17 4:33pm
 ;;1.0;norelease;;feb 27, 2017;build 2
 ;
 ;
 q
 ;
 ; All the public entry points for these routines are found in %wd
 ;
wsPutGraph(ARG,BODY,RESULT) ; POST web service which takes in and stores a graph
 n zgraph s zgraph=$g(ARG("graph"))
 i zgraph="" s zgraph="misc-graph"
 ;
 ; determine which graph
 ;
 n root s root=$$setroot^%wd(zgraph)
 ; 
 ; parse the json
 ;
 n tbdy
 d DECODE^VPRJSON("BODY","tbdy")
 ;
 ; find the ids of the graph
 ;
 n id1,id2
 s id1=$g(ARG("id"))
 s id2=$g(ARG("id2"))
 ;
 ; find where in the graph to put incoming
 ;
 n ien,rien s (ien,rien)=""
 ;
 i id1="" s ien=$o(@root@(" "),-1)+1
 i id1'="" d  ;
 . s ien=$o(@root@("B",id1,""))
 . i ien="" d  q  ;
 . . s ien=$o(@root@(" "),-1)+1
 . i id2'="" d  ;
 . . s rien=$o(@root@(ien,""),-1)+1
 ;
 ; merge to the graph
 ;
 set HTTPRSP("mime")="application/json"
 n rslt,prefix
 s prefix=$o(tbdy(""))
 i id1="" d  q  ; no index provided, merge to root
 . ;m @root=tbdy(prefix)
 . m @root=tbdy
 . s rslt("result","status")="ok"
 . s rslt("result","graph")=zgraph
 . s rslt("result","ien")=""
 . d ENCODE^VPRJSON("rslt","RESULT")
 ;
 i id2="" d  q  ; index found but no secondary index
 . ;m @root@(ien)=tbdy(prefix)
 . m @root@(ien)=tbdy
 . s @root@("B",id1,ien)=""
 . s rslt("result","status")="ok"
 . s rslt("result","graph")=zgraph
 . s rslt("result","ien")=ien
 . d ENCODE^VPRJSON("rslt","RESULT")
 ;
 d  q  ; index and secondary index found
 . ;m @root@(ien,rien)=tbdy(prefix)
 . m @root@(ien,rien)=tbdy
 . s @root@("B",id1,ien)=""
 . s @root@(ien,"B",id2,rien)=""
 . s rslt("result","status")="ok"
 . s rslt("result","graph")=zgraph
 . s rslt("result","ien")=ien
  . s rslt("result","rien")=rien
 . d ENCODE^VPRJSON("rslt","RESULT")
 ;
 q
 ;
wsGetGraph(rtn,filter) ; web service to retieve a graph
 n zgraph s zgraph=$g(ARG("graph"))
 i zgraph="" s zgraph="misc-graph"
 ;
 ; determine which graph
 ;
 n root s root=$$setroot^%wd(zgraph)
 n grshape
 d grokGraph(.grshape,root)
 ;
 ; find the ids of the graph
 ;
 n id1,id2
 s id1=$g(ARG("id"))
 s id2=$g(ARG("id2"))
 ;
 ; locate the graph
 ;
 n ien,rien s (ien,rien)=""
 ;
 i id1'="" d  ;
 . s ien=$o(@root@("B",id1,""))
 . q:ien=""
 . ;s rien=$o(
 q
 ;
grokGraph(shape,groot,recalc) ; detect the shape of the graph
 ; if recalc is 1, the shape will be recalculated and stored in the graph
 i $d(@groot@("shape")) d  q  ; graph has a shape section
 . m shape=@groot@("shape")
 ;
 q
 ;
remoteGraph(url,graph) ; download a graph from url and create graph
 ;
 n %,json
 s %=$$%^%WC(.json,"GET",url)
 ;
 i '$d(graph) s graph="remoteGraph"
 n root s root=$$setroot^%wd(graph)
 ;
 d DECODE^VPRJSON("json",root)
 q
 ;
getOS5 ; get the latest OS5 graph
 n url
 s url="http://syn.vistaplex.org/os5?format=json"
 d remoteGraph(url,"OS5codes")
 q
 ;

%wf
%wf ;ven/gpl-write form: development log ;2018-03-01T21:47Z
 ;;1.8;Mash;
 ;
 ; %wful is the Write Form Library's ppi & api routine. It supports getting
 ; & posting html forms, specifically the interface between an html form &
 ; a mumps graphstore.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development: see routine %wful
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-01T21:47Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Write Form - %wf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@to-do
 ; reroute %wfhform calls to other routines as it is broken up
 ;
 ;@contents
 ; API = application program interface, supported reference for SAMI
 ; ppi = private program interface for Mash
 ; ws = web service for Mash
 ;
 ;
 ;
 ;@section 1 wsGetForm^%wf web service & ppis
 ;
 ;
 ;
 ;@ws GET form/*, get html form
wsGetForm(rtn,filter,post) goto wsGetForm^%wfhform
 ;
 ;
 ;
 ;@section 2 wsGetForm^%wf support subroutines
 ;
 ;
 ;
 ;@ppi $$formLabel^%wf, label to use for form's post url
formLabel(form) goto formLabel^%wfhform
 ;
 ;
 ;@API $$getTemplate^%wf, get name of form's template
getTemplate(form) goto getTemplate^%wfhform
 ;
 ;
 ;
 ;@section 3 wsGetForm^%wf error handling
 ;
 ;
 ;
 ;@ppi redactErr^%wf, clear errors from form
redactErr(html,err,indx) goto redactErr^%wfhform
 ;
 ;
 ;@ppi redactErr2^%wf, redact field's error symbol
redactErr2(html,indx) goto redactErr2^%wfhform
 ;
 ;
 ;@test redactErr2^%wf [move to %wfut]
testRedactErr2 goto testRedactErr2^%wfhform
 ;
 ;
 ;@ppi putErrMsg2^%wf, insert error msgs
putErrMsg2(html,line,msg,err) goto putErrMsg2^%wfhform
 ;
 ;
 ;@ppi insError^%wf, insert error msg into html line
insError(line,msg) goto insError^%wfhform
 ;
 ;
 ;@ppi debugFld^%wf, insert field debugging info
debugFld(line,form,name) goto debugFld^%wfhform
 ;
 ;
 ;
 ;@section 4 wsGetForm^%wf text manipulation
 ;
 ;
 ;
 ;@ppi deleteBetween^%wf, find & delete text between 2 substrings
deleteBetween(line,before,after,replace) goto deleteBetween^%wfhfind
 ;
 ;
 ;
 ;@section 5 wsGetForm^%wf input value manipulation
 ;
 ;
 ;
 ;@ppi unvalue^%wf, clear input value in html line
unvalue(line) goto unvalue^%wfhform
 ;
 ;
 ;@ppi value^%wf, set input value in html line
value(line,val) goto value^%wfhform
 ;
 ;
 ;@ppi getVals^%wf, get field values from graph
getVals(vrtn,zid,zsid) goto getVals^%wfhform
 ;
 ;
 ;@ppi setVals^%wf, set field values into graph
setVals(vary,zid,zsid) goto setVals^%wfhform
 ;
 ;
 ;
 ;@section 6 input tag processing
 ;
 ;
 ;
 ;@ppi $$type^%wf, input type
type(line) goto type^%wfhinput
 ;
 ;
 ;@ppi uncheck^%wf, uncheck radio button or checkbox
uncheck(line) goto uncheck^%wfhinput
 ;
 ;
 ;@ppi check^%wf, check radio button or checkbox
check(line,type) goto check^%wfhinput
 ;
 ;
 ;
 ;@section 7 wsGetForm^%wf field validation
 ;
 ;
 ;
 ;@ppi $$validate^%wf, validate value
validate(value,spec,map,msg) goto validate^%wfhform
 ;
 ;
 ;@ppi $$dateValid^%wf, validate date
dateValid(value,spec,map,msg) goto dateValid^%wfhform
 ;
 ;
 ;@ppi $$textValid^%wf, validate free-text field
textValid(value,spec,map) goto textValid^%wfhform
 ;
 ;
 ;@ppi $$numValid^%wf, validate numeric field
numValid(value,spec,map) goto numValid^%wfhform
 ;
 ;
 ;@ppi $$dateFormat^%wf, date in elcap format
dateFormat(val,form,name) goto dateFormat^%wfhform
 ;
 ;
 ;
 ;@section 8 wsPostForm^%wf web service & parseBody ppi
 ;
 ;
 ;
 ;@ws POST form/*, submit HTML form
wsPostForm(ARGS,BODY,RESULT) goto wsPostForm^%wfhform
 ;
 ;
 ;@ppi parseBody^%wf, get field values from form
parseBody(rtn,body) goto parseBody^%wfhform
 ;
 ;
 ;
 ;@section 9 commented-out procedures
 ;
 ;
 ;
 ;@ppi replaceSrc^%wf, chg resources in src & href
replaceSrc(line) goto replaceSrc^%wfhform
 ;
 ;
 ;@ppi replaceHref^%wf, chg resources in href
replaceHref(line) goto replaceHref^%wfhform
 ;
 ;
 ;
 ;@section 10 %wffmap form mapping ppi
 ;
 ;
 ;
 ;@ppi importfmap^%wf, import map from csv
importfmap(csvname,form) goto importfmap^%wffmap
 ;
 ;
 ;
eor ; end of routine %wf

%wffiler
%wffiler ;ven/gpl-web form: file graph data in Fileman ;2018-03-06T20:08Z
 ;;1.8;Mash;
 ;
 ; %wffiler implements the Write Form Library's ppis for filing graph data
 ; from html forms into their Fileman files.
 ; See %wfutf for the unit tests for these methods.
 ; See %wfut for the whole unit-test library.
 ; See %wfud for documentation introducing the Web Form Lbrary,
 ; including an intro to the Filer Library.
 ; See %wful for the module's primary-development log.
 ; See %wf for the module's ppis & apis.
 ; %wffiler contains no public entry points.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development: see routine %wful
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ;   gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ;   http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ;   https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-06T20:08Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Web Form - %wf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@to-do
 ; finish applying mash style to subroutines
 ; %wf: add ppi & convert entry points to ppi/api style
 ; r/all local calls w/calls through ^%wf
 ; change branches from %wf
 ;
 ;@contents
 ; fileForm: file graph data from form into fileman database
 ; exception: handle exceptions
 ; testFiler: test driver for the filer
 ; $$var2field = fileman file & field # for var in form
 ; $$field2var = var in form for fileman field in file
 ; retrieve: retrieve all form variables from fileman file for form & studyid
 ;
 ;
 ;
 ;@section 1 code to implement ppis
 ;
 ;
 ;
fileForm(ary,form,sid,report) ; ary is the input data, which has been validated
 ;
 ; ary is passed by name
 ; form is the form identifier which must be found in the form mapping file
 ; id should be the key of the targeted fileman file, for example studyid for
 ; the SAMI background file.
 ; report is optional and will contain the processing results. it is passed by
 ;  name
 ;
 ;  We must make a choice whether to process the file looking for fields for
 ;  which we have data or to process the data first, then looking for the 
 ;  fileman fields to update. We have chosen the latter so that forms can be
 ;  made which cover only a portion of the fields in a file, and will process
 ;  more quickly than with the former approach.  gpl
 ;
 if $get(report)="" set report="report"
 new fda,fdaentry
 set fda(311.102,"?+1,",.01)=sid
 new %wi set %wi=""
 ;
 ; zwrite @ary
 ;
 for  set %wi=$order(@ary@(%wi)) quit:%wi=""  do  ;
 . new fln,fld,combo
 . set combo=$$var2field(form,%wi)
 . ; write !,combo
 . set fln=$piece(combo,"^",1)
 . quit:fln'["SAMI BACKGROUND"
 . set fld=$piece(combo,"^",2)
 . quit:fld=""
 . quit:fld=.01
 . if fld["*" do exception("fdaentry",form,fld,report) quit  ;
 . if fld["+" do exception("fdaentry",form,fld,report) quit  ;
 . if fld=12.4 quit  ; field causes errors... need to fix it
 . if $$getFieldSpec^%wffmap(form,%wi)["D" do  ;
 . . new X,Y
 . . set X=$get(@ary@(%wi))
 . . do ^%DT
 . . set @ary@(%wi)=Y
 . . quit
 . set fda(311.102,"?+1,",fld)=$get(@ary@(%wi))
 . set @report@("processed",%wi)=fld_"^"_"311.102"
 . quit
 ;
 ; zwrite fda
 ;
 do updie^%wffmap(.fda)
 ;
 set %wi=""
 for  set %wi=$order(@ary@(%wi)) quit:%wi=""  do  ;
 . if $data(@report@("processed",%wi)) quit  ;
 . set @report@("notprocessed",%wi)=$$var2field(form,%wi)
 . quit
 ;
 quit  ; end of fileForm
 ;
 ;
 ;
exception(rtn,form,field,report) ; handle exceptions
 ;
 set @report@("notprocessed",field)=$$var2field(form,field)
 ;
 quit  ; end of exception
 ;
 ;
 ;
testFiler ; test driver for the filer
 ;
 new vals
 do getVals^%wf("vals","sbform","XXXX02")
 do fileForm("vals","sbform","XXXX02")
 ;
 quit  ; end of testFiler
 ;
 ;
 ;
var2field(form,var) ; extrinsic returns the fileman file and field number for the var in form form
 ;
 ; format file^field
 ;
 new map
 do getFieldMap^%wffmap("map",form,var)
 new fld,file,rtn
 set fld=$get(map("FILEMAN_FIELD"))
 set file=$get(map("FILEMAN_FILE"))
 set rtn=file_"^"_fld
 ;
 quit rtn ; end of $$var2Field
 ;
 ;
 ;
field2var(form,file,field) ; extrinsic returns the var in form form for the fileman field in file file
 ;
 new root set root=$$setroot^%wd("form-map")
 new groot set groot=$name(@root@("graph",form,"VARIABLE","FIELD"))
 new return set return=""
 if $data(@groot@(field)) set return=$order(@groot@(field,""))
 ;
 quit return ; end of $$field2Var
 ;
 ;
 ;
retrieve(ary,form,file,sid) ; retrieve all form variables from the fileman file for form and studyid (sid)
 ;
 ; ary is passed by name
 ;
 new tary
 new ien set ien=$order(^SAMI(file,"B",sid,""))
 if ien="" quit
 do GETS^DIQ(file,ien_",","**","IE","tary")
 new tary2 set tary2=$name(tary(file,ien_","))
 new %wi set %wi=""
 for  set %wi=$order(@tary2@(%wi)) quit:%wi=""  do  ;
 . new var
 . set var=$$field2var(form,file,%wi)
 . if var="" quit  ;
 . ; write !,"var= ",var," field= ",%wi
 . new usevar
 . if $$getFieldSpec^%wffmap(form,var)["D" set usevar=$get(@tary2@(%wi,"E"))
 . else  set usevar=$get(@tary2@(%wi,"I"))
 . if usevar'="" set @ary@(var)=usevar
 . quit
 ;
 quit  ; end of retrieve
 ;
 ;
 ;
eor ; end of routine %wffiler

%wffmap
%wffmap ;ven/gpl-web form: mapping ;2018-03-06T20:22Z
 ;;1.8;Mash;
 ;
 ; %wffmap implements the Web Form Library's mapping methods.
 ; See %wfutfm for the unit tests for these methods.
 ; See %wfut for the whole unit-test library.
 ; See %wfud for documentation introducing the Web Form Lbrary,
 ; including an intro to the Mapping Library.
 ; See %wful for the module's primary-development log.
 ; See %wf for the module's ppis & apis.
 ; %wffmap contains no public entry points.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development: see routine %wful
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-06T20:22Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Web Form - %wf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@to-do: [tbd]
 ;
 ;@contents
 ; $$formFn = form file number
 ; $$formVarFn = variable subfile number
 ; $$formGlb = form global
 ; importfmap: import form mapping definitions from csv
 ; $$formien = form record number
 ; updie: update fileman file
 ; initFmap: initializes form-map graph for form
 ; $$getFmapGlb: get location of form's fieldmap
 ; $$getFieldSpec: format specification
 ; getFieldMap: file map
 ;
 ;
 ;
 ;@section 1 utilities
 ;
 ;
 ;
formFn() ; form file number
 ;
 quit 311.11 ; return file #; end of $$FormFn
 ;
 ;
 ;
formVarFn() ; variable subfile number
 ;
 quit 311.11001 ; return subfile #; end of $$formVarFn
 ;
 ;
 ;
formGlb() ; form global
 ;
 quit $name(^SAMI(311.11)) ; return global name; end of $$formGlb
 ;
 ;
 ;
importfmap(csvname,form) ; import form mapping definitions from csv
 ;
 ; csvname is the name of the csv file
 ; form is the name of the form
 ;
 ; sample graph from the csv form mapping file
 ;^%wd(17.040801,7,"graph","sbform",365,"dataType")="RDATE"
 ;^%wd(17.040801,7,"graph","sbform",365,"fieldName")="sbdoc"
 ;^%wd(17.040801,7,"graph","sbform",365,"fieldTitle")="Date informed consent signed"
 ;^%wd(17.040801,7,"graph","sbform",365,"mClass#")=311.102
 ;^%wd(17.040801,7,"graph","sbform",365,"mDlimCheck")=""
 ;^%wd(17.040801,7,"graph","sbform",365,"mProp#")=34.1
 ;^%wd(17.040801,7,"graph","sbform",365,"mPropLoc")="10;10"
 ;^%wd(17.040801,7,"graph","sbform",365,"mPropName")="CONSENT DATE"
 ;^%wd(17.040801,7,"graph","sbform",365,"mPropType")="D"
 ;^%wd(17.040801,7,"graph","sbform",365,"sub#")=""
 ;
 do csv2graph^%wd(csvname,form)
 ;
 new groot set groot=$$rootOf^%wd("csvGraph")
 if '$data(@groot@(form)) do  quit  ;
 . write !,"csvGraph not found for form ",form
 . quit
 new fmap
 merge fmap=@groot@(form)
 ; zwrite fmap
 new formien set formien=$$formien(form) ; laygo form record number
 write:$get(%wform) !,"form: ",form," has ien: ",formien
 ;
 new %w1 set %w1=0
 for  set %w1=$order(fmap(%w1)) quit:+%w1=0  do  ; process each field
 . quit:$get(fmap(%w1,"fieldName"))=""  ; must have a field name
 . write !,"processing field ",fmap(%w1,"fieldName")
 . kill fda
 . set fda($$formVarFn(),"?+1,"_formien_",",.01)=fmap(%w1,"fieldName")
 . set fda($$formVarFn(),"?+1,"_formien_",",.02)=$get(fmap(%w1,"fieldTitle"))
 . set fda($$formVarFn(),"?+1,"_formien_",",.5)=$get(fmap(%w1,"mClass#"))
 . set fda($$formVarFn(),"?+1,"_formien_",",1)=$get(fmap(%w1,"mProp#"))
 . set fda($$formVarFn(),"?+1,"_formien_",",2)=$get(fmap(%w1,"mPropType"))
 . zwrite fda
 . do updie(.fda)
 . ;
 . do initFmap(form)
 . ;
 . quit
 ;
 quit  ; end of importfmap
 ;
 ;
 ;
formien(form) ; extrinsic returns form record number
 ;
 ; creates one if not found
 ;
 new %ien
 set %ien=$order(@$$formGlb()@("B",form,""))
 if %ien'="" quit %ien
 new fda
 set fda($$formFn,"?+1,",.01)=form
 do updie(.fda)
 set %ien=$order(@$$formGlb()@("B",form,""))
 ;
 quit %ien ; return IEN; end of $$formien
 ;
 ;
 ;
updie(fda) ; update fileman file
 ;
 new %yerr
 do UPDATE^DIE("","fda","","%yerr")
 if $data(%yerr) do  quit  ;
 . write !,"fileman error"
 . zwr %yerr
 . zwr fda
 . kill fda
 . quit
 kill fda
 ;
 quit  ; end of updie
 ;
 ;
 ;
initFmap(form) ; initializes form-map graph for form
 ;
 new fglb set fglb=$$formGlb()
 new formien set formien=$order(@fglb@("B",form,""))
 if formien="" do  quit  ;
 . write !,"Error initializing form-map for form: ",form
 . quit
 new mapglb set mapglb=$$setroot^%wd("form-map")
 new fmapglb set fmapglb=$name(@mapglb@("graph",form))
 if $data(@fmapglb) kill @fmapglb
 ; break
 do fmx^%sfv2g(fmapglb,$$formFn,formien)
 ;
 ; sample fieldmap graph entry
 ;
 ;^%wd(17.040801,7,"graph","sbform","VARIABLE",148,"DATA_TYPE")="D"
 ;^%wd(17.040801,7,"graph","sbform","VARIABLE",148,"FILEMAN_FIELD")=34.1
 ;^%wd(17.040801,7,"graph","sbform","VARIABLE",148,"FILEMAN_FILE")="SAMI BACKGROUND"
 ;^%wd(17.040801,7,"graph","sbform","VARIABLE",148,"TITLE")="Date informed consent signed"
 ;^%wd(17.040801,7,"graph","sbform","VARIABLE",148,"VARIABLE")="sbdoc"
 ;
 ; index the graph
 new %wi set %wi=0
 for  set %wi=$order(@fmapglb@("VARIABLE",%wi)) quit:+%wi=0  do  ;
 . new %wvar set %wvar=$get(@fmapglb@("VARIABLE",%wi,"VARIABLE"))
 . quit:%wvar=""
 . set @fmapglb@("VARIABLE","B",%wvar,%wi)=""
 . new %wfield set %wfield=$get(@fmapglb@("VARIABLE",%wi,"FILEMAN_FIELD"))
 . quit:%wfield=""
 . set @fmapglb@("VARIABLE","FIELD",%wfield,%wvar,%wi)=""
 . quit
 ;
 quit  ; end of initFmap
 ;
 ;
 ;
getFmapGlb(form) ; get location of form's fieldmap
 ;
 new mapglb set mapglb=$$setroot^%wd("form-map")
 new fmapglb set fmapglb=$name(@mapglb@("graph",form,"VARIABLE"))
 ;
 quit fmapglb ; return location; end of $$getFmapGlb
 ;
 ;
 ;
getFieldSpec(form,field,fmapglb) ; extrinsic returns format specification
 ;
 ; for field in form. fmapglb is optional but will speed up the lookup
 ;
 if $get(fmapglb)="" set fmapglb=$$getFmapGlb(form)
 ;
 new %wien set %wien=$order(@fmapglb@("B",field,""))
 ;
 if %wien="" do  quit  ;
 . ; write !,"Error field map not found"
 . ; do ^ZTER
 . quit
 ;
 quit $get(@fmapglb@(%wien,"DATA_TYPE")) ; return spec; end of $$getFieldSpec
 ;
 ;
 ;
getFieldMap(array,form,field,fmapglb) ; array is passed by name and returns the file map
 ;
 ; for the field in the form
 ; fmapglb is passed by name and is optional, but will speed up processing
 ;
 if $get(fmapglb)="" set fmapglb=$$getFmapGlb(form)
 ;
 if $g(field)="" quit  ;
 new %wien s %wien=$o(@fmapglb@("B",field,""))
 ;
 if %wien="" do  quit  ;
 . ; write !,"Error field map not found"
 . ; do ^ZTER
 . quit
 ;
 merge @array=@fmapglb@(%wien)
 ;
 quit  ; end of getFieldMap
 ;
 ;
 ;
eor ; end of routine %wffmap

%wfhfind
%wfhfind ;ven/gpl-web form: html find/replace ;2018-03-07T21:06Z
 ;;1.8;Mash;
 ;
 ; %wfhfind implements the Web Form Library's html find & replace
 ; methods, for finding & then removing or replacing substrings in a
 ; line of html text. It will be retired soon in favor of the Mash
 ; String Find Library toolset.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development: see routine %wful
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-07T21:06Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Web Form - %wf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@to-do: [tbd]
 ;
 ;@contents
 ; deleteBetween: code for ppi deleteBetween^%wf
 ;  find & delete text between 2 substrings
 ;
 ;
 ;@section 1 combination methods find+delete & find+replace
 ;
 ;
 ;
 ;@ppi-code deleteBetween^%wf
deleteBetween ; find & delete text between 2 substrings
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; deleteBetween^%wf(.line,begin,end,replace)
 ;@branches-from
 ; deleteBetween^%wf
 ;@ppi-called-by
 ; redactErr2^%wf
 ;@called-by: none
 ;@calls: none
 ;@throughput
 ;.line = line of html to change
 ;.line("low") = lowercase version of line for checks & searches
 ;@input
 ; before = substring preceding text to delete
 ; after = substring following text to delete
 ; replace = [optional] new text to replace deleted text
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; find before & after, delete text between them, optionally replace it,
 ; in line of html. Lowercase version of line is used to find matches, &
 ; it too is changed to keep it in synch with line.
 ;
 ;@stanza 2 find & delete/replace text
 ;
 quit:$get(line)=""  ; can't delete or replace in an empty line
 new linelow set linelow=$$lowerCase^%ts(line)
 ;
 new to set to=$find(linelow,after)-$length(after) ; 1st char after
 new from set from=$find(linelow,before)-1 ; last char before
 new last set last=$length(line) ; last char in line
 ;
 set replace=$get(replace) ; get optional replacement value
 new haverep set haverep=replace]"" ; do we have one?
 ;
 set line=$extract(line,1,from)_replace_$extract(line,to,last)
 set line=$extract(linelow,1,from)_replace_$extract(linelow,to,last)
 set line("extract","low")=linelow
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of ppi deleteBetween^%wf
 ;
 ;
 ;
eor ; end of routine %wfhfind

%wfhform
%wfhform ;ven/gpl-web form: html form get & post ;2018-03-18T17:05Z
 ;;1.8;Mash;
 ;
 ; %wfhform implements the Web Form Library's html form get & post web
 ; services. It will be broken up into many routines & further annotated.
 ; See %wfut* for the unit tests for these methods.
 ; See %wfut for the whole unit-test library.
 ; See %wfud for documentation introducing the Web Form Lbrary,
 ; including an intro to the HTML Form Library.
 ; See %wful for the module's primary-development log.
 ; See %wf for the module's ppis & apis.
 ; %wfhform contains no public entry points.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development: see routine %wful
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-18T17:05Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Web Form - %wf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@to-do
 ; break up into smaller routines & change branches from %wf
 ;
 ;@contents
 ; [too big, break up]
 ;
 ;
 ;
 ;@section 1 wsGetForm^%wf web service & ppis
 ;
 ;
 ;
wsGetForm ; code for wsGetForm^%wf, get html form
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;web service;procedure;
 ;@signature
 ; do wsGetForm^%wf(.rtn,.filter,post)
 ;@branches-from
 ; wsGetForm^%wf
 ;@ws-called-by
 ; web service %wf-wsGetForm
 ; wsNuFormPost^SAMICASE
 ;@called-by: none
 ;@calls
 ; getVals^%wf
 ; retrieve^%wffiler
 ; $$getTemplate^%wf
 ; getThis^%wd
 ; $$lowcase^%ts
 ; SAMISUBS^SAMIFRM
 ; SAMISUB2^SAMIFRM
 ; redactErr^%wf
 ; redactErr2^%wf
 ; $$formLabel^%wf
 ; $$replaceSrc^%wf [commented out]
 ; $$replaceHref^%wf [commented out]
 ; uncheck^%wf
 ; check^%wf
 ; debugFld^%wf
 ; unvalue^%wf
 ; $$URLENC^VPRJRUT
 ; findReplace^%ts
 ; dateFormat^%wf
 ; value^%wf
 ; $$getFieldSpec^%wffmap
 ; $$validate^%wf
 ; putErrMsg2^%wf
 ; insError^%wf
 ;@input
 ;.filter = 
 ; filter("form")=form id
 ; filter("studyId")=study id
 ; post = 1 if ...
 ;@output
 ;.rtn = name of root containing returned html (the prepared form)
 ;@throughput: none
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; return the html for the form id, passed in filter
 ;
 ;@stanza 2 load saved field values from graph
 ;
 new form set form=$get(filter("form")) ; id form
 if form="" set form="sbform"
 ;
 new sid set sid=$get(filter("studyid")) ; id patient by study id
 if sid="" set sid=$get(filter("fvalue"))
 if sid="" set sid="XXXX01"
 ;
 new key set key=$g(filter("key")) ; graph key for the saved form
 i key="" set key=form
 i key["vapals:" s key=$p(key,"vapals:",2)
 i form["vapals:" s form=$p(form,"-",1)
 ;
 new vals
 ;do getVals^%wf("vals",form,sid) ; load saved field values
 do getVals^%wf("vals",key,sid) ; load saved field values
 ;
 ;@stanza 3 load html template
 ;
 ; get field values saved in fileman file, preserve graph values
 new fn
 ;if form["sbform" do  ; gpl - forget about the fileman file for this version - use the graph
 ;. ;set fn="background-form.html"
 ;. new tmpvals
 ;. if $g(post)=1 quit  ;
 ;. do retrieve^%wffiler("tmpvals","sbform",311.102,sid)
 ;. ;if $data(tmpvals) kill vals merge vals=tmpvals
 ;. ; maintain graph vars not saved in fileman:
 ;. if $data(tmpvals) merge vals=tmpvals
 ;. quit
 ;
 ; clear return html array
 set rtn=$name(^TMP("yottaForm",$job))
 kill @rtn
 ;
 ; lookup template name
 if $get(fn)="" set fn=$$getTemplate^%wf(form)
 if fn="" quit  ;
 ;
 ; load template html
 new zhtml,errctrl ; holders of html template & error control array
 do getThis^%wd("zhtml",fn)
 if '$data(zhtml) quit  ;
 ;
 ;@stanza 4 traverse html lines in template, for each ...
 ;
 new name,value,selectnm
 set selectnm="" ; name of select variable, which spans options
 new %j set %j=""
 for  set %j=$order(zhtml(%j)) quit:%j=""  do  ;
 . new tln set tln=zhtml(%j)
 . set tln("low")=$$lowcase^%ts(tln) ; lowercase for checks
 . new customscan s customscan=""
 . ;
 . ;@stanza 5 special handling of SAMI forms
 . ;
 . ; do  ; i can't get this to work... need help with x indirection
 . ; . new fglb set fglb=$name(^SAMI(311.11))
 . ; . new fn set fn=311.11
 . ; . new fien set fien=$order(@fglb@("B",form,""))
 . ; . quit:fien="" ""
 . ; . set customscan=$$GET1^DIQ(fn,fien_",",3) ; custom scan routine
 . ; . if $length(customscan)>0 do
 . ; . . set customscan=$translate(customscan,"@","^") ; fix for ^
 . ; . . quit
 . ; . quit:$length(customscan)>0
 . ; . if $extract(form,3,6)["form" do
 . ; . . set customscan="do SAMISUBS^SAMIFRM(.tln,form,sid,.filter)"
 . ; . . quit
 . ; if customscan'="" xecute @customscan
 . ;
 . new newstyle set newstyle=0
 . if form["vapals:" set newstyle=1
 . ;if form["vapals:" do SAMISUB2^SAMIFRM2(.tln,form,sid,.filter,.%j,.zhtml)
 . if newstyle=1 do SAMISUB2^SAMIFRM2(.tln,key,sid,.filter,.%j,.zhtml)
 . ;else  do SAMISUBS^SAMIFRM(.tln,form,sid,.filter)
 . if newstyle=0 do SAMISUBS^SAMIFRM(.tln,form,sid,.filter)
 . set zhtml(%j)=tln
 . ;
 . if tln["submit" quit  ;
 . if tln["hidden" quit  ;
 . ;
 . ; hack for elcap forms - temporary - gpl
 . ; if tln["jquery-1.html" set zhtml(%j)="" quit  ; 
 . ; if tln["mgtsys.html" set zhtml(%j)="" quit  ; 
 . ; if tln["mgtsys2.html" set zhtml(%j)="" quit  ; 
 . ; if tln["index.html" set zhtml(%j)="" quit  ; 
 . ; if tln["identity.html" set zhtml(%j)="" quit  ; 
 . ; if tln["jquery-1.html" set zhtml(%j)="" quit  ; 
 . ; end hack
 . ;
 . ;@stanza 6 process errors
 . ;
 . if tln["class=""errormsg"">" do  quit  ; error block at top of form
 . . do redactErr^%wf("zhtml","errctrl",.%j) ; remove error section
 . . quit
 . ;
 . if tln["fielderr" do  ; error messages w/fields
 . . do redactErr2^%wf("zhtml",.%j)
 . . quit
 . ;
 . ;@stanza 7 process field name or value
 . ;
 . set (name,value)=""
 . ;
 . if zhtml(%j)["name=" do  ;
 . . set name=$piece($piece(zhtml(%j),"name=""",2),"""")
 . . ; write !,"found name ",name
 . . quit
 . ;
 . if zhtml(%j)["value=" do  ;
 . . set value=$piece($piece(zhtml(%j),"value=""",2),"""")
 . . quit
 . ;
 . ;@stanza 8 process study id [asterisks in Ken's 1st draft]
 . ;
 . if zhtml(%j)["*sbsid*" do  ;
 . . set zhtml(%j)=$piece(tln,"*sbsid*")_sid_$piece(tln,"*sbsid*",2)
 . . quit
 . ;
 . ;@stanza 9 process action
 . ;
 . if zhtml(%j)["action=" do  ;
 . . ; set zhtml(%j)="<form action=""http://vendev.vistaplex.org:9080/postform?form="_form_"&studyId="_sid_""" method=""POST"" id=""backgroundForm"">"
 . . new sublbl set sublbl=$$formLabel^%wf(form)
 . . new dbg set dbg=$get(filter("debug"))
 . . if dbg'="" set dbg="&debug="_dbg
 . . ;
 . . ; if form'="sbform" do  quit  ;
 . . ; . if zhtml(%j)["datae" do
 . . ; . . set zhtml(%j)="<form action=""form?form="_form_"&studyId="_sid_dbg_""" method=""POST"" name="""_sublbl_""">"
 . . ; . . quit
 . . ;
 . . if zhtml(%j)["http://foia201606.vistaplex.org:9080/sami/intake" do  quit  ; 
 . . . set zhtml(%j)="<form action=""form?form="_form_"&studyId="_sid_dbg_""" method=""POST"" name="""_sublbl_""">"
 . . . quit
 . . quit
 . ;
 . ;@stanza 10 fix css & js href values [disabled]
 . ;
 . ;if form'="sbform" do  ;
 . ;. if $$replaceSrc^%wf(.tln) set zhtml(%j)=tln
 . ;. if $$replaceHref^%wf(.tln) set zhtml(%j)=tlnvalues
 . ;. quit
 . ;
 . ;@stanza 11 skip table declarations
 . ;
 . if tln["table" quit  ;
 . ;
 . ;@stanza 12 process input tags
 . ;
 . if zhtml(%j)["<input" do  ;
 . . ;b
 . . ;
 . . ; handle long lines
 . . if $length(zhtml(%j),"<input")>2 do  ; got to split the lines
 . . . new zgt,zgn set zgt=zhtml(%j)
 . . . set zgn=$find(zgt,"<input",$find(zgt,"<input"))
 . . . set zhtml(%j+.001)=$extract(zgt,zgn-6,$length(zgt))
 . . . set zhtml(%j)=$extract(zgt,1,zgn-7)
 . . . set tln=zhtml(%j)
 . . . quit
 . . ;
 . . ; save field value
 . . quit:$get(name)=""
 . . new val set val=""
 . . if $data(vals(name)) set val=vals(name)
 . . ;
 . . ; process radio buttons & checkboxes
 . . new type set type=$$type^%wf(tln("low")) ; get input type
 . . if type="radio"!(type="checkbox") do  quit  ; treat the same
 . . . do uncheck^%wf(.tln)
 . . . if $get(val)=$get(value) do check^%wf(.tln,type)
 . . . if $get(filter("debug"))=2 do debugFld^%wf(.tln,form,name)
 . . . set zhtml(%j)=tln ; r/template line w/processed line
 . . . quit
 . . ;
 . . ; clear value, normalize quotes & dates, restore value
 . . do unvalue^%wf(.tln) ; clear input-field value
 . . ; set val=$$URLENC^VPRJRUT(val)
 . . ; replace with findReplaceAll call?:
 . . for  do findReplace^%ts(.val,"""","&quot;") quit:val'[""""  ; quotes
 . . do dateFormat^%wf(.val,form,name) ; ensure elcap date format
 . . do value^%wf(.tln,val) ; restore normalized value
 . . ;
 . . ; input-field validation
 . . new spec,errmsg set spec=$$getFieldSpec^%wffmap(form,name)
 . . set errmsg="Input invalid"
 . . if val]"" do  ;
 . . . if $$validate^%wf(val,spec,,.errmsg)<1 do  ;
 . . . . set errflag=1
 . . . . new errmethod set errmethod=2
 . . . . ; set errmethod=$get(filter("errormessagestyle"))
 . . . . ; if errmethod="" set errmethod=$get(errctrl("errorMessageStyle"))
 . . . . ; if errmethod="" set errmethod=1
 . . . . set errmethod=2
 . . . . if errmethod=2 do  ;
 . . . . . new tprevln,uln
 . . . . . set uln=(%j-1)
 . . . . . set tprevln=zhtml(uln)
 . . . . . if tprevln'["fielderror" set tprevln=zhtml(%j-2) set uln=%j-2
 . . . . . do putErrMsg2^%wf("zhtml",.tprevln,.errmsg,"errctrl")
 . . . . . set zhtml(uln)=tprevln
 . . . . . quit
 . . . . if errmethod=1 do insError^%wf(.tln,.errmsg)
 . . . . quit
 . . . quit
 . . ;
 . . ; [optionally debug & r/html template line w/processed line
 . . ; write !,tln,!,zhtml(%j),! break
 . . if $get(filter("debug"))>0 do debugFld^%wf(.tln,form,name)
 . . set zhtml(%j)=tln
 . . quit
 . ;
 . ;@stanza 13 process text areas
 . ;
 . if zhtml(%j)["<textarea" do  ;
 . . new val set val=""
 . . quit:$get(name)=""
 . . set val=$get(vals(name))
 . . ; set val=$get(vals(name))
 . . ; set val=$$URLENC^VPRJRUT(val)
 . . if val'="" do
 . . . do findReplace^%ts(.tln,"</textarea>",val_"</textarea>")
 . . . quit
 . . set zhtml(%j)=tln
 . . quit
 . ;
 . ;@stanza 14 process option selections
 . ;
 . if zhtml(%j)["<select" do  ;
 . . set selectnm=$get(name)
 . . quit
 . if zhtml(%j)["</select" do  ;
 . . set selectnm=""
 . . quit
 . if zhtml(%j)["<option" do  ;
 . . quit:selectnm=""
 . . set val=$get(vals(selectnm))
 . . do findReplace^%ts(.tln," selected","") ; unselect
 . . if $get(toad)="*****DEBUG*****",value="gd" break ; debug problem w/options
 . . if $g(val)=$get(value) do
 . . . do findReplace^%ts(.tln,"<option ","<option selected ")
 . . . quit
 . . if $get(filter("debug"))=2 do debugFld^%wf(.tln,form,name)
 . . set zhtml(%j)=tln
 . . quit
 . quit
 ;
 ;@stanza 15 return form prepared fr/template
 ;
 ;do ADDCRLF^VPRJRUT(.zhtml)
 ;
 merge @rtn=zhtml ; copy processed template to return array
 ;
 set HTTPRSP("mime")="text/html" ; set mime type
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of wsGetForm^%wf
 ;
 ;
 ;
 ;@section 2 wsGetForm^%wf support subroutines
 ;
 ;
 ;
formLabel ; code for ppi $$formLabel^%wf, form's post url label
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;function;
 ;@signature
 ; $$formLabel^%wf(form)
 ;@branches-from
 ; $$formLabel^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ;@called-by: none
 ;@calls
 ; $$GET1^DIQ
 ;@input
 ; form = form name
 ; ^SAMI(311.11) = 
 ;@output=
 ; label to use
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ;
 ;@stanza 2 do replacements
 ;
 new fglb set fglb=$name(^SAMI(311.11))
 new fn set fn=311.11
 new fien set fien=$order(@fglb@("B",form,""))
 quit:fien="" ""
 new lbl set lbl=$$GET1^DIQ(fn,fien_",",2.1) ; label to use
 ;
 ;@stanza 3 termination
 ;
 quit lbl ; end of $$formLabel^%wf
 ;
 ;
 ;
getTemplate ; code for API $$getTemplate^%wf, form's template name
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;function;
 ;@signature
 ; $$getTemplate^%wf(form)
 ;@branches-from
 ; $$getTemplate^%wf
 ;@api-called-by
 ; wsGetForm^%wf
 ; getTemplate^SAMICASE
 ;@called-by: none
 ;@calls
 ; $$GET1^DIQ
 ;@input
 ; form = form name
 ; ^SAMI(311.11) = 
 ;@output=
 ; template name
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ;
 ;@stanza 2 get template name
 ;
 new fglb set fglb=$name(^SAMI(311.11))
 new fn set fn=311.11
 if form["-" do  ;
 . set form=$piece(form,"-",1)
 . ;if form="sbform" set form="sbform2"
 . quit
 new fien set fien=$order(@fglb@("B",form,""))
 quit:fien="" ""
 new tnm set tnm=$$GET1^DIQ(fn,fien_",",2) ; name of template
 ;
 ;@stanza 3 termination
 ;
 quit tnm ; end of $$getTemplate^%wf
 ;
 ;
 ;
 ;@section 3 wsGetForm^%wf error handling
 ;
 ;
 ;
redactErr ; code for ppi redactErr^%wf, clear errors from form
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do redactErr^%wf(html,err,indx)
 ;@branches-from
 ; redactErr^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ;@called-by: none
 ;@calls: none
 ;@input
 ; html = name of html form array
 ; err = name of error array
 ;.indx = current line in html
 ;@throughput
 ; @html = error messages cleared
 ; @err = error messages cleared
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; redact error message section in html & clear error array
 ;
 ;@stanza 2 clear error messages
 ;
 new done set done=0
 set @err@("errorSectionBeginLine")=indx
 set @err@("errorMessageStyle")=2 ; errors to the top of page
 for i=indx:1,indx+20 quit:done  do  ;
 . if @html@(i)["</div>" set done=1
 . set @html@(i)=""
 . set @err@("errorSectionEndLine")=i
 . if @html@(i)["<tr>" set @err@("currentErrorLine")=i
 . set indx=i
 . quit
 set @err@("errorCount")=0
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of redactErr^%wf
 ;
 ;
 ;
redactErr2 ; code for ppi redactErr2^%wf, redact field's error symbol
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do redactErr2^%wf(html,.indx)
 ;@branches-from
 ; redactErr2^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ;@called-by: none
 ;@calls
 ; deleteBetween^%wf
 ;@input
 ; html = 
 ;.indx = 
 ;@throughput
 ; @html(indx) = 
 ;@examples [tbd]
 ;@tests [tbd]
 ; testRedactErr2^%wf
 ;
 ; [description tbd]
 ;
 ;@stanza 2 remove error symbol from field
 ;
 if @html@(indx)'["fielderror" quit  ; nothing to replace
 if @html@(indx)["fielderror""></span>" quit  ; nothing to replace
 new line
 set line=@html@(indx)
 do deleteBetween^%wf(.line,"fielderror"">","</span>")
 set @html@(indx)=line
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of redactErr2^%wf
 ;
 ;
 ;
testRedactErr2 ; code for test redactErr2^%wf [move to %wfut]
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do testRedactErr2^%wf
 ;@ppi-called-by: none
 ;@called-by: none
 ;@calls
 ; redactErr2^%wf
 ;@input: none
 ;@output
 ; report to screen results of removing error from field
 ;
 ; [description tbd]
 ;
 ;@stanza 2 do replacements
 ;
 new g set g="<th class=""serv"">Served in the military?<span id=""sbmly-fielderror""><a name=""err-2"" href=""#err-2e""><img src=""see/error.png""/>2</a></span></th>"
 new gg set gg(1)=g
 do redactErr2^%wf("gg",1)
 write !,gg(1)
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of testRedactErr2^%wf
 ;
 ;
 ;
putErrMsg2 ; code for ppi putErrMsg2^%wf, insert error msgs
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do putErrMsg2^%wf(html,.line,.msg,err)
 ;@branches-from
 ; putErrMsg2^%wf
 ;@ppi-called-by
 ; wsGetForm
 ;@called-by: none
 ;@calls
 ; findReplace^%ts
 ;@input
 ; html = name of array containing html form
 ;.msg = error message to insert
 ;@throughput
 ; err = name of error array
 ;.line = line to change, containing error, needs error message inserted
 ; @html = form to insert error messages into
 ; @err = error array to update with error message
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; style 2 of error messages - top of screen
 ;
 ;@stanza 2 insert error messages
 ;
 if $g(err)="" set err="errctrl"
 ; merge ^gpl("err")=@err
 new errno set errno=$get(@err@("errorCount"))+1
 set @err@("errorCount")=errno
 new uline set uline=$get(@err@("currentErrorLine"))
 if errno=1 do  ;
 . new bline,eline
 . set bline=$get(@err@("errorSectionBeginLine"))
 . if bline="" quit  ; don't know where to put the section
 . set @html@(bline)="<div class=""errormsg"">"
 . set @html@(bline+1)="<h1>Errors:<h1>"
 . set @html@(bline+2)="<table>"
 . set eline=$get(@err@("errorSectionEndLine"))
 . if eline="" quit  ;
 . set @html@(eline-1)="</table>"
 . set @html@(eline)="</div>"
 . if uline="" set uline=bline+3
 . quit
 new inserttxt
 set inserttxt="<a name=""err-"_errno_""" href=""#err-"_errno_"e""><img src=""see/error.png""/>"_errno_"</a>"
 do findReplace^%ts(.line,"fielderror"">","fielderror"">"_inserttxt)
 if $get(uline)="" quit  ; set uline=32 - no uline is found, so nowhere to put the errors
 set @html@(uline)=@html@(uline)_"<tr><td class=""icon""><a name=""err-"_errno_"e"" href=""#err-"_errno_"""><img src=""see/error.png""/>"_errno_"</a></td><td>"_msg_"</td></tr>"
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of putErrMsg2^%wf
 ;
 ;
 ;
insError ; code for ppi insError^%wf, insert error msg into html line
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do insError^%wf(.line,.msg)
 ;@branches-from
 ; insError^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ; debugFld^%wf
 ;@called-by: none
 ;@calls
 ; findReplace^%ts
 ;@input
 ;.msg = error message to insert
 ;@throughput
 ;.line = line to change by inserting error message
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; inserts an error message into line, passed by reference
 ;
 ;@stanza 2 insert error message
 ;
 new errins set errins="<span class=""alert"" style=""font-size: 0.9em;"">"_msg_"</span>"
 if line["</input>" do  quit
 . do findReplace^%ts(.line,"</input>","</input>"_errins)
 . quit
 if line["/>" do  quit
 . do findReplace^%ts(.line,"/>","/>"_errins)
 . quit
 if line[">" do
 . set line=line_"</input>"_errins
 . quit
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of insError^%wf
 ;
 ;
 ;
debugFld ; code for ppi debugFld^%wf, insert field debugging info
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do debugFld^%wf(line,form,name)
 ;@branches-from
 ; debugFld^%wf
 ;@ppi-called-by
 ; wsGetFld^%wf
 ;@called-by: none
 ;@calls
 ; getFieldMap^%wffmap
 ; insError^%wf
 ;@input
 ; form = 
 ; name = 
 ;@throughput
 ;.line = 
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ;
 ;@stanza 2 insert debugging info re field
 ;
 new dtxt
 set dtxt="field="_name
 new fary
 do getFieldMap^%wffmap("fary",form,name)
 set dtxt=dtxt_" fmFld="_$get(fary("FILEMAN_FIELD"))
 set dtxt=dtxt_" "_$get(fary("DATA_TYPE"))
 set dtxt=dtxt_" fmTitle: "_$get(fary("TITLE"))
 do insError^%wf(.line,dtxt)
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of debugFld^%wf
 ;
 ;
 ;
 ;@section 4 wsGetForm^%wf field value manipulation
 ;
 ;
 ;
unvalue ; code for ppi unvalue^%wf, clear input value in html line
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do unvalue^%wf(.line)
 ;@branches-from
 ; unvalue^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ;@called-by: none
 ;@calls: none
 ;@throughput
 ;.line
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; sets value=""
 ;
 ;@stanza 2 clear value
 ;
 new l1,l2,l3,t1,t2
 set l1=$find(line,"value=""")
 q:l1=0
 set t1=$extract(line,1,l1-1)
 set t2=$extract(line,l1,$length(line))
 set l3=$find(t2,"""")
 set t2=""""_$extract(t2,l3,$length(t2))
 set line=t1_t2
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of unvalue^%wf
 ;
 ;
 ;
value ; code for ppi value^%wf, set input value in html line
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do value^%wf(.line,val)
 ;@branches-from
 ; value^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ;@called-by: none
 ;@calls
 ; findReplace^%ts
 ;@input
 ; val = 
 ;@throughput
 ;.line = 
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; sets value="@val"
 ;
 ;@stanza 2 set value
 ;
 new loc,end
 set loc=$find(line,"value=""""")
 if loc=0 do  quit  ;
 . ; if $extract(line,$length(line))=">" do
 . ; . set line=$extract(line,1,$length(line)-1)_" value="""_val_""""_">"
 . ; . quit
 . do findReplace^%ts(.line,"<input ","<input value="""_val_""" ")
 . quit
 set end=$extract(line,loc,$length(line))
 set line=$piece(line,"value=""",1)_"value="""_val_""""_end
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of value^%wf
 ;
 ;
 ;
getVals ; code for ppi getVals^%wf, get field values from graph
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; d getVals^%wf(vary,zid,zsid)
 ;@branches-from
 ; getVals^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ; testFiler^%wffiler
 ;@called-by: none
 ;@calls
 ; $$setroot^%wd
 ; $$sid2num^SAMIHOME
 ;@input
 ; vrtn = 
 ; zid = 
 ; zsid = 
 ; @root@("graph",zsid,zid)
 ;@output
 ; @vrtn = 
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; get the values for the form from the graph
 ;
 ;@stanza 2 get values from graph
 ;
 new root set root=$$setroot^%wd("vapals-patients")
 if '$data(@root@("graph",zsid,zid)) do  quit  ;
 . set @vrtn@(0)="values for patient: "_zsid_" in graph: "_zsid
 . quit
 merge @vrtn=@root@("graph",zsid,zid)
 ;
 ;@stanza 3 load prefill values
 ;
 new gien set gien=$$sid2num^SAMIHOME(zsid) ; graph ien of this patient
 merge @vrtn=@root@(gien)
 ;
 ;@stanza 4 termination
 ;
 quit  ; end of getVals^%wf
 ;
 ;
 ;
setVals ; code for ppi setVals^%wf, set field values into graph
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do setVals^%wf(vary,zid,zsid)
 ;@branches-from
 ; setVals^%wf
 ;@called-by: none
 ;@calls
 ; $$setroot^%wd
 ;@input
 ; vary = 
 ; zid = 
 ; zsid = 
 ;@output
 ; @root@("graph")
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; set the values returned from form id for patient zsid
 ;
 ;@stanza 2 set values
 ;
 new root set root=$$setroot^%wd("vapals-patients")
 if zsid="XXXX01" do  quit  ; the sample set
 . new src set src=$$setroot^%wd("elcapSampleJson")
 . if '$data(@src@(zid)) quit  ; no such form
 . merge @root@("graph",zsid,zid)=@src@(zid)
 . quit
 kill @root@("graph",zsid,zid)
 merge @root@("graph",zsid,zid)=@vary
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of setVals^%wf
 ;
 ;
 ;
 ;@section 5 wsGetForm^%wf field validation
 ;
 ;
 ;
validate ; code for ppi $$validate^%wf, validate value
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;function;
 ;@signature
 ; $$validate^%wf(value,spec,map,.msg)
 ;@branches-from
 ; $$validate^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ;@called-by: none
 ;@calls
 ; $$dateValid^%wf
 ; $$textValid^%wf
 ; $$numValid^%wf
 ;@input
 ; value = string being validated
 ; spec = fileman spec which defines validation (e.g., FJ30  D  N5.2)
 ; map = [optional] passed by name, field mapping entry for variable
 ;@output
 ;.msg = custom error message
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; extrinsic returns 1 if valid 0 if not valid
 ;
 ;@stanza 2 validate value
 ;
 ;if $get(spec)="" quit 0  ; everything is invalid with no spec
 ;if $get(spec)="" quit 1  ; everything is valid with no spec
 if $get(spec)="" set spec="FJ30" ; make it free text to weed out bad characters
 ;
 ;new valrtn set valrtn
 ;if $get(@map@("VALIDATOR"))'="" do  quit valrtn  ; call a custom validator
 ;. add code to call the custom validator here
 ;
 if spec["S" quit 1  ; all set of codes are valid - let fileman check them
 ;
 if spec["D" quit $$dateValid^%wf(value,spec,$get(map),.msg) ; validate a date
 ;
 if spec["F" quit $$textValid^%wf(value,spec,$get(map)) ; validate free text field
 ;
 if spec["N" quit $$numValid^%wf(value,spec,$get(map)) ; validate a numeric value
 ;
 ;@stanza 3 termination
 ;
 quit 0  ; what else is there? assume it is invalid ; end of $$validate^%wf
 ;
 ;
 ;
dateValid ; code for ppi $$dateValid^%wf, validate date
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;function;
 ;@signature
 ; $$dateValid^%wf(value,spec,map,msg)
 ;@branches-from
 ; $$dateValid^%wf
 ;@ppi-called-by
 ; $$validate^%wf
 ;@called-by: none
 ;@calls
 ; ^%DT: Vista Fileman date-time input/validation
 ;@input
 ; value = date being validated
 ; spec = 
 ; map = 
 ;@output=
 ; 1 if valid
 ; 0 if invalid
 ;.msg =
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; extrinsic which validates a date
 ;
 ;@stanza 2 validate date
 ;
 new X,Y
 set X=value
 do ^%DT
 if Y=-1 quit 0
 ;
 ;@stanza 3 termination
 ;
 quit 1 ; end of $$dateValid^%wf
 ;
 ;
 ;
textValid ; code for ppi $$textValid^%wf, validate free-text field
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;function;
 ;@signature
 ; $$textValid^%wf(value,spec,map)
 ;@branches-from
 ; $$textValid^%wf
 ;@ppi-called-by
 ; $$validate^%wf
 ;@called-by: none
 ;@calls: none
 ;@input
 ; value = text being validated
 ; spec = fileman spec which defines validation (e.g., FJ30)
 ; map =
 ;@output=
 ; 1 if valid
 ; 0 if invalid
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; validate a free text field
 ; uses mumps pattern matching
 ;
 ;@stanza 2 validate text
 ;
 if spec'["F" quit 0  ; not a text field
 ;
 new min,max,x,specn
 set specn=+$translate(spec,"FJX ","") ; gets rid of the alphabetics 
 if specn["." do  ; there is a minimum and maximum
 . set min=$piece(specn,".",1)
 . set max=$piece(specn,".",2)
 . set x="value?"_min_"."_max_"LUNP"
 . quit
 else  do  ; no minimum
 . set x="value?."_specn_"LUNP"
 . quit
 ;w !,x
 if @x quit 1
 ;
 ;@stanza 3 termination
 ;
 quit 0 ; end of $$textValid^%wf
 ;
 ;
 ;
numValid ; code for ppi $$numValid^%wf, validate numeric field
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;function;
 ;@signature
 ; $$numValid^%wf(value,spec,map)
 ;@branches-from
 ; $$numValid^%wf
 ;@ppi-called-by
 ; $$validate^%wf
 ;@called-by: none
 ;@calls: none
 ;@input
 ; value = number being validated
 ; spec = fileman spec which defines validation (e.g., N5.2)
 ; map =
 ;@output=
 ; 1 if valid
 ; 0 if invalid
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; validate a numeric field
 ; uses mumps pattern matching, handles decimal points
 ;
 ;@stanza 2 validate number
 ;
 if spec'["N" quit 0  ; not a numeric field
 new left,right,x,specn
 set specn=$translate(spec,"NJX ","") ; gets rid of the alphabetics 
 new result set result=1 ; assume valid
 if specn["," do  quit result  ; there is a left and right
 . set left=$piece(specn,",",1) ; digits left of the decimal
 . new valleft set valleft=$piece(value,".",1)
 . set x="valleft?."_left_"N"
 . if @x s result=1
 . else  set result=0 quit  ;
 . ; now test the number of digits right of the decimal 
 . set right=$piece(specn,",",2)
 . new valright set valright=$piece(value,".",2) ; digits right of the decimal
 . set x="valright?."_right_"N"
 . if @x set result=1
 . else  set result=0
 . quit
 else  d  ; no right of decimal point
 . set x="value?."_specn_"N"
 . quit
 w !,x
 if @x quit 1
 ;
 ;@stanza 3 termination
 ;
 quit 0 ; end of $$numValid^%wf
 ;
 ;
 ;
dateFormat ; code for ppi $$dateFormat^%wf, date in elcap format
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do dateFormat^%wf(.val,form,name)
 ;@branches-from
 ; dateFormat^%wf
 ;@ppi-called-by
 ; wsGetForm
 ;@called-by: none
 ;@calls
 ; $$getFieldSpec^%wffmap
 ; ^%DT
 ; $$FMTE^XLFDT
 ;@input
 ; form = 
 ; name = 
 ;@throughput
 ;.val = date
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; reformat date in elcap format
 ;
 ;@stanza 2 reformat date
 ;
 new spec set spec=$$getFieldSpec^%wffmap(form,name)
 if spec'["D" quit  ; not a date field
 new X,Y
 set X=val
 do ^%DT
 if Y=-1 quit  ; invalid date, can't reformat
 new dtmp set dtmp=$$FMTE^XLFDT(Y,"D") ; default exteral date format
 if $length(dtmp)=12 set val=$extract(dtmp,5,6)_"/"_$extract(dtmp,1,3)_"/"_$extract(dtmp,9,12) ; jan 01,1987
 else  set val=dtmp
 if $length(val)=8 set val=$extract(val,5,8)
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of dateFormat^%wf
 ;
 ;
 ;
 ;@section 6 wsPostForm^%wf web service & parseBody ppi
 ;
 ;
 ;
wsPostForm ; code for ws wsPostForm^%wf, submit HTML form
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;web service;procedure;
 ;@signature
 ; do wsPostForm^%wf(.ARGS,BODY,RESULT)
 ;@branches-from
 ; wsPostForm^%wf
 ;@ppi-called-by
 ; web service POST:form/*
 ;@called-by: none
 ;@calls
 ; parseBody^%wf
 ; $$setroot^%wd
 ; wsGetForm^%wf
 ; fileForm^%wffiler
 ; fmx^%sfv2g
 ; ENCODE^VPRJSON
 ; beautify^%wd
 ; ADDCRLF^VPRJRUT
 ;@input
 ;.ARGS =
 ;.BODY =
 ;@output
 ;.RESULT =
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; receive from form
 ;
 ;@stanza 2 receive from form
 ;
 new %json,form,sid,body,tbdy
 set form=$get(ARGS("form"))
 set sid=$get(ARGS("studyid"))
 set body=$get(BODY(1))
 if form="" set form="sbform"
 if sid="" set sid="XXXX17"
 quit:form=""
 quit:sid=""
 set %json(sid,form,"form")=form
 do parseBody^%wf("tbdy",.body)
 merge %json(sid,form)=tbdy
 new gr set gr=$$setroot^%wd("vapals-patients")
 merge @gr@("graph")=%json
 ;
 if $get(ARGS("debug"))="" do  quit  ;
 . do wsCASE^SAMICAS2(.RESULT,.ARGS)
 . quit
 ;
 ; validation process
 ;
 new errflag set errflag=0
 new revise
 do wsGetForm^%wf(.revise,.ARGS,1)
 if form="sbform2" if errflag'=0 do  quit  ;
 . merge RESULT=revise
 ;
 ; end validation process
 ;
 ; no errors, file it into fileman
 new status s status=""
 if form["sbform" do  ;
 . do fileForm^%wffiler("tbdy","sbform",sid,"status")
 . ;
 . ; now return the fileman record that was created
 . new fman,fien
 . set fien=$order(^SAMI(311.102,"B",sid,""))
 . quit:fien=""
 . do fmx^%sfv2g("fman",311.102,fien)
 . quit
 merge fman=status
 merge fman(form)=tbdy
 new tjson
 do ENCODE^VPRJSON("fman","tjson")
 do beautify^%wd("tjson","RESULT")
 DO ADDCRLF^VPRJRUT(.RESULT)
 set HTTPRSP("mime")="application/json"
 kill ^gpl("sami")
 merge ^gpl("sami","args")=ARGS
 merge ^gpl("sami","body")=BODY
 merge ^gpl("sami","json")=%json
 merge ^gpl("sami","fman")=fman
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of wsPostForm^%wf
 ;
 ;
 ;
parseBody ; code for ppi parseBody^%wf, get field values from form
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;
 ;@signature
 ; do parseBody^%wf(rtn,body)
 ;@branches-from
 ; parseBody^%wf
 ;@ppi-called-by
 ; wsPostForm^%wf
 ; wsNuFormPost^SAMICASE
 ; wsLookup^SAMISRCH
 ;@called-by: none
 ;@calls
 ; $$URLDEC^VPRJRUT
 ;@input
 ; rtn = [pass by name]
 ; body = 
 ;@output
 ; @rtn =
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; parse the variables sent by a form
 ; rtn is passed by name
 ;
 ;@stanza 2 parse variables from form
 ;
 new ii set ii=""
 if '$data(body) set body=$get(^gpl("sami","body",1))
 quit:'$data(body)
 new tmp set tmp=body
 kill @rtn
 for ii=1:1:$length(tmp,"&") do  ;
 . new ij
 . set ij=$piece(tmp,"&",ii)
 . quit:ij=""
 . set @rtn@($piece(ij,"=",1))=$$URLDEC^VPRJRUT($piece(ij,"=",2))
 . quit
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of parseBody^%wf
 ;
 ;
 ;
 ;@section 7 commented-out procedures
 ;
 ;
 ;
replaceSrc ; code for ppi replaceSrc^%wf, chg resources in src & href
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;function;
 ;@signature
 ; $$replaceSrc^%wf(.line)
 ;@branches-from
 ; $$replaceSrc^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf [commented out]
 ;@called-by: none
 ;@calls
 ; findReplaceAll^%ts
 ;@input
 ;.line = 
 ;@output=
 ; 1 if replacement was done
 ; 0 if not
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; do replacements on lines for src= to use see service to locate resource
 ; deprecated, needed changes are in template now.
 ;
 ;@stanza 2 insert see service in src & href lines
 ;
 new done set done=0
 if line["src='/" do  ;
 . do findReplaceAll^%ts(.line,"src='/","src='see/")
 . set done=1
 . quit
 if line["src=""/" do  ;
 . quit:done
 . do findReplaceAll^%ts(.line,"src=""/","src=""see/")
 . set done=1
 . quit
 if line["src=" do  ; 
 . quit:done
 . do findReplaceAll^%ts(.line,"src=""","src=""see/")
 . set done=1
 . quit
 if line["href='/" do  ;
 . do findReplaceAll^%ts(.line,"href='/","href='see/")
 . set done=1
 . quit
 if line["href='" do  ;
 . quit:done
 . if line["href=""#" quit  ;
 . if line["href=""javascript" quit  ;
 . do findReplaceAll^%ts(.line,"href='","href='see/")
 . set done=1 
 . quit
 if line["href=" do  ; 
 . quit:done
 . if line["href=""#" quit  ;
 . if line["href=""javascript" quit  ;
 . do findReplaceAll^%ts(.line,"href=""","href=""see/")
 . set done=1
 . quit
 ;
 ;@stanza 3 termination
 ;
 quit done ; end of $$replaceSrc^%wf
 ;
 ;
 ;
replaceHref ; code for ppi replaceHref^%wf, chg resources in href
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;function;
 ;@signature
 ; $$replaceHref^%wf(.line)
 ;@branches-from
 ; $$replaceHref^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf [commented out]
 ;@called-by: none
 ;@calls
 ; findReplace^%ts
 ;@input
 ;.line = 
 ;@output=
 ; 1 if replacement was done
 ; 0 if not
 ;@throughput
 ;@examples [tbd]
 ;@tests [tbd]
 ;
 ; [description tbd]
 ; do replacements on html lines for href values ; extrinsic returns true if
 ; replacement was done
 ; deprecated, use replaceSrc instead, if needed
 ;
 ;@stanza 2 process href lines
 ;
 new conds,done
 set done=0
 set conds("""sami.css""")="""resources/sami/sami.css"""
 set conds("""sami.js""")="""resources/sami/sami.js"""
 set conds("""sami2.js""")="""resources/sami/sami2.js"""
 set conds("""jquery-3.2.1.min.js""")="""resources/sami/jquery-3.2.1.min.js"""
 set conds("""jquery-ui.min.js""")="""resources/sami/jquery-ui.min.js"""
 ;
 new %ig set %ig=""
 for  set %ig=$order(conds(%ig)) quit:%ig=""  do  ;
 . if line[%ig do  ;
 . . do findReplace^%ts(.line,%ig,$get(conds(%ig)))
 . . set done=1
 . . quit
 . quit
 ;
 ;@stanza 3 termination
 ;
 quit done ; end of $$replaceHref^%wf
 ;
 ;
 ;
eor ; end of routine %wfhform

%wfhinput
%wfhinput ;ven/gpl-web form: html input tag ;2018-03-18T17:24Z
 ;;1.8;Mash;
 ;
 ; %wfhinput implements the Web Form Library's html input tag
 ; processing methods, such as identifying input type or processing
 ; radio buttons & checkboxes.
 ; See %wfuthi for the unit tests for these methods.
 ; See %wfut for the whole unit-test library.
 ; See %wfud for documentation introducing the Web Form Lbrary,
 ; including an intro to the HTML Input Library.
 ; See %wful for the module's primary-development log.
 ; See %wf for the module's ppis & apis.
 ; %wfhinput contains no public entry points.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development: see routine %wful
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-18T17:24Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Web Form - %wf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;
 ;@to-do
 ; write unit tests
 ;
 ;@contents
 ; type: code for ppi $$type^%wf, input type
 ; uncheck: code for ppi uncheck^%wf, uncheck radio button or checkbox
 ; check: code for ppi check^%wf, check radio button or checkbox
 ;
 ;
 ;
 ;@section 1 type processing
 ;
 ;
 ;
type ; code for ppi $$type^%wf, input type
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;clean;silent;sac;???% tests
 ;@signature
 ; $$type^%wf(line)
 ;@branches-from
 ; $$type^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ;@called-by: none
 ;@calls: none
 ;@input
 ; line = line of html including one & only one complete input tag. It
 ;  does not enforce standard input types but returns whatever type
 ;  the input says it is. Likewise, so long as the line contains that
 ;  tag & attribute, it does not care whether the rest of the line or
 ;  even the rest of this tag is standard-compliant. If no input tag
 ;  or type attribute exists in line, returns "".
 ;@output = value of type attribute within input tag
 ;@examples
 ; $$type^%wf("<input type=""radio"">") = "radio"
 ; $$type^%wf("<input type=radio>") = "radio"
 ; $$type^%wf("type=""radio""") = ""
 ; $$type^%wf("<input>") = ""
 ; $$type^%wf("<input type=""faketype"">") = "faketype"
 ; $$type^%wf("nonsense<input type=""button"">nonsense") = "button"
 ; $$type^%wf("<Input tYpe=""rAdIo"">") = "radio"
 ; $$type^%wf("") = ""
 ; $$type^%wf() = ""
 ;@tests: in %wfuthi
 ; type01: html compliant
 ; type02: nonstandard variant
 ; type03: no input tag
 ; type04: no type attribute
 ; type05: nonstandard type value
 ; type06: nonsense around input tag
 ; type07: case-insensitive
 ; type08: empty string
 ; type09: undefined
 ;@to-do
 ; handle splitting tag or attribute across lines
 ;
 ; extrinsic function returns value of input tag's type attribute. It
 ; is case-insensitive.
 ;
 ; Like the rest of web service %wf-wsGetForm, this function is not
 ; designed to handle tags or attributes that split across lines,
 ; nor lines containing multiple input tags.
 ;
 ;@stanza 2 parse & return type attribute's value
 ;
 set line=$get(line)
 new linelow set linelow=$$lowerCase^%ts(line) ; refresh lowercase
 new type set type=""
 ;
 ; handle missing input tag
 if linelow'["<input" ; sets $test
 ;
 ; standard html (quotes around type attribute value)
 else  if linelow[" type=""" do  ; e.g., <input type="radio" ...>
 . set type=$piece($piece(linelow," type=""",2),""" ")
 . quit
 ;
 ; nonstandard html (no quotes around type attribute value)
 else  if linelow[" type=" do  ; e.g., <input type=radio ...>
 . set type=$piece($piece(linelow," type=",2)," ")
 . quit
 ;
 set:type["""" type=$piece(type,"""")
 set:type[">" type=$piece(type,">")
 ;
 quit type ; return input type, end of $$type^%wf
 ;
 ;
 ;
 ;@section 2 radio/checkbox processing
 ;
 ;
 ;
uncheck ; code for ppi uncheck^%wf, uncheck radio button or checkbox
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;clean;silent;sac;???% tests
 ;@signature
 ; do uncheck^%wf(.line)
 ;@branches-from
 ; uncheck^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ;@called-by: none
 ;@calls
 ; $$lowerCase^%ts
 ; findReplace^%ts
 ;@throughput
 ;.line = line of template html to be replaced by processed html
 ;.line("low") = lowercase version of line for checks & searches
 ;@examples
 ;
 ;  new line
 ;  set line="<input type=radio name=""sbhcs"" value=""n"" checked> no"
 ;  do uncheck^%wf(.line)
 ; produces
 ;  line="<input type=radio name=""sbhcs"" value=""n""> no"
 ;
 ;  new line
 ;  set line="<input type=radio name=""sbphu"" value=""i"" CHECKED> in"
 ;  do uncheck^%wf(.line)
 ; produces
 ;  line="<input type=radio name=""sbphu"" value=""i""> in"
 ;
 ;  new line
 ;  set line="<input type=radio name=""sbphu"" value=""c""> cm"
 ;  do uncheck^%wf(.line)
 ; produces
 ;  line="<input type=radio name=""sbphu"" value=""c""> cm"
 ;
 ;  new line
 ;  set line="<input type=""radio"" name=""sbmpa"" value=""n"" checked=""checked"">no</input>"
 ;  do uncheck^%wf(.line)
 ; produces
 ;  line="<input type=""radio"" name=""sbmpa"" value=""n"">no</input>"
 ;
 ;  new line
 ;  set line="<input type=""radio"" name=""sbmpmi"" value=""n"" checked=checked>no</input>"
 ;  do uncheck^%wf(.line)
 ; produces
 ;  line="<input type=""radio"" name=""sbmpmi"" value=""n"">no</input>"
 ;
 ;  new line set line=""
 ;  do uncheck^%wf(.line)
 ; produces
 ;  line=""
 ;
 ;  new line
 ;  do uncheck^%wf(.line)
 ; produces
 ;  line=""
 ;
 ;@tests: in %wfuthi
 ; unchk01: html compliant
 ; unchk02: uppercase CHECKED
 ; unchk03: not checked
 ; unchk04: nonstandard variant 1
 ; unchk05: nonstandard variant 2
 ; unchk06: empty string
 ; unchk07: undefined
 ;@to-do
 ; handle splitting tag or attribute across lines
 ;
 ; [description tbd]
 ; removes checked attribute from input tag, handles two nonstandard
 ; variants, handles uppercase or mixed case
 ;
 ;@stanza 2 uncheck checkbox or radio button
 ;
 set line=$get(line)
 new linelow set linelow=$$lowerCase^%ts(line) ; refresh lowercase
 new find set find=""
 new doit set doit=0
 ;
 ; html standard
 if linelow[" checked "!(linelow[" checked>") do
 . set find=" checked"
 . set doit=1
 . quit
 ;
 ; nonstandard variant 1
 else  if linelow[" checked=""checked""" do
 . set find=" checked=""checked"""
 . set doit=1
 . quit
 ;
 ; nonstandard variant 2
 else  if linelow[" checked=checked" do
 . set find=" checked=checked"
 . set doit=1
 . quit
 ;
 do:doit findReplace^%ts(.line,find) ; cut checked attribute
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of uncheck^%wf
 ;
 ;
 ;
check ; code for ppi check^%wf, check radio button or checkbox
 ;
 ;@stanza 1 invocation, binding, & branching
 ;
 ;ven/gpl;private;procedure;clean;silent;sac;???% tests
 ;@signature
 ; do check^%wf(.line,type)
 ;@branches-from
 ; check^%wf
 ;@ppi-called-by
 ; wsGetForm^%wf
 ;@called-by: none
 ;@calls
 ; $$lowerCase^%ts
 ; findReplace^%ts
 ;@throughput
 ;.line = line of template html to be replaced by processed html
 ;.line("low") = lowercase version of line for checks & searches
 ;@input
 ; type = value of input tag's type attribute
 ;@examples
 ;
 ;  new line
 ;  set line="<input type=""radio"" name=""sbdsd"" id=""sbdsd-n"" value=""n""> No"
 ;  new type set type="radio"
 ;  do uncheck^%wf(.line,type)
 ; produces
 ;  line="<input type=""radio"" checked name=""sbdsd"" id=""sbdsd-n"" value=""n""> No"
 ;
 ;  new line
 ;  set line="<input type=radio name=""sbphu"" value=""c""> cm"
 ;  new type set type="radio"
 ;  do uncheck^%wf(.line,type)
 ; produces
 ;  line="<input type=radio checked name=""sbphu"" value=""c""> cm"
 ;
 ;  new line
 ;  set line="<input TYPE=checkbox name=""sbshsua"" value=""a""> cigars"
 ;  new type set type="checkbox"
 ;  do uncheck^%wf(.line,type)
 ; produces
 ;  line="<input TYPE=checkbox checked name=""sbshsua"" value=""a""> cigars"
 ;
 ;  new line set line="<html lang=""en"">"
 ;  new type set type=""
 ;  do uncheck^%wf(.line,type)
 ; produces
 ;  line="<html lang=""en"">"
 ;
 ;  new line set line=""
 ;  do uncheck^%wf(.line)
 ; produces
 ;  line=""
 ;
 ;  new line
 ;  do uncheck^%wf(.line)
 ; produces
 ;  line=""
 ;
 ;@tests: in %wfuthi
 ; chk01: html compliant
 ; chk02: nonstandard variant
 ; chk03: case-insensitive
 ; chk04: no type attribute
 ; chk05: empty string
 ; chk06: undefined
 ;@to-do
 ; handle splitting tag or attribute across lines
 ;
 ; [description tbd]
 ; for radio buttons & checkbox, to be called only after input's
 ; checked attribute has already been cleared, to avoid ending up
 ; with two checked attributes.
 ;
 ;@stanza 2 check the radio button or checkbox
 ;
 set line=$get(line)
 new linelow set linelow=$$lowerCase^%ts(line) ; refresh lowercase
 set type=$get(type)
 new doit set doit=0
 ;
 ; html standard
 new find set find="type="""_type_"""" ; substring to find
 new replace set replace=find_" checked" ; substring to replace it with
 if linelow[find do
 . set doit=1
 . quit
 ;
 ; nonstandard variant: no quotes around type atribute's value
 else  do
 . set find="type="_type
 . quit:linelow'[find
 . set doit=1
 . quit
 ;
 do:doit findReplace^%ts(.line,find,replace)
 ;
 ;@stanza 3 termination
 ;
 quit  ; end of check^%wf
 ;
 ;
 ;
eor ; end of routine %wfhinput

%wful
%wful ;ven/toad-web form: development log ;2018-03-24T22:06Z
 ;;1.8;Mash;
 ;
 ; %wful is the Web Form Library's primary-development log.
 ; It contains no executable software.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-24T22:06Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Web Form - %wf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@module-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-02-27/09-18 ven/gpl %*1.7t03 %yottaq: original routine developed
 ;
 ; 2017-09-25 ven/gpl %*1.7t03 %yottaq: split lines containing >1
 ; <input> tag to aid parsing; replace quotes with &quot; to aid
 ; parsing; in wsGetForm.
 ;
 ; 2017-10-02 ven/gpl %*1.7t03 %wfhform: renamespace under %wf and move
 ; all subroutines related to wsGetForm & wsPostForm to this new
 ; routine; all other subroutines went elsewhere, including under %wd;
 ; begin spelling out mumps language elements; remove dead code; new
 ; subroutines initforms & initform1.
 ;
 ; 2017-10-04 ven/gpl %*1.7t03 %wfhform: r/initforms & initform1
 ; w/validate, dateValid, textValid, numValid.
 ;
 ; 2017-10-07 ven/gpl %*1.7t03 %wfhform: in wsGetForm r/postform w/form
 ; action, r/.5 w/.001 in <input> split, insert new validation block,
 ; insert debugging line after validation; new insError; in wsPostForm
 ; add validation block; in validate & dateValid add mew msg param.
 ;
 ; 2017-10-24 ven/gpl %*1.7t03 %wfhform: in wsGetForm r/id, handle
 ; temporary values, call $$replaceSrc to fix css & js href values, call
 ; debugFld as needed; add debugFld, replaceSrc, replaceAll; in replaceHref
 ; add conds sami2.js, jquery-3.2.1.min.js, jquery-ui.min.js; in insError
 ; expand to append error inserts to more than just </input>; in setVals
 ; clear old graph before merging new one in.
 ;
 ; 2017-10-30 ven/gpl %*1.7t03 %wfhform: in wsGetForm add param post to
 ; support posting w/o retrieving; in wsPostForm use new param, after
 ; validation block add filing into Fileman & returning the record.
 ;
 ; 2017-10-31 ven/gpl %*1.7t03 %wfhform: in wsGetForm comment out fixing
 ; css & js values, reformat if date; add dateFormat.
 ;
 ; 2017-11-15 ven/gpl %*1.7t03 %wfhform: in wsGetForm preserve graph
 ; variables not saved in fileman, remove error section, support new debug
 ; flags for form, support 2nd error method; add redactErr, redactErr2,
 ; testRedactErr2, putErrMsg2, delText; in dateFormat be more flexible;
 ; move replaceSrc & replaceHref to end; in wsPostForm use new status
 ; param in call to fileForm^%wffiler; in validate make default type free
 ; text to support weeding out bad characters.
 ;
 ; 2017-12-20 ven/gpl %*1.7t03 %wfhform: in wsGetForm add special handling
 ; for sbform2, chg default form handling to call $$getTemplate, add temp
 ; hack for elcap forms (gpl), introduce use of form label in form action,
 ; restore fixes of css & js values, skip table lines, improve handling of
 ; option selected, stop adding crlf; add formLabel, getTemplate;
 ; in putErrMsg2 don't insert errors if nowhere to put them, refine
 ; insError; in unvalue & value handle missing value=; in wsPostForm don't
 ; quit on error for sbform2; in replaceSrc skip inserting see service if
 ; href is javascript.
 ;
 ; 2018-01-03 ven/gpl %*1.8t04 %wfhform: in wsGetForm call SAMISUBS^SAMIFRM
 ; & replace line, comment out post action; in wsPostForm only return fm
 ; record & set status if sbform.
 ;
 ; 2018-01-17 ven/gpl %*1.8t04 %wfhform: in wsGetForm use filter("fvalue")
 ; if present to set sid, combine handling of sbform & sbform2, comment
 ; out temp elcap forms hack, overhaul processing of action, struggle w/
 ; checkboxes & radio buttons; in getTemplate comment out special handling
 ; of sbform & sbform2; in uncheck & check wrestle with radio buttons &
 ; checkboxes; in wsPostForm generalize handling of sbforms; in replaceSrc
 ; handle quotes.
 ;
 ; 2018-01-22 ven/toad %1.8t04 %wful: create development-log routine.
 ;  %wf: passim hdr comments, mash style, rearrange subroutines.
 ;  %wfhform: passim hdr comments, spell out mumps language elements,
 ; add do-dot quits, white space, rearrange subroutines.
 ;
 ; 2018-01-31/02-03 ven/toad %1.8t04 %wful: hdr comments include project
 ; & partner-org & refine copyright.
 ;  %wf & %wfhform: hdr comments refine credits, add to-do; finish laying
 ; out sections & rearranging subroutines.
 ;
 ; 2018-02-04 ven/gpl %1.8t04 %wfhform: in wsGetForm work on customScan
 ; logic, add special handling for form sbform3, protect vs undef val in
 ; two places; in replace protect vs undef ln; in getVals ensure if
 ; graph undef for this patient return 0 node.
 ;  %wf: in wsGetForm add optional param post; add ppi $$getTemplate^%wf,
 ; putErrMsg2^%wf, $$validate^%wf, $$dateValid^%wf, $$textValid^%wf,
 ; $$numValid^%wf, dateFormat^%wf; in replaceAll fix toad's dp typo.
 ;
 ; 2018-02-05 ven/toad %1.8t04 %wf: passim finish creating remaining ppis
 ; $$formLabel^%wf, redactErr^%wf, redactErr2^%wf, insError^%wf,
 ; debugFld^%wf, $$delText^%wf, & test testRedactErr2^%wfhform, adjust
 ; param passing to match %wfhform protections, remove my old ppi comments,
 ; spell out language elements, refine ppi comments, move replaceAll up
 ; to section 4.
 ;  %wfhform: refine ppi comments, spell out language elements, note calls
 ; from outside routine; move replaceAll up to section 4, add calls from
 ; outside routine.
 ;  %wffiler: apply hdr comments, white space, spell out language elements,
 ; r/getVals^%wfhform w/getVals^%wf, add do-dot quits.
 ;  %wffmap: apply hdr comments, white space, spell out language elements,
 ; add do-dot quits; in importfmap synch ppi comments.
 ;
 ; 2018-02-11 ven/toad %1.8t04 %wf & %wfhform: passim update calls &
 ; called-by tags & add ppi-called-by, standardize API, ppi, ws tags &
 ; comments, convert %wf's calls to %wfhform to gotos, convert %wfhform
 ; labels to receive gotos, repoint check & uncheck^%wf to %wfhradio
 ; then to %wfhinput, annotate wsGetForm & break into stanzas.
 ;  %wfhradio->%wfhinput: new routine fr/check & uncheck^%wfhform,
 ; rename to %wfhinput, refactor check & uncheck, make check only
 ; apply standard checked attribute.
 ;  %wf,%wfhinput,%wfhform: add & use $$type^%wf ppi, make it & check
 ; & uncheck read any case of INPUT or TYPE or CHECKED as per html
 ; standard but only write lowercase, as per html convention.
 ;
 ; 2018-02-13/03-01 ven/toad %1.8t04 %wf,%wfhfind,%wfhform,SAMIFRM,
 ; SAMICASE: move code for ppis $$delText^%wf,replace^%wf,replaceAll^%wf
 ; fr/%wfhform to/%whfhfind, repoint ppis to moved code, rename
 ; $$delText->deleteBetween (function->procedure), replace->findReplace,
 ; replaceAll->findReplaceAll, change all calls to ppis to match, add
 ; ppis find^%wf & replace^%wf to do case-insensitive find & replace,
 ; rename replace => place. move replace^%wf => setextract^%ts &
 ; replace^%wfhfind => setextract^%tses. find^%wf => find^%ts,
 ; find^%wfhfind => find^%tsef. findReplace^%wf => findReplace^%ts &
 ; repoint calls to it from %wfhform & %wfhinput. fold George's 02-27
 ; mod into my %wfhform; eliminate findReplaceAll^%wfhfind in favor of
 ; findReplace^%ts with A flag; remove findReplaceAll^%wf.
 ;
 ; 2018-02-27 ven/gpl 1.8t04 %wfhform: in getVals load prefill values
 ; by calling $$sid2num^SAMIHOME.
 ;
 ; 2018-03-05 ven/toad %1.8t04 %wfhinput: in uncheck,check,type use
 ; new calls, add examples, & be cautious about lowercase, rename
 ; module => Web form Library.
 ;  %wffiler: update headers & white space
 ;  %wffmap: update headers & white space
 ;  %wfhfind: update headers
 ;  %wfhform: update headers
 ;  %wfut: create core unit-test routine.
 ;  %wfuthi: create html input unit-test routine.
 ;
 ; 2018-03-07/08 ven/toad %1.8t04 %wfhform: in parseBody,wsGetForm update
 ; called-by. in wsGetForm restore CR/LF line.
 ;
 ; 2018-03-16/18 ven/toad %1.8t04 %wfhform: fix latent bug in getVals that
 ; manifests in testing but not in production, in which leftover local
 ; variable sid is used when zsid is meant, yet because wsGetForm has sid
 ; set in the cymbol table to the correct value, we see no problem when
 ; running the Form Processor, only when testing getVals in isolation.
 ; passim ensure r flag always used in findReplace^%ts calls. Then
 ; reconsider approach to findReplace^%ts, create findReplaceAll^%ts,
 ; simplify both, & use throughout %wfhform.
 ;  %wfhinput: in uncheck & check simplify calls to findReplace^%ts.
 ;
 ; 2018-03-24 ven/lmry %1.8t04 %wful: new %wfutexcl
 ;
 ;@to-do
 ; use find & place in other three ppis
 ;
 ;@module-contents
 ; %wf: write form ppi & api library
 ; %wffiler: fileman-to-form interfaces
 ; %wffmap: fileman-to-form maps
 ; %wfhform: graph-to-form interfaces
 ; %wfhinput: process input tags, including radio & checkbox
 ; %wful: primary-development log
 ; %wfut: unit tests
 ; %wfuthi: unit tests for html input tags
 ;
 ;
 ;
eor ; end of routine %wful

%wfut
%wfut ;ven/mcglk&toad-web form: unit tests ;2018-03-24T22:03Z
 ;;1.8;Mash;
 ;
 ; %wfut implements unit tests for the Mash Web Form Library.
 ; See %wfud for documentation introducing the Web Form library.
 ; See %wful for the module's primary-development log.
 ; See %wf for the module's ppis & apis.
 ; It contains two direct-mode interfaces for running unit tests
 ; & reporting code coverage.
 ; %wfut contains no public entry points.
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-24T22:03Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Web Form - %wf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@to-do
 ; create unit tests for entire %ts type-string library
 ;
 ;@contents
 ; ^%wfut: dmi to run Mash Web Form Library unit-test suite
 ; cover^%wfut: dmi to run tests & calculate code coverage
 ; cover01: no-entry-from-top code-coverage tests
 ; XROU: listing of unit-test routines for the Web Form Library
 ;
 ;
 ;@section 1 dmi to run Mash Web Form Library unit-test suite
 ;
 ;
 ;
 do EN^%ut($text(+0),2) ; invoke M-Unit
 ;
 quit  ; end of call from top
 ;
 ;
 ;
 ;@section 2 dmi to run tests & calculate code coverage
 ;
 ;
 ;
cover ; run tests & calculate code coverage
 ;
 ;ven/toad;dmi;procedure;clean;report;sac
 ;
 new namespace
 set namespace="%wf*" ; set namespace for routines being tested
 ;
 ; add routines here in preferred order; this enables us to easily
 ; rearrange these in whatever order we like
 ;----------------------------------------------------------------------------
 new %wfuincl
 set %wfuincl(1)="^%wfut"
 ;----------------------------------------------------------------------------
 ; note that routine references may be specified as:
 ;   * routine        : calls EN^%ut with name as argument
 ;   * ^routine       : calls top of routine
 ;   * label^routine  : calls label in routine
 ; we generally prefer middle form
 ;
 ; to exclude specific routines, do that here:
 ;----------------------------------------------------------------------------
 new %wfuexcl
 set %wfuexcl(1)="cover^%wfut"
 ; set %wfuexcl(#)="EXCLUDEME^TESTROUTINE"
 ;----------------------------------------------------------------------------
 ;
 ; add %wfuexcl values to ^TMP, which tracks this coverage test
 merge ^TMP("%wfu",$job,"XCLUDE")=%wfuexcl
 ;
 ; cover %wf* namespace; '3' specifies verbosity: this will show values
 ; showing total coverage, plus values for each routine in namespace,
 ; plus totals for everything analyzed, along with coverage values
 ; for each tag within routines, as well as lines under each tag that
 ; were *not* covered in analysis. This may be quite a bit of info,
 ; & we may have to modify namespace and/or verbosity to pare this down
 ; until we have a lot more unit tests written.
 ;
 do COVERAGE^%ut(namespace,.%wfuincl,.%wfuexcl,2)
 ;
 quit  ; end of cover
 ;
 ;
 ;
 ;@section 3 no-entry-from-top code-coverage tests
 ;
 ;
 ;
cover01 ; @TEST no entry from top
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 do ^%wf ; all of these are for 100% code coverage
 do ^%wffiler
 do ^%wffmap
 do ^%wfhfind
 do ^%wfhform
 do ^%wfhinput
 do ^%wful
 do ^%wfuthi
 do CHKEQ^%ut(1,1)
 ;
 quit  ; end of cover01
 ;
 ;
 ;
 ;@section 4 unit-test routines for the Web Form Library
 ;
 ;
 ;
XTROU ; routines containing unit tests for ^%ts apis
 ;;%wfuthi; html input tag processing
 ;
 ;
 ;
eor ; end of routine %wfut

%wfuthi
%wfuthi ;ven/toad-web form: test %wfhinput ;2018-03-06T20:00Z
 ;;1.8;Mash;
 ;
 ; %wfuthi implements eleven unit tests for apis $$type^%wf,
 ; check^%wf, & uncheck^%wf.
 ; See %wfhinput for the code for those apis.
 ; See %wfut for the whole unit-test library.
 ; See %wfud for documentation introducing the Web Form Lbrary,
 ; including an intro to the HTML Input Library.
 ; See %wful for the module's primary-development log.
 ; See %wf for the module's ppis & apis.
 ; %wfuthi contains no public entry points.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2018, toad, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-06T20:00Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Web Form - %wf
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@contents
 ; [all unit tests]
 ;
 ;@called-by
 ; M-Unit
 ;  EN^%ut (called by ^%wfut)
 ;  COVERAGE^%ut (called by cover^%wfut)
 ;@calls
 ; CHKEQ^%ut
 ;
 ;
 ;
 ;@section 1 unit tests for $$type^%wf
 ;
 ;
 ;
 ;@calls
 ; $$type^%wf
 ;
 ;
 ;
type01 ; @TEST $$type^%wf: html compliant
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new line set line="<input type=""radio"">"
 new result set result="radio"
 do CHKEQ^%ut($$type^%wf(line),result)
 ;
 quit  ; end of type01
 ;
 ;
 ;
type02 ; @TEST $$type^%wf: nonstandard variant
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new line set line="<input type=radio>"
 new result set result="radio"
 do CHKEQ^%ut($$type^%wf(line),result)
 ;
 quit  ; end of type02
 ;
 ;
 ;
type03 ; @TEST $$type^%wf: no input tag
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new line set line="type=""radio"""
 new result set result=""
 do CHKEQ^%ut($$type^%wf(line),result)
 ;
 quit  ; end of type03
 ;
 ;
 ;
type04 ; @TEST $$type^%wf: no type attribute
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new line set line="<input>"
 new result set result=""
 do CHKEQ^%ut($$type^%wf(line),result)
 ;
 quit  ; end of type04
 ;
 ;
 ;
type05 ; @TEST $$type^%wf: nonstandard type value
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new line set line="<input type=""faketype"">"
 new result set result="faketype"
 do CHKEQ^%ut($$type^%wf(line),result)
 ;
 quit  ; end of type05
 ;
 ;
 ;
type06 ; @TEST $$type^%wf: nonsense around input tag
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new line set line="nonsense<input type=""button"">nonsense"
 new result set result="button"
 do CHKEQ^%ut($$type^%wf(line),result)
 ;
 quit  ; end of type06
 ;
 ;
 ;
type07 ; @TEST $$type^%wf: case-insensitive
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new line set line="<Input TYPE=""rAdIo"">"
 new result set result="radio"
 do CHKEQ^%ut($$type^%wf(line),result)
 ;
 quit  ; end of type07
 ;
 ;
 ;
type08 ; @TEST $$type^%wf: empty string
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new line set line=""
 new result set result=""
 do CHKEQ^%ut($$type^%wf(line),result)
 ;
 quit  ; end of type08
 ;
 ;
 ;
type09 ; @TEST $$type^%wf: undefined
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new line
 new result set result=""
 do CHKEQ^%ut($$type^%wf(.line),result)
 ;
 quit  ; end of type09
 ;
 ;
 ;
 ;@section 2 unit tests for uncheck^%wf
 ;
 ;
 ;
 ;@calls
 ; uncheck^%wf
 ;
 ;
 ;
unchk01 ; @TEST uncheck^%wf: html compliant
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 set before="<input type=radio name=""sbhcs"" value=""n"" checked> no"
 new after
 set after="<input type=radio name=""sbhcs"" value=""n""> no"
 new line set line=before
 ;
 do uncheck^%wf(.line)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of unchk01
 ;
 ;
 ;
unchk02 ; @TEST uncheck^%wf: uppercase CHECKED
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 set before="<input type=radio name=""sbphu"" value=""i"" CHECKED> in"
 new after
 set after="<input type=radio name=""sbphu"" value=""i""> in"
 new line set line=before
 ;
 do uncheck^%wf(.line)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of unchk02
 ;
 ;
 ;
unchk03 ; @TEST uncheck^%wf: not checked
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 set before="<input type=radio name=""sbphu"" value=""c""> cm"
 new after
 set after="<input type=radio name=""sbphu"" value=""c""> cm"
 new line set line=before
 ;
 do uncheck^%wf(.line)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of unchk03
 ;
 ;
 ;
unchk04 ; @TEST uncheck^%wf: nonstandard variant 1
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 set before="<input type=""radio"" name=""sbmpa"" value=""n"" checked=""checked"">no</input>"
 new after
 set after="<input type=""radio"" name=""sbmpa"" value=""n"">no</input>"
 new line set line=before
 ;
 do uncheck^%wf(.line)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of unchk04
 ;
 ;
 ;
unchk05 ; @TEST uncheck^%wf: nonstandard variant 2
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 set before="<input type=""radio"" name=""sbmpmi"" value=""n"" checked=checked>no</input>"
 new after
 set after="<input type=""radio"" name=""sbmpmi"" value=""n"">no</input>"
 new line set line=before
 ;
 do uncheck^%wf(.line)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of unchk05
 ;
 ;
 ;
unchk06 ; @TEST uncheck^%wf: empty string
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before set before=""
 new after set after=""
 new line set line=before
 ;
 do uncheck^%wf(.line)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of unchk06
 ;
 ;
 ;
unchk07 ; @TEST uncheck^%wf: undefined
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 new after set after=""
 new line
 ;
 do uncheck^%wf(.line)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of unchk07
 ;
 ;
 ;
 ;@section 3 unit tests for check^%wf
 ;
 ;
 ;
 ;@calls
 ; check^%wf
 ;
 ;
 ;
chk01 ; @TEST check^%wf: html compliant
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 set before="<input type=""radio"" name=""sbdsd"" id=""sbdsd-n"" value=""n""> No"
 new after
 set after="<input type=""radio"" checked name=""sbdsd"" id=""sbdsd-n"" value=""n""> No"
 new line set line=before
 new type set type="radio"
 ;
 do check^%wf(.line,type)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of chk01
 ;
 ;
 ;
chk02 ; @TEST check^%wf: nonstandard variant
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 set before="<input type=radio name=""sbphu"" value=""c""> cm"
 new after
 set after="<input type=""radio"" checked name=""sbphu"" value=""c""> cm"
 new line set line=before
 new type set type="radio"
 ;
 do check^%wf(.line,type)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of chk02
 ;
 ;
 ;
chk03 ; @TEST check^%wf: case-insensitive
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 set before="<input TYPE=checkbox name=""sbshsua"" value=""a""> cigars"
 new after
 set after="<input type=""checkbox"" checked name=""sbshsua"" value=""a""> cigars"
 new line set line=before
 new type set type="checkbox"
 ;
 do check^%wf(.line,type)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of chk03
 ;
 ;
 ;
chk04 ; @TEST check^%wf: no type attribute
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before set before="<html lang=""en"">"
 new after set after="<html lang=""en"">"
 new line set line=before
 new type set type=""
 ;
 do check^%wf(.line,type)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of chk04
 ;
 ;
 ;
chk05 ; @TEST check^%wf: empty string
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before set before=""
 new after set after=""
 new line set line=before
 ;
 do check^%wf(.line)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of chk05
 ;
 ;
 ;
chk06 ; @TEST check^%wf: undefined
 ;
 ;ven/toad;test;procedure;clean?;silent?;sac
 ;
 new before
 new after set after=""
 new line
 ;
 do check^%wf(.line)
 do CHKEQ^%ut(line,after)
 ;
 quit  ; end of chk06
 ;
 ;
 ;
eor ; end of routine %wfuthi

%yottagr
yottagr ;ven/gpl-yottadb extension: graphstore ;2018-03-11T22:31Z
 ;;1.8;Mash;
 ;
 ; %yottagr implements the Yottadb Extension Library's graphstore
 ; ppis & apis. These may eventually migrate to another Mash
 ; namespace, tbd. In the meantime, they will get a %yotta ppi &
 ; api library built.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-03-11T22:31Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Yottadb Extension - %yotta
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@module-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-02-17 ven/gpl %*1.8t01 %yottagr: create routine to hold
 ; all yottadb graph methods.
 ;
 ; 2017-09-16 ven/gpl %*1.8t01 %yottagr: update
 ;
 ; 2017-09-18 ven/gpl %*1.8t01 %yottagr: update
 ;
 ; 2017-10-07 ven/gpl %*1.8t01 %yottagr: update
 ;
 ; 2018-02-07/11 ven/toad %*1.8t04 %yottagr: passim add white space &
 ; hdr comments & do-dot quits, tag w/Apache license & attribution
 ; & to-do to shift namespace later, break up a few long line. debug.
 ;
 ; 2018-03-10/11 ven/toad %*1.8t04 %yottagr: fix $namew typo.
 ;
 ;@to-do
 ; %yotta: create entry points in ppi/api style
 ; r/all local calls w/calls through ^%yotta
 ; break up into smaller routines & change branches from %yotta
 ; renamespace elsewhere, research best choice
 ;
 ;@contents
 ; [too big, break up]
 ;
 ;
 ;
 ;@section 1 code to implement ppis & apis
 ;
 ;
 ;
setroot(graph) ; root of working storage
 ;
 if '$data(graph) set graph="seeGraph"
 new %y set %y=$order(^%wd(17.040801,"B",graph,""))
 if %y="" set %y=$$addgraph(graph) ; if graph is not present, add it
 ;
 quit $na(^%wd(17.040801,%y)) ; root for graph ; end of $$setroot
 ;
 ;
 ;
addgraph(graph) ; makes a place in the graph file for a new graph
 ;
 new fda set fda(17.040801,"?+1,",.01)=graph
 new %yerr
 do UPDATE^DIE("","fda","","%yerr")
 new %y set %y=$order(^%wd(17.040801,"B",graph,""))
 ;
 quit %y ; end of $$addgraph
 ;
 ;
 ;
homedir() ; extrinsic which return the document home
 ;
 new kbaihd set kbaihd=$get(^%WHOME)
 if kbaihd="" do  break  ;
 . write !,"error, home directory not set"
 . quit
 if $extract(kbaihd,$length(kbaihd))="/" do
 . set kbaihd=$extract(kbaihd,1,$length(kbaihd)-1)
 . quit
 ;
 quit kbaihd ; end of $$homedir
 ;
 ;
 ;
build ; retrieve directory structure and build into xtmp
 ;
 new kbairoot
 set kbairoot=$$setroot()
 ;
 ; kill @kbairoot
 ; if '$data(@kbairoot@(0)) do  quit  ; work area doesn't exist
 ; . write !,"error, work area not found ",kbairoot
 ; . quit
 ; . new X,Y
 ; . set X="T+999" ; a long time from now
 ; . do ^%DT ; covert to fm date format
 ; . set @kbairoot@(0)=Y_"^"_$$NOW^XLFDT_"^kbaiwsai graph"
 ; . quit
 ;
 zsystem "ls -DRL --file-type ~/www > ~/www/dirconfig.txt"
 new zdir set zdir=^%WHOME
 new kbails,kbails1,ok
 set kbails=$na(@kbairoot@("ls"))
 set kbails1=$name(@kbails@(1))
 set ok=$$FTG^%ZISH(zdir,"dirconfig.txt",kbails1,4)
 do bldgraph
 ;
 quit  ; end of build
 ;
 ;
 ;
bldgraph ; build the graph in xtmp
 ;
 new kbairoot set kbairoot=$$setroot()
 new hmdir set hmdir=$$homedir()
 new groot set groot=$name(@kbairoot@("graph"))
 ; kill @groot
 new gsrc set gsrc=$name(@kbairoot@("ls"))
 new zi,zj,zln,zien,zien2,uriary,distdir,localdir
 set distdir="root"  ;
 set zien=0
 set zien2=0 ; subfile ien
 set zi=0
 new %cnt set %cnt=0
 for  set zi=$order(@gsrc@(zi)) quit:+zi=0  do  ;
 . new zln,zdir,zpar,ztag
 . set zln=@gsrc@(zi)
 . quit:zln=""
 . if zln[":" do  quit  ;
 . . set %cnt=%cnt+1
 . . ; if %cnt>100000 do counts(groot) set %cnt=1 ; this is for watching progress on big builds
 . . set zien=zien+1
 . . if $extract(zln,$length(zln))=":" set zln=$extract(zln,1,$length(zln)-1) ; strip off the :
 . . if $get(distdir)="" set distdir="root"  ;
 . . set @groot@(zien,"parent",distdir)=""
 . . set @groot@("pos","parent",distdir,zien)=""
 . . set @groot@("ops",distdir,"parent",zien)=""
 . . set localdir=zln
 . . set @groot@(zien,"localdir",localdir)=""
 . . set @groot@("pos","localdir",localdir,zien)=""
 . . set @groot@("ops",localdir,"localdir",zien)=""
 . . ; set graph type
 . . set @groot@(zien,"type","directory")=""
 . . set @groot@("pos","type","directory",zien)=""
 . . set @groot@("ops","directory","type",zien)=""
 . . set distdir=$piece(localdir,$$homedir,2)
 . . if distdir'="" do  ;
 . . . set @groot@(zien,"distdir",distdir)=""
 . . . set @groot@("pos","distdir",distdir,zien)=""
 . . . set @groot@("ops",distdir,"distdir",zien)=""
 . . . set @groot@(zien,"id",distdir)=""
 . . . set @groot@("pos","id",distdir,zien)=""
 . . . set @groot@("ops",distdir,"id",zien)=""
 . . . kill uriary do deuri(distdir,"uriary")
 . . . quit
 . . set zien2=0
 . . quit
 . ; process file names as a subfile to the directory
 . set zien2=zien2+1
 . ; set parent pointer
 . if $get(distdir)="" set distdir="root"  ;
 . set @groot@(zien,zien2,"parent",distdir)=""
 . set @groot@("pos","parent",distdir,zien,zien2)=""
 . set @groot@("ops",distdir,"parent",zien,zien2)=""
 . ; set file name attribute
 . set @groot@(zien,zien2,"file",zln)=""
 . set @groot@("pos","file",zln,zien,zien2)=""
 . set @groot@("ops",zln,"file",zien,zien2)=""
 . ; tag the file name
 . set @groot@(zien,zien2,"tag",zln)=""
 . set @groot@("pos","tag",zln,zien,zien2)=""
 . set @groot@("ops",zln,"tag",zien,zien2)=""
 . ; added to tag qrda cqm names
 . if $extract(zln,1,3)="CMS" do  ;
 . . new cqm
 . . set cqm=$piece(zln,"_",1)
 . . do addtag(cqm,zien,zien2)
 . . quit
 . ;
 . ; set the file id
 . new zid set zid=distdir_"/"_zln
 . if distdir="root" set zid=zln
 . set @groot@(zien,zien2,"id",zid)=""
 . set @groot@("pos","id",zid,zien,zien2)=""
 . set @groot@("ops",zid,"id",zien,zien2)=""
 . new ztyp ; graph type
 . if $extract(zln,$length(zln))="/" set ztyp="directory"
 . else  set ztyp="file"
 . set @groot@(zien,zien2,"type",ztyp)=""
 . set @groot@("pos","type",ztyp,zien,zien2)=""
 . set @groot@("ops",ztyp,"type",zien,zien2)=""
 . new zftyp
 . set zftyp=$reverse($piece($reverse(zln),".",1))
 . if zftyp'="" do  ;
 . . set @groot@(zien,zien2,"filetype",zftyp)=""
 . . set @groot@("pos","filetype",zftyp,zien,zien2)=""
 . . set @groot@("ops",zftyp,"filetype",zien,zien2)=""
 . . set @groot@(zien,zien2,"tag",zftyp)=""
 . . set @groot@("pos","tag",zftyp,zien,zien2)=""
 . . set @groot@("ops",zftyp,"tag",zien,zien2)=""
 . . ; tag the name without the filetype
 . . new zfn2
 . . set zfn2=$reverse($piece($reverse(zln),$reverse(zftyp)_".",2))
 . . if zfn2'="" do  ;
 . . . set @groot@(zien,zien2,"tag",zfn2)=""
 . . . set @groot@("pos","tag",zfn2,zien,zien2)=""
 . . . set @groot@("ops",zfn2,"tag",zien,zien2)=""
 . . . new contents
 . . . if zftyp["xml" do  ;
 . . . . do scan(.contents,zid,zien,zien2) ; not scanning right now
 . . . . quit
 . . . quit
 . . quit
 . set @groot@(zien,zien2,"localdir",localdir)=""
 . set @groot@("pos","localdir",localdir,zien,zien2)=""
 . set @groot@("ops",localdir,"localdir",zien,zien2)=""
 . if $get(distdir)'="" do  ;
 . . set @groot@(zien,zien2,"distdir",distdir)=""
 . . set @groot@("pos","distdir",distdir,zien,zien2)=""
 . . set @groot@("ops",distdir,"distdir",zien,zien2)=""
 . . quit
 . ; add the tags from the directory
 . new zj set zj=""
 . for  set zj=$order(uriary(zj)) quit:zj=""  do  ;
 . . set @groot@(zien,zien2,"tag",uriary(zj))=""
 . . set @groot@("pos","tag",uriary(zj),zien,zien2)=""
 . . set @groot@("ops",uriary(zj),"tag",zien,zien2)=""
 . . quit
 . ; if zien=3344 break
 . quit
 ; compute the counts
 do counts(groot) ;
 ;
 quit  ; end of bldgraph
 ;
 ;
 ;
counts(groot) ;
 ;
 new ztag,zary,zcnt
 kill @groot@("countbytag")
 kill @groot@("tagbycount")
 set ztag=""
 for  set ztag=$order(@groot@("pos","tag",ztag)) quit:ztag=""  do  ;
 . if ztag="" quit  ;
 . kill zary
 . do match("#tag:"_ztag,"zary")
 . ; write !,ztag," ",$data(zary)
 . set zcnt=$$count("zary")
 . if zcnt<1 quit  ;
 . set @groot@("countbytag",ztag,zcnt)=""
 . set @groot@("tagbycount",zcnt,ztag)=""
 . quit
 ;
 quit  ; end of counts
 ;
 ;
 ;
testscan ;
 ;
 set zien=4
 set zien2=1
 ; set zid=$order(^xtmp("kbaiweb","graph",4,1,"id",""))
 set zid=$order(@$$setroot@("graph",4,1,"id",""))
 do scan(.g,zid,zien,zien2)
 ;
 quit  ; end of testscan
 ;
 ;
 ;
scan(rtn,zid,zien,zien2) ; scan the file contents for new tags
 ;
 ; and add them to the graph
 ;
 new zcmd,tmpfile,tmpdir,cmdfile
 set tmpfile="scan.txt"
 set cmdfile="scan.sh"
 set tmpdir=^%WHOME
 set zcmd=$name(^tmp("kbaicmd",$job))
 set zcmd1=$name(@zcmd@(1))
 set @zcmd@(1)="rm "_tmpdir_"/"_tmpfile
 new g2 set g2=""
 for i=1:1:$length(zid) set g2=g2_$select($extract(zid,i)=" ":"\ ",1:$extract(zid,i))
 ; set @zcmd@(2)="grep code "_tmpdir_"/"_zid_" > "_tmpdir_"/"_tmpfile
 set @zcmd@(2)="grep code "_tmpdir_g2_" > "_tmpdir_tmpfile
 ; set @zcmd@(3)="grep originaltext "_tmpdir_"/"_zid_" >> "_tmpdir_"/"_tmpfile
 set @zcmd@(3)="grep originaltext "_tmpdir_g2_" >> "_tmpdir_tmpfile
 new ok
 set ok=$$GTF^%ZISH(zcmd1,3,tmpdir,cmdfile)
 zsystem "bash ../www/scan.sh"
 new where set where=$name(^tmp("kbaiscan",$job))
 kill @where
 new where1 set where1=$name(@where@(1))
 set ok=$$FTG^%ZISH(tmpdir,tmpfile,where1,3)
 if ok do  ;
 . new zi set zi=0
 . for  set zi=$order(@where@(zi)) quit:+zi=0  do  ;
 . . new zl set zl=@where@(zi)
 . . if zl["code" do  ;
 . . . new code
 . . . set code=$piece($piece(zl,"code=""",2),""" ")
 . . . if code[">" quit  ;
 . . . if code["""" quit  ;
 . . . ; break
 . . . new name
 . . . set name=$piece($piece(zl,"displayName=""",2),"""")
 . . . if name["[&quot;" set name=$piece($piece(name,"[&quot;",2),"&quot;]")
 . . . if name="" do  ;
 . . . . if zl["<originalText" do  ;
 . . . . . set name=$piece($piece(zl,"<originalText>",2),"</originalText>")
 . . . . . quit
 . . . . quit
 . . . quit:code=""
 . . . do addtag(code_" "_name,zien,zien2)
 . . . ; do addtag(code,zien,zien2)
 . . . quit
 . . quit
 . quit
 ;
 ; zwrite ^tmp("kbaiscan",$job,*)
 ;
 quit  ; end of scan
 ;
 ;
 ;
addtag(tag,zien,zien2) ; add a tag to a graph
 ;
 ; write !,"adding ",tag," at ",zien," ",zien2 
 ;
 new gn set gn=$na(@$$setroot@("graph"))
 set @gn@(zien,zien2,"tag",tag)=""
 set @gn@("pos","tag",tag,zien,zien2)=""
 set @gn@("ops",tag,"tag",zien,zien2)=""
 ; zwrite @$$setroot@("graph",:,:,tag,zien,zien2)
 ;
 quit  ; end of addtag
 ;
 ;
 ;
wssee(rtn,filter) ; web service for browsing files using the graph
 ;
 merge ^gpl("filter")=filter
 new arg set arg=$get(filter("*"))
 if arg="" do toppage^%yottahtm(.rtn,.filter) quit  ;
 ;
 ; if arg="@rewrite" do rewrite(.rtn) quit  ;
 ;
 if arg]"%" set arg=$$URLDEC^VPRJRUT(arg)
 new ptrary ; pointer array for result
 new groot set groot=$name(@$$setroot@("graph"))
 ;
 ; if $$lookup(arg,"id",.ptrary)= do  quit  ; id arg is found
 ; . if $$count(.ptrary)=1 do  ; just one match
 ; . . ;
 ; . . quit
 ; . quit
 ; if $order(@$$setroot@("graph","pos","id","/"_arg,""))'="" do  quit  ;
 ; if $order(@groot@("pos","id","/"_arg,""))'="",arg'="ehmp" do  quit  ;
 ;
 if $order(@groot@("pos","id","/"_arg,""))'="" do  quit  ;
 . ; new zdest set zdest="/"_arg
 . ; if $$stat(arg)'["regular file" set zdest=$$locate(arg)
 . ; if zdest'=arg set filter("*")=zdest
 . if $extract(arg,$length(arg))="/" do dir(.rtn,arg) quit  ; it's a directory
 . ; if $reverse($piece($reverse(arg),"."))="xml" do style(.rtn,arg) quit  ;
 . if $reverse($piece($reverse(arg),"."))="xml" do  quit  ;
 . . do style(.rtn,arg)
 . . do ADDCRLF^VPRJRUT(.rtn)
 . . quit
 . set filter("*")=arg
 . do FILESYS^%W0(.rtn,.filter)
 . quit
 ;
 ; request is not an id in the graph, so try and find the file if any
 new zf,zuri
 set zuri=$$useuri($$isfile(arg),arg)
 if zuri=-1 set zuri=$$useuri($$altfile($$isfile(arg)),arg)
 if zuri'=-1 do  quit  ;
 . if $reverse($piece($reverse(zuri),"."))="xml" do  quit  ;
 . . do style(.rtn,zuri)
 . . do ADDCRLF^VPRJRUT(.rtn)
 . . quit
 . set filter("*")=zuri
 . do FILESYS^%W0(.rtn,.filter)
 . quit
 ;
 ; set zf=$$isfile(arg)
 ; if zf'=-1 set zuri=$$useuri(zf) ;
 ; else  do  ;
 ; . set zf=$$altfile(zf)
 ; . if zf'=-1 set zuri=$$useuri(zf)
 ; . quit
 ; if zuri'=1 do  quit  ;
 ; . set filter("*")=zuri
 ; . do FILESYS^%W0(.rtn,.filter)
 ; . quit
 ;
 new matches
 ;
 ; if arg["%20" s arg=$translate(arg,"%20"," ")
 ;
 do match("#"_arg,"matches")
 ;
 ; merge ^gpl("matches")=matches
 ; if $data(matches) set rtn=$query(matches)
 ;
 if $$count("matches")>0 do  quit  ; more than one match
 . do multout(.rtn,"matches")
 . quit
 ;
 quit  ; end of wssee
 ;
 ;
 ;
style(rtn,zuri) ;
 ;
 new gn set gn=$name(^tmp("kbaiout",$job))
 new gn1 set gn1=$name(@gn@(1))
 kill @gn
 new ok
 set ok=$$FTG^%ZISH($$dirpart(zuri),$$isfile(zuri),gn1,3)
 if 'ok do  quit  ;
 . ; break
 . set filter("*")=zuri
 . do FILESYS^%W0(.rtn,.filter)
 . quit
 set HTTPRSP("mime")="text/xml"
 ;
 ; new gt1
 ; set gt1="<?xml-stylesheet type=""text/xsl"" href=""/resources/css/cda.xslt""?>"
 ; if $get(@gn@(1))["?>" do  ;
 ; . new gt set gt=$piece(@gn@(1),"?>",1)_"?>"_gt1_$piece(@gn@(1),"?>",2)
 ; . set @gn@(1)=gt
 ; . quit
 ; set @gn@(1)=@gn@(1)_"<?xml-stylesheet type=""text/xml"" href=""/resources/css/cda.xsl""?>"
 ;
 set @gn@(1.5)="<?xml-stylesheet type=""text/xml"" href=""/resources/css/cda.xsl""?>"
 set rtn=gn
 ;
 quit  ; end of style
 ;
 ;
 ;
parent(zarg) ; extrinsic which returns the parent of the zarg
 ;
 new groot set groot=$name(@$$setroot@("graph"))
 new zien
 set zien=$order(@groot@("pos","id","/"_zarg,""))
 if zien="" quit ""
 ;
 quit $order(@groot@(zien,"parent",""))
 ;
 ;
 ;
isfile(zarg) ; extrinsic to return the file name from a uri
 ;
 ; -1 if it's not a file
 ;
 new rslt
 set rslt=$reverse($piece($reverse(zarg),"/"))
 if rslt="" set rslt=-1
 ;
 quit rslt ; end of $$isFile
 ;
 ;
 ;
dirpart(zuri) ; extrinsic which returns the directory part of the file uri
 ;
 new rslt
 set rslt=$piece(zuri,$$isfile(zuri),1)
 if rslt="" set rslt=-1
 ;
 quit ^%WHOME_rslt ; end of $$dirpart
 ;
 ;
 ;
altfile(zfile) ; extrinsic which tries to take the version number out of
 ;
 ; the filename ie jasmine-1.3.1.js becomes jasmine.js
 ;
 new z1,z2,z3,z4,z5
 set z1=$reverse(zfile) ; sj.1.3.1-enimsaj
 set z2=$piece(z1,".",4) ; 1-enimsaj
 ; write:$get(debug) !,"z2=",z2
 ; set z3=$piece(z2,"-",2) ; enimsaj
 set z3=$extract(z2,3,$length(z2))
 ; write:$get(debug) !,"z3=",z3,!
 set z4="."_$reverse($piece(z1,".",1)) ; .js
 ; write:$get(debug) !,"z4=",z4,!
 set z5=$reverse(z3)_z4
 ;
 quit z5 ; end of $$altfile
 ;
 ;
 ;
useuri(zfile,zarg) ; extrinsic which returns the uri to use for a filename
 ;
 ; -1 if none found
 ;
 new z1,z2,groot,zr
 set groot=$name(@$$setroot@("graph"))
 set z1=$order(@groot@("pos","file",zfile,""))
 if z1="" quit -1
 set z2=$order(@groot@("pos","file",zfile,z1,""))
 set zr=$order(@groot@(z1,z2,"id",""))
 if zr="" set zr=-1
 ; if zr'=-1 do logrewr(zarg,zr)
 ;
 quit zr ; end of $$useuri
 ;
 ;
 ;
multout(rtn,zary,title) ; return and html page with multiple selections
 ;
 ; zary is passed by name and is usually a "match" array
 ;
 do  ;
 . set rtn=$name(^tmp("kbaiwsai",$j))
 . kill @rtn
 . new gtop,gbot
 . do htmltb2^%yottaweb(.gtop,.gbot,"search results for #"_arg)
 . merge @rtn=gtop
 . if $data(title) do addto^%yottautl(rtn,"<p>"_title_"</p>")
 . do addto^%yottautl(rtn,"<ul>")
 . new zcnt,zstop set (zcnt,zstop)=0
 . new zi set zi=zary
 . for  set zi=$query(@zi) quit:((zi="")!(zstop))  do  ;
 . . set zcnt=zcnt+1
 . . if zcnt>1000 set zstop=1
 . . new zptr set zptr=$$fmtptr(zi)
 . . new zd,zf,zref
 . . set zd=$order(@zptr@("localdir",""))
 . . set zd=$piece(zd,$$homedir,2)
 . . ; if $extract(zd,$length(zd))="/" do  quit  ; it's a directory
 . . set zf=$order(@zptr@("file",""))
 . . set zref="<a href=""/see"_zd_"/"_zf_""">"_zd_"/"_zf_"</a>"
 . . do addto^%yottautl(rtn,"<li>"_zref_"</li>")
 . . quit
 . do addto^%yottautl(rtn,"</ul>")
 . kill @rtn@(0)
 . set HTTPRSP("mime")="text/html"
 . set @rtn@($order(@rtn@(""),-1)+1)=gbot
 . quit
 ;
 ; if $extract(arg,$length(arg))="/" do  quit  ; it's a directory
 ; . set rtn="it's a directory"
 ; . quit
 ; do FILESYS^%W0(.rtn,.filter)
 ;
 quit  ; end of multout
 ;
 ;
 ;
dir(rtn,zpar)
 ;
 new zi,dirary
 new groot set groot=$name(@$$setroot@("graph"))
 new adj set adj="/"_$extract(zpar,1,$length(zpar)-1)
 merge dirary=@groot@("pos","parent",adj)
 ; set dirary("up")=$get(@groot@("
 ; break
 if '$data(dirary) quit  ;
 do multout(.rtn,"dirary")
 ;
 quit  ; end of dir
 ;
 ;
 ;
deuri(in,out) ; deconstruct a uri. in passed by value out passed by name
 ;
 new zzi
 for zzi=2:1:$length(in,"/") set @out@(zzi-1)=$piece(in,"/",zzi)
 ;
 quit  ; end of deuri
 ;
 ;
 ;
reuri(in) ; extrinsic which reconstructs a uri from an array
 ;
 quit  ; end of reuri
 ;
 ;
 ;
repar(in) ; extrinsic which reconstructs a parent uri from an array
 ;
 quit  ; end of repar
 ;
 ;
 ;
show(zien,zien2) ;
 ;
 if $get(zien)="" set zien=1
 if $get(zien2)="" zwrite @$$setroot@("graph",zien,*) quit  ;
 zwrite @$$setroot@("graph",zien,zien2,*)
 ;
 quit  ; end of show
 ;
 ;
 ;
fmtptr(inref) ; extrinsic forms a closed global reference to the graph
 ;
 ; inref is passed by value and looks like g(2897,3)
 ; returns ^xtmp("kbaiweb","graph",3297,3) based on setroot
 ;
 new %1,%2 set %1=$name(@$$setroot@("graph"))
 set %1=$piece(%1,")",1)
 set %2=$piece(inref,"(",2)
 ;
 quit %1_","_%2 ; end of fmtptr
 ;
 ;
 ;
gshow(inary) ; show the location and file names pointed to by inary
 ;
 ; inary is passed by name
 ;
 new %
 new z1 set z1=inary
 for  set z1=$query(@z1) quit:z1=""  do  ;
 . new z2,z3
 . set %=$$fmtptr(z1)
 . set z2=$name(@%@("file"))
 . write !,z2,"   ",$order(@z2@(""))
 . set z3=$name(@%@("distdir"))
 . write !,"   ",$order(@z3@(""))
 . quit
 ;
 quit  ; end of gshow
 ;
 ;
 ;
match(input,outary) ; extrinsic which returns the count of matches, 0 if none
 ;
 ; input is a string eg.. #ehmp#applets.
 ; outary is passed by name and returns
 ; the iens of the graph elements that match
 ; ie.. outary(1,2)="" and outary(3)
 ;
 new po ; predicate object array
 do hashpars(input,"po")
 if '$data(po) quit 0 ;
 new groot set groot=$$setroot()
 new posroot set posroot=$name(@groot@("graph","pos"))
 if $order(po(""),-1)=1 do  quit  ; $$count(outary)
 . ; only one hash tag to search for
 . new pred,obj
 . set pred=$order(po(1,""))
 . set obj=$order(po(1,pred,""))
 . if '$data(@posroot@(pred,obj)),$data(@posroot@(pred,obj_" ")) do
 . . set obj=obj_" "
 . . quit
 . if $order(@posroot@(pred,obj,""))="" quit  ;
 . kill @outary
 . merge @outary=@posroot@(pred,obj)
 . quit
 ;
 quit  ; end of match
 ;
 ;
 ;
count(ary) ; count the number of entries in the array ary pased by name
 ;
 new zcnt set zcnt=0
 if '$data(@ary) quit zcnt
 new % set %=ary
 for  set %=$query(@%) quit:%=""  set zcnt=zcnt+1
 ;
 quit zcnt ; end of $$count
 ;
 ;
 ;
recount ; recount the tags
 ;
 new groot set groot=$$setroot
 set groot=$name(@groot@("graph"))
 do counts(groot)
 ;
 quit  ; end of recount
 ;
 ;
 ;
hashpars(input,pairs)
 ;
 new kbaii
 if input'["#" quit  ;
 for kbaii=2:1:$length(input,"#") do  ;
 . new zp,zo,pred
 . set zp=$piece(input,"#",kbaii)
 . set pred="tag"
 . set zo=zp
 . if zp[":" do  ;
 . . set pred=$piece(zp,":",1)
 . . set zo=$extract(zp,$find(zp,":"),$length(zp))
 . . if zo["%" set zo=$$URLDEC^VPRJRUT(.zo)
 . . ; write !,zo
 . . ; set zo=$piece(zp,":",2)
 . . quit
 . if $get(pred)="" quit  ;
 . if $get(zo)="" quit  ;
 . set @pairs@(kbaii-1,pred,zo)=""
 . quit
 ;
 quit  ; end of hashpars
 ;
 ;
 ;
stat(zf) ;
 ;
 new zstat,zcmd,zwhere
 set zcmd="""stat --format %f "_zf_" >./stat.txt"""
 zsystem @zcmd
 set zwhere=$name(^tmp("kbaiweb","stat",1))
 new zok set zok=$$FTG^%ZISH("./","stat.txt",zwhere,3)
 ;
 quit @zwhere ; end of $$stat
 ;
 ;
 ;
locate(zarg) ;
 ;
 quit zarg ; end of $$locate
 ;
 ;
 ;
logrewr(from,to) ; log uri rewrite
 ;
 new dt,id,ln
 set dt=httplog("dt"),id=httplog("id")
 set ln=$g(^vprhttp("log",dt,$job,id,"rewrite","from"),0)+1
 set ^vprhttp("log",dt,$job,id,"rewrite","from",0)=ln
 set ^vprhttp("log",dt,$job,id,"rewrite",ln,"from")=$get(from)
 set ^vprhttp("log",dt,$job,id,"rewrite",ln,"to")=$get(to)
 ;
 quit  ; end of logrewr
 ;
 ;
 ;
rewrite(rtn) ; show all the rewrites in the log
 ;
 new zr,zrary
 new gtop,gbot
 do htmltb^%yottaweb(.gtop,.gbot,"search results for #"_arg)
 merge @rtn=gtop
 do addto^%yottautl(rtn,"<h1>items not found</h1>") 
 set zr=$name(^vprhttp("log"))
 for  set zr=$query(@zr) quit:zr=""  do  ;
 . if zr'["rewrite" quit  ;
 . if zr'["from" quit  ;
 . ; write !,zr
 . if $length(@zr)=1 quit  ; the count
 . new title set title="not found - "_@zr
 . do match(@zr,"zrary")
 . do addto^%yottautl(rtn,"<p>"_@zr_"</p>")
 . ; do multout(.rtn,"zrary",title)
 . quit
 kill @rtn@(0)
 set HTTPRSP("mime")="text/html"
 set @rtn@($order(@rtn@(""),-1)+1)=gbot
 ;
 quit  ; end of rewrite
 ;
 ;
 ;
eor ; end of routine %yottagr

%yottahtm
%yottahtm ;ven/gpl-yottadb extension: graphstore ;2018-02-07T19:33Z
 ;;1.8;Mash;
 ;
 ; %yottahtm implements the Yottadb Extension Library's toppage
 ; ppi. This may eventually migrate to another Mash namespace,
 ; tbd. In the meantime, it will be added to a new %yotta ppi
 ; library.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-02-07T19:33Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Yottadb Extension - %yotta
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@module-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-02-27 ven/gpl %*1.8t01 %yottahtm: create routine to hold
 ; the yottadb toppage method.
 ;
 ; 2017-09-16 ven/gpl %*1.8t01 %yottahtm: update
 ;
 ; 2017-09-12 ven/gpl %*1.8t01 %yottahtm: update
 ;
 ; 2017-09-18 ven/gpl %*1.8t01 %yottahtm: update
 ;
 ; 2018-02-07 ven/toad %*1.8t04 %yottahtm: passim add white space &
 ; hdr comments & do-dot quits, tag w/Apache license & attribution
 ; & to-do to shift namespace later, break up a few long lines.
 ;
 ;@to-do
 ; %yotta: create entry points in ppi/api style
 ; r/all local calls w/calls through ^%yotta
 ; change branches from %yotta
 ; renamespace elsewhere, research best choice
 ;
 ;@contents
 ; toppage: build the starting page of hashtag counts
 ;
 ;
 ;
 ;@section 1 code to implement ppis & apis
 ;
 ;
 ;
toppage(rtn,filter) ; build the starting page of hashtag counts
 ;
 new kbaii,gtop,gbot,table,groot,zcnt
 do htmltb2^%yottaweb(.gtop,.gbot,"#see query engine")
 set rtn=$name(^tmp("kbaiwsai",$job))
 kill @rtn
 merge @rtn=gtop
 set groot=$name(@$$setroot^%yottagr@("graph"))
 set table("title")="tags by count"
 set table("header",1)="tag"
 set table("header",2)="tag count"
 set kbaii="" set zcnt=0
 new k2
 for  set kbaii=$order(@groot@("tagbycount",kbaii),-1) quit:kbaii=""  do  ;
 . set k2=""
 . for  set k2=$order(@groot@("tagbycount",kbaii,k2)) quit:k2=""  do  ;
 . . new ztag
 . . set ztag=k2
 . . set zcnt=zcnt+1
 . . if zcnt>2000 quit  ; max rows
 . . set table(zcnt,1)="<a href=""see/tag:"_ztag_""">"_"#"_ztag_"</a>"
 . . set table(zcnt,2)=kbaii
 . . quit
 . quit
 do genhtml^%yottautl(rtn,"table")
 kill @rtn@(0)
 set HTTPRSP("mime")="text/html"
 set @rtn@($order(@rtn@(""),-1)+1)=gbot
 ;
 quit  ; end of toppage
 ;
 ;
 ;
eor ; end of routine %yottahtm

%yottaq
yottaq  ;ven/gpl-yottadb extension: query ;2018-02-07T21:11Z
 ;;1.8;Mash;
 ;
 ; %yottaq implements the Yottadb Extension Library's query
 ; ppis & apis. This may eventually migrate to another Mash namespace,
 ; tbd. In the meantime, it will be added to a new %yotta ppi
 ; library.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-02-07T21:11Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Yottadb Extension - %yotta
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@module-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-09-18 ven/gpl %*1.8t01 %yottaq: create routine to hold
 ; the yottadb query methods.
 ;
 ; 2017-09-25 ven/gpl %*1.8t01 %yottaq: update
 ;
 ; 2018-02-07 ven/toad %*1.8t04 %yottaq: passim add white space &
 ; hdr comments & do-dot quits, tag w/Apache license & attribution
 ; & to-do to shift namespace later, break up a few long lines.
 ;
 ;@to-do
 ; %yotta: create entry points in ppi/api style
 ; r/all local calls w/calls through ^%yotta
 ; change branches from %yotta
 ; renamespace elsewhere, research best choice
 ;
 ;@contents
 ; queryPred: returns a json/mumps array of tagged items
 ; importsami: import sami sample json
 ; impsami1:
 ; initforms: initialize sami forms
 ; initform1: initialize form from array
 ; $$tagyn = is item tagged w/tag?
 ; scanall:
 ;
 ;
 ;
 ;@section 1 code to implement ppis & apis
 ;
 ;
 ;
queryPred(rtn,pred) ; returns a json/mumps array of tagged items
 ;
 new graph set graph="seeGraph"
 kill @rtn
 new root set root=$$setroot^%wdgraph(graph)
 new groot set groot=$name(@root@("graph"))
 if '$data(@groot@("pos",pred)) quit
 new obj,x1,y1 set (obj,x1,y1)=""
 new cnt set cnt=0
 for  set obj=$order(@groot@("pos",pred,obj)) quit:obj=""  do  ;
 . for  set x1=$order(@groot@("pos",pred,obj,x1)) quit:x1=""  do  ;
 . . for  set y1=$order(@groot@("pos",pred,obj,x1,y1)) quit:y1=""  do  ;
 . . . set cnt=cnt+1
 . . . set @rtn@(cnt,obj,x1,y1)=""
 . . . quit
 . . quit
 . quit
 ;
 quit  ; end of queryPred
 ;
 ;
 ;
importsami ; import sami sample json
 ;
 new root set root=$$setroot^%wdgraph("elcapSampleJson")
 new ii,%i set %i=""
 set ii("ceform3","ceform-20142105.json")=""
 set ii("fuform","fuform-20142105.json")=""
 set ii("sbform","sbform-20130101.json")=""
 set ii("bxform","bxform-20132802.json")=""
 set ii("ceform","ceform-20130101.json")=""
 set ii("rbform","rbform-20130104.json")=""
 set ii("ceform2","ceform-20131510.json")=""
 set ii("ptform","ptform-20130802.json")=""
 set ii("siform","siform-20122408.json")=""
 for  set %i=$order(ii(%i)) quit:%i=""  do  ;
 . new %ii set %ii=$order(ii(%i,""))
 . do impsami1(root,%i,%ii)
 . quit
 ;
 quit  ; end of importsami
 ;
 ;
 ;
impsami1(root,id,fn) ;
 ;
 new vtmp
 do getThis^%wdgraph("vtmp",fn)
 new dest set dest=$name(@root@(id))
 new tmpdest
 do DECODE^VPRJSON("vtmp","tmpdest")
 merge @dest=tmpdest
 set @root@("B",id)=""
 ;
 quit  ; end of impsami1
 ;
 ;
 ;
initforms ; initialize sami forms
 ;
 new root set root=$$setroot("elcapSampleJson")
 new %i set %i=""
 for  set %i=$order(@root@(%i)) quit:%i=""  do  ;
 . if %i="B" quit
 . if %i=0 quit
 . new vars
 . merge vars=@root@(%i)
 . ; break
 . do initform1(%i,"vars")
 . quit
 ;
 quit  ; end of initforms
 ;
 ;
 ;
initform1(id,ary) ; initialize form from array
 ;
 ; initialize one form named id from ary passed by name
 ;
 new fn set fn=17.040201 ; file number
 new sfn set sfn=17.402011 ; subfile number for variables
 new fmroot set fmroot=$name(^%wf(17.040201))
 new fda,%yerr
 set fda(fn,"?+1,",.01)=id
 write !,"creating form ",id
 do UPDATE^DIE("","fda","","%yerr")
 if $data(%yerr) do  quit  ;
 . write !,"error creating form record ",id,!
 . zwrite %yerr
 . quit
 new %ien set %ien=$o(@fmroot@("B",id,""))
 if %ien="" do  quit  ;
 . write !,"error locating form record ",id
 . quit
 new %j set %j=""
 new vcnt set vcnt=0
 kill fda
 for  set %j=$order(@ary@(%j)) quit:%j=""  do  ;
 . set vcnt=vcnt+1
 . set fda(sfn,"?+"_vcnt_","_%ien_",",.01)=%j
 . quit
 do CLEAN^DILF
 write !,"creating variables for form ",%ien
 do UPDATE^DIE("","fda","","%yerr")
 if $data(%yerr) do  quit  ;
 . write !,"error creating variable record ",%j,!
 . zwrite %yerr
 . quit
 ;
 quit  ; end of initform1
 ;
 ;
 ;
tagyn(tag,ien1,ien2) ; is item tagged w/tag?
 ;
 ; extrinsic returns 1 if item is tagged w/tag
 ;
 new gn set gn=$name(^%wd(17.020801,1,"graph",ien1,ien2,"tag"))
 if $data(@gn@(tag)) quit 1
 ;
 quit 0 ; end of $$tagyn
 ;
 ;
 ;
scanall ;
 ;
 new gn set gn=$name(^%wd(17.020801,1,"graph","pos","id"))
 new zid,zi,zj
 set (zid,zi,zj)=""
 for  set zid=$order(@gn@(zid)) quit:zid=""  do  ;
 . if $reverse($piece($reverse(zid),"."))'="xml" quit  ; 
 . set zi=$order(@gn@(zid,""))
 . set zj=$order(@gn@(zid,zi,""))
 . quit:zj=""
 . quit:$$tagyn("scanned",zi,zj)
 . new contents
 . write !,"scanning ",zid
 . do scan^%yottagr(.contents,zid,zi,zj)
 . do addtag^%yottagr("scanned",zi,zj)
 . quit
 ;
 quit  ; end of scanall
 ;
 ;
 ;
eor ; end of routine %yottaq

%yottautl
%yottautl ;ven/gpl-yottadb extension: utilities ;2018-02-08T19:18Z
 ;;1.8;Mash;
 ;
 ; %yottaq implements the Yottadb Extension Library's utilities
 ; ppis & apis. This will eventually be reorganized into topics &
 ; migrated to other Mash namespaces. In the meantime, they will be
 ; added to the new %yotta ppi library.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-02-08T19:18Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Yottadb Extension - %yotta
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@module-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-07-04 ven/gpl %*1.8t01 %yottautl: create routine to hold
 ; yottadb utility methods.
 ;
 ; 2017-09-12 ven/gpl %*1.8t01 %yottautl: update
 ;
 ; 2017-09-18 ven/gpl %*1.8t01 %yottautl: update
 ;
 ; 2018-02-07/08 ven/toad %*1.8t04 %yottautl: passim add white space
 ; & hdr comments & do-dot quits, tag w/Apache license & attribution
 ; & to-do to shift namespace later.
 ;
 ;@to-do
 ; %yotta: create entry points in ppi/api style
 ; r/all local calls w/calls through ^%yotta
 ; organize by topic & renamespace variously
 ;
 ;@contents
 ; [too big, organize & break up]
 ;
 ;
 ;
 ;@section 1 code to implement ppis & apis
 ;
 ;
 ;
starttm(ary) ; timestamp the start time
 ;
 set @ary@("starttimefm")=$$timei
 set @ary@("starttime")=$$timee(@ary@("starttimefm"))
 ;
 quit  ; end of starttm
 ;
 ;
 ;
endtm(ary) ; timestamp the start time
 ;
 set @ary@("endtimefm")=$$timei
 set @ary@("endtime")=$$timee(@ary@("endtimefm"))
 set @ary@("elapsedtime")=$$elapsed(@ary@("endtimefm"),@ary@("starttimefm")) ;
 ; in seconds
 ;
 quit  ; end of endtm
 ;
 ;
 ;
elapsed(end,start) ; elapsed time in seconds. end and start are fm format
 ;
 quit $$fmdiff^xlfdt(end,start,2) ; end of $$elapsed
 ;
 ;
 ;
timei() ; internal time
 ;
 quit $$now^xlfdt ; end of $$timei
 ;
 ;
 ;
timee(fmtime) ; external time
 ;
 quit $$FMTE^XLFDT(fmtime) ; end of $$timee
 ;
 ;
 ;
addat(outary,inary,tag) ; both passed by name..
 ;
 ;  inary("attr")="xx" is converted to outary("tag@attr")="xx"
 ;   to make better xml - only works with simple arrays
 ;
 if '$data(tag) set tag="item"
 new zi set zi=""
 for  set zi=$order(@inary@(zi)) quit:zi=""  do  ;
 . set @outary@(tag_"@"_zi)=@inary@(zi)
 . quit
 ;
 quit  ; end of addat
 ;
 ;
 ;
testadd ; test of addat routine
 ;
 new gn set gn=$name(^xtmp("ehexpat",1))
 new gpl
 do addat("gpl",gn,"patient")
 zwrite gpl
 ;
 quit  ; end of testadd
 ;
 ;
 ;
genhtml2(hout,hary) ; generate an html table from array hary
 ;
 ; hout and hary are passed by name
 ;
 ;  hary("title")="problem list"
 ;  hary("header",1)="column 1 header"
 ;  hary("header",2)="col 2 header"
 ;  hary(1,1)="row 1 col1 value"
 ;  hary(1,2)="row 1 col2 value"
 ;  hary(1,2,"id")="the id of the element" 
 ;  etc...
 ;
 new c0i,c0j
 do addto(hout,"<div align=""center"">")
 ;
 ; if $data(@hary@("title")) do  ;
 ; . new x
 ; . set x="<title>"_@hary@("title")_"</title>"
 ; . do addto(hout,x)
 ; . quit
 ;
 do addto(hout,"<text>")
 do addto(hout,"<table border=""1"" style=""width:80%"">")
 if $data(@hary@("title")) do  ;
 . new x
 . set x="<caption><b>"_@hary@("title")_"</b></caption>"
 . do addto(hout,x)
 . quit
 if $data(@hary@("header")) do  ;
 . do addto(hout,"<thead>")
 . do addto(hout,"<tr>")
 . set c0i=0
 . for  set c0i=$order(@hary@("header",c0i)) quit:+c0i=0  do  ;
 . . do addto(hout,"<th>"_@hary@("header",c0i)_"</th>")
 . . quit
 . do addto(hout,"</tr>")
 . do addto(hout,"</thead>")
 . quit
 do addto(hout,"<tbody>")
 if $data(@hary@(1)) do  ;
 . set c0i=0 set c0j=0
 . for  set c0i=$order(@hary@(c0i)) quit:+c0i=0  do  ;
 . . do addto(hout,"<tr>")
 . . for  set c0j=$order(@hary@(c0i,c0j)) quit:+c0j=0  do  ;
 . . . new uid set uid=$get(@hary@(c0i,c0j,"id"))
 . . . if uid'="" do addto(hout,"<td style=""padding:5px;"" id="""_uid_""">"_@hary@(c0i,c0j)_"</td>")
 . . . else  do addto(hout,"<td style=""padding:5px;"">"_@hary@(c0i,c0j)_"</td>")
 . . do addto(hout,"</tr>")
 . . quit
 . quit
 do addto(hout,"</tbody>")
 do addto(hout,"</table>")
 do addto(hout,"</text>")
 do addto(hout,"</div>")
 ;
 quit  ; end of genhtml2
 ;
 ;
 ;
genhtml(hout,hary) ; generate an html table from array hary
 ;
 ; hout and hary are passed by name
 ;
 ;  hary("title")="problem list"
 ;  hary("header",1)="column 1 header"
 ;  hary("header",2)="col 2 header"
 ;  hary(1,1)="row 1 col1 value"
 ;  hary(1,2)="row 1 col2 value"
 ;  hary(1,2,"id")="the id of the element" 
 ;  etc...
 ;
 new divclass,tblclass
 set divclass=$get(@hary@("divclass"))
 set tblclass=$get(@hary@("tableclass"))
 if divclass="" set divclass="tables"
 if tblclass="" set tblclass="patient"
 new c0i,c0j
 do addto(hout,"<div class=""tables"">")
 ;
 ; if $data(@hary@("title")) do  ;
 ; . new x
 ; . set x="<title>"_@hary@("title")_"</title>"
 ; . do addto(hout,x)
 ; . quit
 ; do addto(hout,"<text>")
 ;
 new zwidth set zwidth=$get(@hary@("width"))
 if zwidth="" set zwidth="80%"
 do addto(hout,"<table class=""summary"" style=""width:"_zwidth_""">")
 if $data(@hary@("title")) do  ;
 . new x
 . set x="<caption>"_@hary@("title")_"</caption>"
 . do addto(hout,x)
 . quit
 if $data(@hary@("header")) do  ;
 . do addto(hout,"<thead>")
 . do addto(hout,"<tr>")
 . new numcol set numcol=$order(@hary@("header",""),-1)
 . set c0i=0
 . for  set c0i=$order(@hary@("header",c0i)) quit:+c0i=0  do  ;
 . . ; new th set th="<th colspan="""_numcol_""">"_@hary@("header",c0i)_"</th>"
 . . new th set th="<th>"_@hary@("header",c0i)_"</th>"
 . . do addto(hout,th)
 . . quit
 . do addto(hout,"</tr>")
 . do addto(hout,"</thead>")
 . quit
 do addto(hout,"<tbody>")
 if $data(@hary@(1)) do  ;
 . set c0i=0 set c0j=0
 . for  set c0i=$order(@hary@(c0i)) quit:+c0i=0  do  ;
 . . do addto(hout,"<tr>")
 . . for  set c0j=$order(@hary@(c0i,c0j)) quit:+c0j=0  do  ;
 . . . new uid set uid=$get(@hary@(c0i,c0j,"id"))
 . . . if uid'="" do addto(hout,"<td id="""_uid_""">"_@hary@(c0i,c0j)_"</td>")
 . . . else  do addto(hout,"<td>"_@hary@(c0i,c0j)_"</td>")
 . . . quit
 . . do addto(hout,"</tr>")
 . . quit
 . quit
 do addto(hout,"</tbody>")
 do addto(hout,"</table>")
 ; do addto(hout,"</text>")
 do addto(hout,"</div>")
 ;
 quit  ; end of genhtml
 ;
 ;
 ;
genvhtml(hout,hary) ; generate a vertical html table from array hary
 ;
 ; headers are in the first row
 ; hout and hary are passed by name
 ;
 ; format of the table:
 ;  hary("title")="problem list"
 ;  hary("header",1)="row 1 column 1 header"
 ;  hary("header",2)="row 2 col 2 header"
 ;  hary(1,1)="row 1 col2 value"
 ;  hary(2,1)="row 2 col2 value"
 ;  etc...
 ;
 new divclass,tblclass
 set divclass=$get(@hary@("divclass"))
 set tblclass=$get(@hary@("tableclass"))
 if divclass="" set divclass="tables"
 if tblclass="" set tblclass="patient"
 new c0i,c0j
 do addto(hout,"<div class=""tables"">")
 ; do addto(hout,"<div align=""center"">")
 new zwidth set zwidth=$get(@hary@("width"))
 if zwidth="" set zwidth="80%"
 do addto(hout,"<table class=""summary"" style=""width:"_zwidth_""">")
 ; do addto(hout,"<text>")
 ; do addto(hout,"<table border=""1"" style=""width:40%"">")
 if $d(@hary@("title")) do  ;
 . new x
 . set x="<caption><b>"_@hary@("title")_"</b></caption>"
 . do addto(hout,x)
 . quit
 if $data(@hary@("header")) do  ;
 . do addto(hout,"<thead>")
 . do addto(hout,"<tr>")
 . new numcol set numcol=$order(@hary@("header",""),-1)
 . set c0i=0
 . for  set c0i=$order(@hary@("header",c0i)) quit:+c0i=0  do  ;
 . . do addto(hout,"<th style=""padding:5px;"">"_@hary@("header",c0i)_"</th>")
 . . do addto(hout,"<td style=""padding:5px;"">"_@hary@(c0i,1)_"</td>")
 . . quit
 . do addto(hout,"</tr>")
 . quit
 do addto(hout,"</table>")
 do addto(hout,"</text>")
 do addto(hout,"</div>")
 ;
 quit  ; end of genvhtml
 ;
 ;
 ;
tstyle1 ; table style template
 ;;<style>
 ;;table, th, td
 ;;{
 ;;border-collapse:collapse;
 ;;border:1px solid black;
 ;;}
 ;;th, td
 ;;{
 ;;padding:5px;
 ;;}
 ;;</style>
 quit  ; end of tstyle1
 ;
 ;
 ;
testhtml ;
 ;
 new html
 set html("title")="problem list"
 set html("header",1)="column 1 header"
 set html("header",2)="col 2 header"
 set html(1,1)="row 1 col1 value"
 set html(1,2)="row 1 col2 value"
 new ghtml
 do genhtml("ghtml","html")
 zwrite ghtml
 ;
 quit  ; end of testhtml
 ;
 ;
 ;
test2 ;
 ;
 new html
 set html("title")="problem list"
 set html("header",1)="column 1 header"
 set html("header",2)="col 2 header"
 set html(1,1)="row 1 col1 value"
 set html(1,2)="row 1 col2 value"
 new ghtml
 do genhtml2("ghtml","html")
 zwrite ghtml
 ;
 quit  ; end of test2
 ;
 ;
 ;
addto(dest,what) ; adds string what to list dest 
 ;
 ; dest is passed by name
 ;
 new gn
 set gn=$o(@dest@("aaaaaa"),-1)+1
 set @dest@(gn)=what
 set @dest@(0)=gn ; count
 ;
 quit  ; end of addto
 ;
 ;
 ;
addary(dest,what) ; adds array what to list dest 
 ;
 ; dest and what are passed by name
 ;
 new gn
 set gn=$order(@dest@("aaaaaa"),-1)+1
 new zzi set zzi=0
 for  set zzi=$order(@what@(zzi)) quit:'zzi  do  ;
 . set @dest@(gn)=$get(@what@(zzi))
 . set @dest@(0)=gn ; count
 . set gn=gn+1
 . quit
 ;
 quit  ; end of addary
 ;
 ;
 ;
orgoid() ; extrinsic which returns the organization oid
 ;
 quit "2.16.840.1.113883.5.83" ; worldvista hl7 oid - 
 ;
 ; replace with oid lookup from institution file
 ;
 ;
 ;
tree(where,prefix,docid,zout) ; show a tree starting at a node in mxml. 
 ;
 ; node is passed by name
 ; 
 if $get(prefix)="" set prefix="|--" ; starting prefix
 if '$data(kbaijob) set kbaijob=$job
 new node set node=$name(^TMP("MXMLDOM",kbaijob,docid,where))
 new txt set txt=$$clean($$alltxt(node))
 write:'$get(diquiet) !,prefix_@node_" "_txt
 do oneout(zout,prefix_@node_" "_txt)
 new zi set zi=""
 for  set zi=$order(@node@("a",zi)) quit:zi=""  do  ;
 . write:'$get(diquiet) !,prefix_"  : "_zi_"^"_$get(@node@("a",zi))
 . do oneout(zout,prefix_"  : "_zi_"^"_$get(@node@("a",zi)))
 . quit
 for  set zi=$order(@node@("c",zi)) quit:zi=""  do  ;
 . do tree(zi,"|  "_prefix,docid,zout)
 . quit
 ;
 quit  ; end of tree
 ;
 ;
 ;
oneout(zbuf,ztxt) ; adds a line to zbuf
 ;
 new zi set zi=$order(@zbuf@(""),-1)+1
 set @zbuf@(zi)=ztxt
 ;
 quit  ; end of oneout
 ;
 ;
 ;
alltxt(where) ; extrinsic which returns all text lines from the node .. concatinated 
 ;
 ; together
 ;
 new zti set zti=""
 new ztr set ztr=""
 for  s zti=$order(@where@("t",zti)) quit:zti=""  do  ;
 . set ztr=ztr_$get(@where@("t",zti))
 . quit
 ;
 quit ztr ; end of $$alltxt
 ;
 ;
 ;
clean(str) ; extrinsic function; returns string - gpl borrowed from the ccr package
 ;
 ;; removes all non printable characters from a string.
 ;; str by value
 ;
 new tr,i
 for i=0:1:31 s tr=$get(tr)_$char(i)
 set tr=tr_$char(127)
 new zr set zr=$translate(str,tr)
 set zr=$$ldblnks(zr) ; get rid of leading blanks
 ;
 quit zr ; end of $$clean
 ;
 ;
 ;
ldblnks(st) ; extrinsic which removes leading blanks from a string
 ;
 new pos for pos=1:1:$length(st)  quit:$extract(st,pos)'=" "
 ;
 quit $extract(st,pos,$length(st)) ; end of $$ldblnks
 ;
 ;
 ;
show(what,docid,zout) ;
 ;
 if '$data(c0xjob) set c0xjob=$job
 do tree(what,,docid,zout)
 ;
 quit  ; end of show
 ;
 ;
 ;
listm(out,in) ; out is passed by name in is passed by reference
 ;
 new i set i=$query(@in@(""))
 for  set i=$query(@i) quit:i=""  do oneout(out,i_"="_@i)
 ;
 quit  ; end of listm
 ;
 ;
 ;
peel(out,in) ; compress a complex global into something simpler
 ;
 new i set i=$query(@in@(""))
 for  s i=$query(@i) quit:i=""  do  ;
 . new j,k,l,m,n,m1
 . set (l,m)=""
 . set n=$$shrink($qsubscript(i,$qlength(i)))
 . set k=$qsubscript(i,0)_"("""
 . for j=1:1:$qlength(i)-1  do  ;
 . . if +$qsubscript(i,j)>0 do  ;
 . . . if m'="" quit
 . . . set m=$qsubscript(i,j)
 . . . set m1=j
 . . . if j>1 set l=$qsubscript(i,j-1)
 . . . else  set l=$qsubscript(i,j)
 . . . if l["substanceadministration" set l=$p(l,"substanceadministration",2)
 . . . quit
 . . set k=k_$qsubscript(i,j)_""","""
 . . write:$get(debug) !,j," ",k
 . . quit
 . set k=k_$qsubscript(i,$qlength(i))_""")"
 . write:$get(debug) !,k,"=",@k
 . if l'="" do  quit  ;
 . . do:$get(@out@(l,m,n))'=""
 . . . ; new jj,n2
 . . . ; for jj=2:1 write !,jj set n2=$qsubscript(i,$qlength(i)-1)_"["_jj_"]"_n quit:$get(@out@(l,m,n2))=""  write !,n2
 . . . ; set n=n2
 . . . ; set n=$$shrink($qsubscript(i,$qlength(i)-1))_"_"_n
 . . . set n=$$mkxpath(i,m1)
 . . . break:$get(@out@(l,m,n))'=""
 . . . quit
 . . set @out@(l,m,n)=@k
 . . quit
 . if @k'="" do  ;
 . . if $qlength(i)>1 do  quit  ;
 . . . set l=$$shrink($qsubscript(i,$qlength(i)-1))
 . . . do:$get(@out@(l,n))'=""
 . . . . ; new jj,n2
 . . . . ; for jj=2:1 set n2=$qsubscript(i,$qlength(i)-1)_"["_jj_"]"_"_"_n quit:$get(@out@(l,n2))=""
 . . . . ; set n=n2
 . . . . ; break:$get(@out@(l,n))'=""
 . . . . set n=$$shrink($qsubscript(i,$qlength(i)-1))_"_"_n
 . . . . quit
 . . . set @out@(l,n)=@k
 . . . quit
 . . set @out@(n)=@k
 . . quit
 . quit
 ;
 quit  ; end of peel
 ;
 ;
 ;
shrink(x) ; reduce strings 
 ;
 new y,z
 set y=x
 set z="substanceadministration"
 if x[z set y=$piece(x,z,2)
 ;
 quit y ; end of $$shrink
 ;
 ;
 ;
mkxpath(zq,zm) ; extrinsic which returns the xpath derived from the $query value 
 ;
 ;passed by value. zm is the index to begin with
 ;
 new zr set zr=""
 new zi set zi=""
 for zi=1:1:$qlength(zq) set zr=zr_"/"_$qsubscript(zq,zi)
 ;
 quit zr ; end of $$mkxpath
 ;
 ;
 ;
 ; todo: make this work for regular xml files - only works now with 
 ;   attributes to a single tag per entry
 ;
 ;
 ;
ary2xml(outxml,inary,stk,child) ; convert an array to xml
 ;
 if '$data(@outxml@(1)) set @outxml@(1)="<?xml version=""1.0"" encoding=""utf-8"" ?>"
 new ii set ii=""
 new dattr set dattr="" ; deffered attributes
 for  set ii=$order(@inary@(ii),-1) quit:ii=""  do  ;
 . new attr,tag
 . set attr="" set tag=""
 . if ii["@" do  ;
 . . if tag="" set tag=$piece(ii,"@",1) set attr=$piece(ii,"@",2)_"="""_@inary@(ii)_""""
 . . write:$get(debug) !,"tag="_tag_" attr="_attr
 . . ; if $order(@inary@(ii))["@" do  ;
 . . ; for  set ii=$order(@inary@(ii),-1) quit:ii=""  quit:$order(@inary@(ii),-1)'[(tag_"@")  do  ;
 . . for  set ii=$order(@inary@(ii),-1) quit:ii=""  quit:ii'[(tag_"@")  do  ;
 . . . set attr=attr_" "_$piece(ii,"@",2)_"="""_@inary@(ii)_""""
 . . . write:$get(debug) !,"attr= ",attr
 . . . write:$get(debug) !,"ii= ",ii
 . . . quit
 . . set ii=$order(@inary@(ii)) ; reset to previous
 . . new ending set ending="/"
 . . if ii["@" do  ;
 . . . if $order(@inary@(ii),-1)=tag set dattr=" "_attr quit  ; deffered attributes
 . . . if $data(@inary@(tag)) set ending=""
 . . . do oneout(outxml,"<"_tag_" "_attr_ending_">")
 . . . if ending="" do push("stk","</"_tag_">")
 . . . quit
 . . quit
 . if ii'["@" do  ;
 . . if +ii=0 do  ;
 . . . do oneout(outxml,"<"_ii_dattr_">")
 . . . set dattr="" ; reinitialize after use
 . . . do push("stk","</"_ii_">")
 . . . quit
 . . quit
 . if $data(@inary@(ii)) do ary2xml(outxml,$name(@inary@(ii)))
 . quit
 if $data(stk) for  do oneout(outxml,$$pop("stk")) quit:'$data(stk)
 ;
 quit  ; end of ary2xml
 ;
 ;
 ;
push(buf,str) ;
 ;
 do oneout(buf,str)
 ;
 quit  ; end of push
 ;
 ;
 ;
pop(buf) ; extrinsic returns the last element and then deletes it
 ;
 new nm,tx
 set nm=$order(@buf@(""),-1)
 quit:nm="" nm
 set tx=@buf@(nm)
 kill @buf@(nm)
 ;
 quit tx ; end of $$pop
 ;
 ;
 ;
eor ; end of routine %yottautl

%yottaweb
%yottaweb ;ven/gpl-yottadb extension: utilities ;2018-02-08T20:06Z
 ;;1.8;Mash;
 ;
 ; %yottaweb implements Yottadb Extension Library web-interface
 ; ppis & apis. This will eventually be migrated to other Mash
 ; namespaces, perhaps %ww. In the meantime, they will be added
 ; to the new %yotta ppi library.
 ; It is currently untested & in progress.
 ;
 quit  ; no entry from top
 ;
 ;
 ;
 ;@section 0 primary development
 ;
 ;
 ;
 ;@routine-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@primary-dev-org: Vista Expertise Network (ven)
 ; http://vistaexpertise.net
 ;@copyright: 2017/2018, gpl, all rights reserved
 ;@license: Apache 2.0
 ; https://www.apache.org/licenses/LICENSE-2.0.html
 ;
 ;@last-updated: 2018-02-08T20:06Z
 ;@application: Mumps Advanced Shell (Mash)
 ;@module: Yottadb Extension - %yotta
 ;@version: 1.8T04
 ;@release-date: not yet released
 ;@patch-list: none yet
 ;
 ;@additional-dev: Frederick D. S. Marshall (toad)
 ; toad@vistaexpertise.net
 ;
 ;@module-credits
 ;@primary-dev: George P. Lilly (gpl)
 ; gpl@vistaexpertise.net
 ;@project: VA Partnership to Increase Access to Lung Screening
 ; (VA-PALS)
 ; http://va-pals.org/
 ;@funding: 2017, gpl
 ;@funding: 2017, ven
 ;@funding: 2017/2018, Bristol-Myers Squibb Foundation (bmsf)
 ; https://www.bms.com/about-us/responsibility/bristol-myers-squibb-foundation.html
 ;@partner-org: Veterans Affairs Office of Rural health
 ; https://www.ruralhealth.va.gov/
 ;@partner-org: International Early Lung Cancer Action Program (I-ELCAP)
 ; http://ielcap.com/
 ;@partner-org: Paraxial Technologies
 ; http://paraxialtech.com/
 ;@partner-org: Open Source Electronic Health Record Alliance (OSEHRA)
 ; https://www.osehra.org/groups/va-pals-open-source-project-group
 ;
 ;@module-log
 ; 2017-07-04 ven/gpl %*1.8t01 %yottaweb: create routine to hold
 ; yottadb web-interface methods.
 ;
 ; 2017-09-12 ven/gpl %*1.8t01 %yottaweb: update
 ;
 ; 2017-09-27 ven/gpl %*1.8t01 %yottaweb: update
 ;
 ; 2017-10-07 ven/gpl %*1.8t01 %yottaweb: update
 ;
 ; 2018-02-08 ven/toad %*1.8t04 %yottaweb: passim add white space &
 ; hdr comments & do-dot quits, tag w/Apache license & attribution
 ; & to-do to shift namespace later.
 ;
 ;@to-do
 ; implement the camel parameter:
 ; example - fileman_field if camel=1 becomes filemanfield
 ;  if camel=2 becomes filemanfield
 ; %yotta: create entry points in ppi/api style
 ; r/all local calls w/calls through ^%yotta
 ; eventually renamespace, perhaps under %ww
 ;
 ;@contents
 ;
 ;
 ;
 ;@section 1 code to implement ppis & apis
 ;
 ;
 ;
fmrec(file,ien) ; extrinsic which returns the json version of the fmx return
 ;
 new %g,%gj
 do fmx("%g",file,ien)
 do ENCODE^VPRJSON("%g","%gj")
 ;
 quit %gj ; end of $$fmrec
 ;
 ;
 ;
fmx(rtn,file,ien,camel) ; return an array of a fileman record for external 
 ;
 ; use in rtn, which is passed by name. 
 ;
 kill @rtn
 new trec,filenm
 do GETS^DIQ(file,ien_",","**","ENR","trec")
 set filenm=$order(^DD(file,0,"NM",""))
 set filenm=$translate(filenm," ","_")
 ; zwrite trec
 if $get(debug)=1 break
 new % set %=$query(trec(""))
 for  do  quit:%=""  ;
 . new fnum,fname,iens,field,val
 . set fnum=$qsubscript(%,1)
 . if $data(^DD(fnum,0,"NM")) do  ;
 . . set fname=$order(^DD(fnum,0,"NM",""))
 . . set fname=$translate(fname," ","_")
 . . quit
 . else  set fname=fnum
 . set iens=$qsubscript(%,2)
 . set field=$qsubscript(%,3)
 . set field=$translate(field," ","_")
 . set val=@%
 . if fnum=file do  ; not a subfile
 . . set @rtn@(fname,ien,field)=val
 . . set @rtn@(fname,"ien")=$piece(iens,",",1)
 . . quit
 . else  do  ;
 . . new i2 set i2=$order(@rtn@(fname,""),-1)+1
 . . set @rtn@(fname,$piece(iens,","),field)=val
 . . ; set @rtn@(fname,i2,field)=val
 . . ; set @rtn@(fname,i2,"iens")=iens
 . . quit
 . write:$get(debug)=1 !,%,"=",@%
 . set %=$query(@%)
 . quit
 ;
 quit  ; end of fmx
 ;
 ;
 ;
 ; example
 ; g("bsts_concept","codeset")=36
 ; g("bsts_concept","concept_id")=370206005
 ; g("bsts_concept","counter")=75
 ; g("bsts_concept","dts_id")=370206
 ; g("bsts_concept","fully_specified_name")="asthma limits walking on the flat (finding)"
 ; g("bsts_concept","last_modified")="may 11, 2015"
 ; g("bsts_concept","out_of_date")="no"
 ; g("bsts_concept","partial_entry")="non-patial (full entry)"
 ; g("bsts_concept","revision_in")="mar 01, 2012"
 ; g("bsts_concept","revision_out")="jan 01, 2050"
 ; g("bsts_concept","version")=20140901
 ; g("bsts_concept","ien")="75"
 ; g("is_a_relationship",1,"is_a_relationship")=2
 ; g("subsets",1,"subsets")="ehr ipl asthma dxs"
 ; g("subsets",2,"subsets")="srch cardiology"
 ; g("subsets",3,"subsets")="ihs problem list"
 ;
 ;
 ;
gpltest(rtn,filter) ;
 ;
 if '$data(rtn) set rtn=$name(^tmp("gpltest",$job))
 kill @rtn
 new gtop,gbot
 do htmltb(.gtop,.gbot,"gpltest page")
 merge @rtn=gtop
 new dfn set dfn=$get(filter("dfn"))
 if dfn="" set dfn=2
 new gary,ary,hary
 do fmx^kbaiweb("gary",2,dfn)
 set ary("header",1)="name"
 set ary("header",2)="date of birth"
 set ary("header",3)="age"
 set ary("title")="test html"
 set ary(1,1)=gary("patient","name")
 set ary(1,2)=gary("patient","date_of_birth")
 set ary(1,3)=gary("patient","age")          
 do genhtml2^kbaiutil(rtn,"ary")
 set @rtn@($order(@rtn@(""),-1)+1)=gbot
 kill @rtn@(0)
 set HTTPRSP("mime")="text/html"
 ;
 quit  ; end of gpltest
 ;
 ;
 ;
htmltb(gtop,gbot,title) ; sets beginning and ending fixed html
 ;
 ; set gtop="<!doctype html><html><head></head><body>"
 set gtop(1)="<!doctype html>"
 set gtop(2)="<html>"
 set gtop(3)="<head>"
 set gtop(4)="<meta charset=""utf-8"">"
 set gtop(5)="<meta http-equiv=""content-type"" content=""text/html; charset=utf-8"" />"
 set gtop(6)="<title>"_$g(title)_"</title>"
 set gtop(7)="<link rel=""stylesheet"" type=""text/css"" href=""/resources/css/c0tstyle.css"" />"
 set gtop(8)="</head>"
 set gtop(9)="<body>"
 ;
 set gbot="</body></html>"
 ;
 quit  ; end of htmltb
 ;
 ;
 ;
htmltb2(gtop,gbot,title) ; sets beginning and ending fixed html
 ;
 ; this one is for standalone html files - no remote css
 ;
 ; set gtop="<!doctype html><html><head></head><body>"
 set gtop(1)="<!doctype html>"
 set gtop(2)="<html>"
 set gtop(3)="<head>"
 set gtop(4)="<meta charset=""utf-8"">"
 set gtop(5)="<meta http-equiv=""content-type"" content=""text/html; charset=utf-8"" />"
 set gtop(6)="<title>"_$get(title)_"</title>"
 ; set gtop(7)="<link rel=""stylesheet"" type=""text/css"" href=""/resources/css/c0tstyle.css"" />"
 ; set gtop(6.5)="<style>"
 set gtop(7)="<style>body {"
 set gtop(8)="    font-family: verdana, sans-serif;"
 set gtop(9)="    font-size: 10pt;"
 set gtop(10)="}"
 set gtop(11)="div.formats {"
 set gtop(12)="    border: 1px solid black;"
 ; set gtop(13)="    margin: 2em;"
 set gtop(13)="    margin: .02em;"
 set gtop(14)="    width: 20em;"
 set gtop(15)="    padding: 0.4em;"
 set gtop(16)="}"
 set gtop(17)="div.formats p {"
 set gtop(18)="    display: inline;"
 set gtop(19)="}"
 set gtop(20)="div.formats ul, div.formats li {"
 set gtop(21)="    display: inline;"
 set gtop(22)="    color: #333399;"
 set gtop(23)="    margin: 0px;"
 set gtop(24)="    padding: 0px;"
 set gtop(25)="    font-weight: bold;"
 set gtop(26)="}"
 set gtop(27)="div.formats li {"
 set gtop(28)="    padding: 0px 0.1em;"
 set gtop(29)="}"
 set gtop(30)="div.tables {"
 set gtop(31)="    margin: 1em auto; align: left;"
 set gtop(32)="}"
 set gtop(33)="table {"
 set gtop(34)="    border-collapse: collapse;"
 ; set gtop(35)="    margin: 3em auto;"
 ; set gtop(35)="    margin: 3em auto;"
 set gtop(35)=" "
 set gtop(36)="}"
 set gtop(37)="table caption {"
 set gtop(38)="    font-size: 110%;"
 set gtop(39)="    padding: 0.4em;"
 set gtop(40)="    background-color: black;"
 set gtop(41)="    color: white;"
 set gtop(42)="    font-weight: bold;"
 set gtop(43)="}"
 set gtop(44)="table td, table th {"
 set gtop(45)="    border: 1px solid #e0e0e0;"
 set gtop(46)="    margin: 0px;"
 set gtop(47)="    padding: 0.4em;"
 set gtop(48)="    white-space: normal; word-wrap: break-word;"
 set gtop(49)="}"
 set gtop(50)="table th {"
 set gtop(51)="    background-color: #808080;"
 set gtop(52)="    color: white;"
 set gtop(53)="    font-weight: bold;"
 set gtop(54)="    text-align: center;"
 set gtop(55)="}"
 set gtop(56)="table td {"
 set gtop(57)="    font-size: 90%;"
 set gtop(58)="    padding: 0.4em; white-space:normal; word-wrap: break-word;"
 set gtop(59)="}"
 set gtop(60)="</style>"
 set gtop(61)="</head>"
 set gtop(62)="<body>"
 ;
 set gbot="</body></html>"
 ;
 quit  ; end of htmltb2
 ;
 ;
 ;
eor ; end of routine %yottaweb



