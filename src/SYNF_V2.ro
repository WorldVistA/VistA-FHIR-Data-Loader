labs, meds, med allergies testing version
GT.M 11-JUN-2018 02:50:35
SYNFALG
SYNFALG ;ven/gpl - fhir loader utilities ; 2/20/18 4:11am
 ;;1.0;fhirloader;;oct 19, 2017;Build 2
 ;
 ; Authored by George P. Lilly 2017-2018
 ; (c) Sam Habiel 2018
 ;
 q
 ;
importAllergy(rtn,ien,args) ; entry point for loading Allergy for a patient
 ; calls the intake Allergy web service directly
 ;
 n grtn
 n root s root=$$setroot^%wd("fhir-intake")
 d wsIntakeAllergy(.args,,.grtn,ien)
 i $d(grtn) d  ; something was returned
 . k @root@(ien,"load","allergy")
 . m @root@(ien,"load","allergy")=grtn("allergy")
 . if $g(args("debug"))=1 m rtn=grtn
 s rtn("conditionsStatus","status")=$g(grtn("status","status"))
 s rtn("conditionsStatus","loaded")=$g(grtn("status","loaded"))
 s rtn("conditionsStatus","errors")=$g(grtn("status","errors"))
 ;b
 ;
 ;
 q
 ;
wsIntakeAllergy(args,body,result,ien) ; web service entry (post)
 ; for intake of one or more Allergy. input are fhir resources
 ; result is json and summarizes what was done
 ; args include patientId
 ; ien is specified for internal calls, where the json is already in a graph
 n jtmp,json,jrslt,eval
 ;i $g(ien)'="" if $$loadStatus("allergy","",ien)=1 d  q  ;
 ;. s result("allergytatus","status")="alreadyLoaded"
 i $g(ien)'="" d  ; internal call
 . d getIntakeFhir^SYNFHIR("json",,"AllergyIntolerance",ien,1)
 e  d  ; 
 . ;s args("load")=0
 . merge jtmp=BODY
 . do DECODE^VPRJSON("jtmp","json")
 ;
 i '$d(json) d getRandomAllergy(.json)
 ;
 i '$d(json) q  ;
 m ^gpl("gjson")=json
 ;
 ; determine the patient
 ;
 n dfn,eval
 if $g(ien)'="" d  ;
 . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
 else  d  ;
 . s dfn=$g(args("dfn"))
 . i dfn="" d  ;
 . . n icn s icn=$g(args("icn"))
 . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
 . . q:dfn=""
 . . s ien=$$dfn2ien^SYNFUTL(dfn)
 i $g(dfn)="" do  quit  ; need the patient
 . s result("allergy",1,"log",1)="Error, patient not found.. terminating"
 ;
 new zi s zi=0
 for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
 . ;
 . ; define a place to log the processing of this entry
 . ;
 . new jlog set jlog=$name(eval("allergy",zi))
 . ;
 . ; insure that the resourceType is AllergyIntolerance
 . ;
 . new type set type=$get(json("entry",zi,"resource","resourceType"))
 . if type'="AllergyIntolerance" do  quit  ;
 . . set eval("allergy",zi,"vars","resourceType")=type
 . . do log(jlog,"Resource type not AllergyIntolerance, skipping entry")
 . set eval("allergy",zi,"vars","resourceType")=type
 . ;
 . ; see if this resource has already been loaded. if so, skip it
 . ;
 . if $g(ien)'="" if $$loadStatus("allergy",zi,ien)=1 do  quit  ;
 . . d log(jlog,"Allergy already loaded, skipping")
 . ;
 . ; determine the codesystem of the allergy
 . ;
 . new codesystem set codesystem=$get(json("entry",zi,"resource","code","coding",1,"system"))
 . do log(jlog,"code system is: "_codesystem)
 . set eval("allergy",zi,"vars","codeSystem")=codesystem
 . ;
 . ; if rxnorm, call meds routine
 . ; 
 . i codesystem["rxnorm" do  q  ;
 . . d MEDALGY^SYNFALG2(dfn,.root,.json,zi,.eval,.jlog,.args)
 . ;
 . ; determine Allergy snomed code  and display text
 . ;
 . ; determine the id of the resource
 . ;
 . ;new id set id=$get(json("entry",zi,"resource","id"))
 . ;set eval("allergy",zi,"vars","id")=id
 . ;d log(jlog,"ID is: "_id)
 . ;
 . new sctcode set sctcode=$get(json("entry",zi,"resource","code","coding",1,"code"))
 . do log(jlog,"code is: "_sctcode)
 . set eval("allergy",zi,"vars","code")=sctcode
 . ;
 . ;
 . ; determine the onset date and time
 . ;
 . new onsetdate set onsetdate=$get(json("entry",zi,"resource","assertedDate"))
 . do log(jlog,"onsetDateTime is: "_onsetdate)
 . set eval("allergy",zi,"vars","onsetDateTime")=onsetdate
 . new fmOnsetDateTime s fmOnsetDateTime=$$fhirTfm^SYNFUTL(onsetdate)
 . i $l(fmOnsetDateTime)=14 s fmOnsetDateTime=$e(fmOnsetDateTime,1,12)
 . d log(jlog,"fileman onsetDateTime is: "_fmOnsetDateTime)
 . set eval("allergy",zi,"vars","fmOnsetDateTime")=fmOnsetDateTime ;
 . new hl7OnsetDateTime s hl7OnsetDateTime=$$fhirThl7^SYNFUTL(onsetdate)
 . d log(jlog,"hl7 onsetDateTime is: "_hl7OnsetDateTime)
 . set eval("allergy",zi,"vars","hl7OnsetDateTime")=hl7OnsetDateTime ;
 . ;
 . ; determine clinical status (active vs inactive)
 . ;
 . n clinicalstatus set clinicalstatus=$get(json("entry",zi,"resource","verificationStatus"))
 . ;
 . ;
 . ; set up to call the data loader
 . ;
 . ;ALLERGY^ISIIMP10(ISIRESUL,ISIMISC)          
 .;;NAME             |TYPE       |FILE,FIELD |DESC
 .;;-----------------------------------------------------------------------
 .;;ALLERGEN         |FIELD      |120.82,.01 |
 .;;SYMPTOM          |MULTIPLE   |120.83,.01 |Multiple,"|" (bar) delimited, working off #120.83
 .;;PAT_SSN          |FIELD      |120.86,.01 |PATIENT (#2, .09) pointer
 .;;ORIG_DATE        |FIELD      |120.8,4    |
 .;;ORIGINTR         |FIELD      |120.8,5    |PERSON (#200)
 .;;HISTORIC         |BOOLEEN    |           |1=HISTORICAL, 0=OBSERVED
 .;;OBSRV_DT         |FIELD      |           |Observation Date (if HISTORIC=0)
 .;
 . n RESTA,ISIMISC
 . ;
 . s ISIMISC("ALLERGEN")=$get(json("entry",zi,"resource","code","coding",1,"display"))
 . n algy s algy=$$ISGMR(sctcode)
 . i algy'=-1 s ISIMISC("ALLERGEN")=$p(algy,"^",2)
 . s eval("allergy",zi,"parms","ALLERGEN")=ISIMISC("ALLERGEN")
 . ;
 . s ISIMISC("SYMPTOM")=$get(json("entry",zi,"resource","reaction",1,"description"))
 . s eval("allergy",zi,"parms","SYMPTOM")=ISIMISC("SYMPTOM")
 . ;
 . ;s ISIMISC("ORIGINTR")="USER,THREE"
 . s ISIMISC("ORIGINTR")=$$USERNAME^SYNFALG
 . s eval("allergy",zi,"parms","ORIGINTR")=ISIMISC("ORIGINTR")
 . ;
 . s DHPPAT=$$dfn2icn^SYNFUTL(dfn)
 . s eval("allergy",zi,"parms","DHPPAT")=DHPPAT
 . s ISIMISC("PAT_SSN")=$$GET1^DIQ(2,dfn_",",.09)
 . s eval("allergy",zi,"parms","PAT_SSN")=ISIMISC("PAT_SSN")
 . ;
 . s DHPSCT=sctcode
 . s eval("allergy",zi,"parms","DHPSCT")=DHPSCT
 . ;
 . s DHPCLNST=$S(clinicalstatus="Active":"A",1:"I")
 . s eval("allergy",zi,"parms","DHPCLNST")=DHPCLNST
 . ;
 . s DHPONS=hl7OnsetDateTime
 . s eval("allergy",zi,"parms","DHPONS")=DHPONS
 . s ISIMISC("ORIG_DATE")=fmOnsetDateTime
 . s eval("allergy",zi,"parms","ORIG_DATE")=ISIMISC("ORIG_DATE")
 . s ISIMISC("HISTORIC")=1
 . s eval("allergy",zi,"parms","HISTORIC")=ISIMISC("HISTORIC")
 . ;
 . s DHPPROV=$$MAP^SYNQLDM("OP","provider") ; map should return the NPI number
 . s eval("allergy",zi,"parms","DHPPROV")=DHPPROV
 . d log(jlog,"Provider NPI for outpatient is: "_DHPPROV)
 . ;
 . ;s DHPLOC=$$MAP^SYNQLDM("OP","location")
 . ;n DHPLOCIEN s DHPLOCIEN=$o(^SC("B",DHPLOC,""))
 . ;if DHPLOCIEN="" S DHPLOCIEN=4
 . ;s eval("allergy",zi,"parms","DHPLOC")=DHPLOCIEN
 . ;d log(jlog,"Location for outpatient is: #"_DHPLOCIEN_" "_DHPLOC)
 . ;
 . s eval("allergy",zi,"status","loadstatus")="readyToLoad"
 . ;
 . if $g(args("load"))=1 d  ; only load if told to
 . . if $g(ien)'="" if $$loadStatus("allergy",zi,ien)=1 do  quit  ;
 . . . d log(jlog,"Allergy already loaded, skipping")
 . . d log(jlog,"Calling ALLERGY^ISIIMP10 to add allergy")
 . . D ALLERGY^ISIIMP10(.RETSTA,.ISIMISC)
 . . m eval("allergy",zi,"status")=RESTA
 . . d log(jlog,"Return from data loader was: "_$g(ISIRC))
 . . if +$g(RETSTA)=1 do  ;
 . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
 . . . s eval("allergy",zi,"status","loadstatus")="loaded"
 . . else  d  ;
 . . . s eval("status","errors")=$g(eval("status","errors"))+1
 . . . s eval("allergy",zi,"status","loadstatus")="notLoaded"
 . . . s eval("allergy",zi,"status","loadMessage")=$g(RETSTA)
 . . n root s root=$$setroot^%wd("fhir-intake")
 . . i $g(ien)'="" d  ;
 . . . k @root@(ien,"load","allergy",zi)
 . . . m @root@(ien,"load","allergy",zi)=eval("allergy",zi)
 ;
 if $get(args("debug"))=1 do  ;
 . m jrslt("source")=json
 . m jrslt("args")=args
 . m jrslt("eval")=eval
 m jrslt("allergyStatus")=eval("allergyStatus")
 set jrslt("result","status")="ok"
 set jrslt("result","loaded")=$g(eval("status","loaded"))
 i $g(ien)'="" d  ; called internally
 . m result=eval
 . m result("status")=jrslt("result")
 . m result("dfn")=dfn
 . m result("ien")=ien
 . ;b
 e  d  ;
 . d ENCODE^VPRJSON("jrslt","result")
 . set HTTPRSP("mime")="application/json" 
 q
 ;
USERNAME() ; extrinsic returns the name of the user
 n duz
 s duz=$$USERDUZ^SYNFALG2
 q:duz="" -1
 q $p(^VA(200,duz,0),"^",1)
 ;
log(ary,txt) ; adds a text line to @ary@("log")
 s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
 q
 ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
 n root s root=$$setroot^%wd("fhir-intake")
 n rt s rt=0
 i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
 i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
 q rt
 ;
testall ; run the allergy import on all imported patients
 new root s root=$$setroot^%wd("fhir-intake")
 new indx s indx=$na(@root@("POS","DFN"))
 n dfn,ien,filter,reslt
 s dfn=0
 f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
 . s ien=$o(@indx@(dfn,""))
 . q:ien=""
 . s filter("dfn")=dfn
 . k reslt
 . d wsIntakeAllergy(.filter,,.reslt,ien)
 q
 ;
testone(reslt,doload) ; run the allergy import on one imported patient
 new root s root=$$setroot^%wd("fhir-intake")
 new indx s indx=$na(@root@("POS","DFN"))
 n dfn,ien,filter
 n done s done=0
 s dfn=0
 f  s dfn=$o(@indx@(dfn)) q:+dfn=0  q:done   d  ;
 . s ien=$o(@indx@(dfn,""))
 . q:ien=""
 . q:$d(@root@(ien,"load","allergy"))
 . s filter("dfn")=dfn
 . s filter("debug")=1
 . i $g(doload)=1 s filter("load")=1
 . k reslt
 . d wsIntakeAllergy(.filter,,.reslt,ien)
 . s done=1
 q
 ;
getRandomAllergy(ary) ; make a web service call to get random allergies
 n srvr
 s srvr="http://postfhir.vistaplex.org:9080/"
 i srvr["postfhir.vistaplex.org" s srvr="http://138.197.70.229:9080/"
 i $g(^%WURL)["http://postfhir.vistaplex.org:9080" d  q  ;
 . s srvr="localhost:9080/"
 . n url
 . s url=srvr_"randomAllergy"
 . n ok,r1
 . s ok=$$%^%WC(.r1,"GET",url)
 . i '$d(r1) q  ;
 . d DECODE^VPRJSON("r1","ary")
 n url
 s url=srvr_"randomAllergy"
 n ret,json,jtmp
 s ret=$$GETURL^XTHC10(url,,"jtmp")
 d assemble^SYNFPUL("jtmp","json")
 i '$d(json) q  ;
 d DECODE^VPRJSON("json","ary")
 q
 ;
ISGMR(CDE) ; extrinsic return the ien and allergy name in GMR ALLERGIES if any
 ; CDE is a snomed code. returns -1 if not found
 N VUID
 S VUID=$$MAP^SYNQLDM(CDE)
 ;W !,CDE," VUID:",VUID
 I VUID="" Q -1
 N IEN
 S IEN=$O(^GMRD(120.82,"AVUID",VUID,""))
 I IEN="" Q -1
 N R1 S R1=IEN_"^"_$$GET1^DIQ(120.82,IEN_",",.01)
 Q R1
 ;
QADDALGY(ALGY,ADATE,ien) ; adds an allergy to the queue to be processed
 ; used by Problems processing include allergies in VistA allergies
 ; ALGY is the name of the allergy. ADATE is the date of the allergy
 ; ien is the patient being processed
 i '$d(ien) q  ;
 n root s root=$$setroot^%wd("fhir-intake")
 n groot s groot=$na(@root@(ien,"load","ALLERGY2ADD"))
 n aien s aien=$o(@groot@(" "),-1)+1
 s @groot@(aien,"allergy")=$g(ALGY)
 s @groot@(aien,"date")=$g(ADATE)
 q
 ;

SYNFALG2
SYNFALG2 ;ven/gpl - fhir loader utilities ; 2/20/18 4:11am
 ;;1.0;fhirloader;;oct 19, 2017;Build 2
 ;
 ; Authored by George P. Lilly 2017-2018
 ; (c) Sam Habiel 2018
 ;
 QUIT
 ;
MEDALGY(dfn,root,json,zi,eval,jlog,args) ; allergy is rxnorm
 ;
 n SYNDFN,SYNRXN,SYNDF,SYNPA,SYNDUZ,SYNSS,SYNDATE,SYNCOMM
 ;
 S SYNDFN=dfn
 d log(jlog,"Patient DFN: "_SYNDFN)
 s eval("allergy",zi,"vars","dfn")=SYNDFN
 ;
 s SYNRXN=$get(json("entry",zi,"resource","code","coding",1,"code"))
 d log(jlog,"Allergin is RxNorm: "_SYNRXN)
 set eval("allergy",zi,"vars","code")=SYNRXN
 ;
 S SYNDUZ=$$USERDUZ
 d log(jlog,"Provider DUZ: "_SYNDUZ)
 s eval("allergy",zi,"vars","duz")=SYNDUZ
 ;
 new onsetdate set onsetdate=$get(json("entry",zi,"resource","assertedDate"))
 do log(jlog,"onsetDateTime is: "_onsetdate)
 set eval("allergy",zi,"vars","onsetDateTime")=onsetdate
 new fmOnsetDateTime s fmOnsetDateTime=$$fhirTfm^SYNFUTL(onsetdate)
 i $l(fmOnsetDateTime)=14 s fmOnsetDateTime=$e(fmOnsetDateTime,1,12)
 d log(jlog,"fileman onsetDateTime is: "_fmOnsetDateTime)
 set eval("allergy",zi,"vars","fmOnsetDateTime")=fmOnsetDateTime ;
 S SYNDATE=fmOnsetDateTime
 ;
 s eval("allergy",zi,"status","loadstatus")="readyToLoad"
 ;
 if $g(args("load"))=1 d  ; only load if told to
 . n ien s ien=$$dfn2ien^SYNFUTL(dfn) ;
 . if $g(ien)'="" if $$loadStatus^SYNFALG("allergy",zi,ien)=1 do  quit  ;
 . . d log(jlog,"Allergy already loaded, skipping")
 . d log(jlog,"Calling ADDMEDADR^SYNFALG2 to add allergy")
 . n ok
 . s ok=$$ADDMEDADR(SYNDFN,SYNRXN,,,SYNDUZ,,SYNDATE) ; 
 . m eval("allergy",zi,"status")=ok
 . d log(jlog,"Return from data loader was: "_ok)
 . if +$g(ok)=1 do  ;
 . . s eval("status","loaded")=$g(eval("status","loaded"))+1
 . . s eval("allergy",zi,"status","loadstatus")="loaded"
 . else  d  ;
 . . s eval("status","errors")=$g(eval("status","errors"))+1
 . . s eval("allergy",zi,"status","loadstatus")="notLoaded"
 . . s eval("allergy",zi,"status","loadMessage")=ok
 . n root s root=$$setroot^%wd("fhir-intake")
 . i $g(ien)'="" d  ;
 . . k @root@(ien,"load","allergy",zi)
 . . m @root@(ien,"load","allergy",zi)=eval("allergy",zi)
 ;
 q
 ;
USERDUZ() ; extrinsic returning the DUZ of the user
 n npi,duz
 s npi=$$MAP^SYNQLDM("OP","provider") ; map should return the NPI number
 s duz=$O(^VA(200,"ANPI",npi,""))
 q duz
 ;
log(ary,txt) ; adds a text line to @ary@("log")
 s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
 q
 ;
ADDMEDADR(SYNDFN,SYNRXN,SYNDF,SYNPA,SYNDUZ,SYNSS,SYNDATE,SYNCOMM) ; [Public] Add an allergy/adrxn using a Medications RxNorm Code
 ; Uses IA#4682 to record an allergy in the patient's chart
 ;
 ; Input:
 ; - SYNDFN   (r) = DFN
 ; - SYNRXN   (r) = RxNorm Ingredient or Clinical Drug code
 ; - SYNDF    (o) = "D"rug or "F"ood
 ; - SYNPA    (o) = Nature of Reaction: "P"harmacologic or "A"llergic
 ; - SYNDUZ   (o) = Recorder of reaction
 ; - SYNSS    (o) = ";" delimited list of signs and symptoms
 ; - SYNDATE  (o) = Date of recording of signs and symptoms
 ; - .SYNCOMM (o) = Comments in 1,2,3 etc passed by reference
 ;
 ; Output:
 ; - Can be called as a routine; but you won't get any error information
 ; - with $$, you will get:
 ; - 0^note to sign (if any) or -1^error message
 ; 
 ; Translate RXN to VUID
 ; get VUIDs
 ; Output like this: 50.6~4030995
 ; or -1^message
 n fileVUIDs s fileVUIDs=$$ETSRXN2VUID^SYNFMED(SYNRXN)
 i fileVUIDs<0 quit fileVUIDs
 ;
 ; Get the first one
 n firstFileVUID s firstFileVUID=$P(fileVUIDs,U)
 ;
 ; Error if not found
 if firstFileVUID="" quit:$quit "-2^no-suitable-vuid-term-was-CD-or-IN" quit
 ;
 kill ^TMP("SYN",$J) ; we put all the reactant info here
 ;
 ; find variable pointer
 new synvuid ; For Searching Compound Index
 set synvuid(1)=$p(firstFileVUID,"~",2)
 set synvuid(2)=1
 set file=$p(firstFileVUID,"~",1)
 if 'file set $ec=",u-no-supposed-to-happen,"
 new ien set ien=$$FIND1^DIC(file,"","XQ",.synvuid,"AMASTERVUID")
 if 'ien quit:$quit "-3^VUID-not-found. Is your NDF up to date?" quit
 ;
 new drugName set drugName=$$GET1^DIQ(file,ien,.01)
 ;
 ; load the data into the global for the API
 set ^TMP("SYN",$J,"GMRAGNT")=drugName_U_ien_";"_$piece($$ROOT^DILFD(file),U,2) ; variable pointer syntax
 set ^TMP("SYN",$J,"GMRATYPE")=$G(SYNDF,"D") ; Allergen type: Drug OR Food (D or F)
 set ^TMP("SYN",$J,"GMRANATR")=$G(SYNPA,"U") ; nature of reaction: Allergic or Pharmacologic (default unknown)
 set ^TMP("SYN",$J,"GMRAORIG")=$G(SYNDUZ,DUZ) ; Originator
 set ^TMP("SYN",$J,"GMRAORDT")=$G(SYNDATE,DT) ; Date of recording of reaction (not date of reaction)
 new ssErr set ssErr=0
 if $get(SYNSS)]"" do
 . set ^TMP("SYN",$J,"GMRASYMP",0)=$L(SYNSS,";") ; Signs and symptoms need to be entered by IENs
 . new i for i=1:1:$l(SYNSS,";") do  q:ssErr  ; put signs and symptoms in 1,2,3 etc
 .. new ssIEN set ssIEN=$$FIND1^DIC(120.83,,"QX",$piece(SYNSS,";",i),"B")
 .. if 'ssIEN set ssErr=1
 .. set ^TMP("SYN",$J,"GMRASYMP",i)=ssIEN_U_$piece(SYNSS,";",i)
 i ssErr quit:$quit "-4^one or more signs/symptoms cannot be found" quit
 set ^TMP("SYN",$J,"GMRACHT",0)=1 ; marked in chart
 set ^TMP("SYN",$J,"GMRACHT",1)=$$NOW^XLFDT() ; marked now
 set ^TMP("SYN",$J,"GMRAOBHX")="h" ; historical. No sense in doing "observed"
 if $data(SYNCOMM) merge ^TMP("SYN",$J,"GMRACMTS")=SYNCOMM
 ;
 ; call the API
 N ORY
 D UPDATE^GMRAGUI1(0,SYNDFN,$NA(^TMP("SYN",$J)))
 ;
 ; API return -1^message or 0^note to sign
 if $piece(ORY,U)=-1 quit:$quit -5_U_$piece(ORY,U,2) quit
 quit:$quit 0_U_$piece(ORY,U,2)
 quit
 ;
TEST D EN^%ut($T(+0),3) quit
STARTUP ; M-UNIT STARTUP
 ; Delete all traces of patients allergies from DFN 1
 ; ZEXCEPT: DFN
 S DFN=1
 N DIK,DA
 S DIK=$$ROOT^DILFD(120.86),DA=DFN D ^DIK
 S DIK="^GMR(120.8,"
 S DA=0
 F  S DA=$O(^GMR(120.8,"B",1,DA)) Q:'DA  D ^DIK 
 QUIT
 ;
TADDMEDADR1 ; @TEST Simple allergen NOS - Contraceptive CD.
 ; ZEXCEPT: DFN
 N % S %=$$ADDMEDADR(DFN,831533)
 D CHKTF^%ut(+%=0)
 quit
 ;
TADDMEDADR2 ; @TEST Allergen as "food" (really penicillin IN)
 ; ZEXCEPT: DFN
 N % S %=$$ADDMEDADR(DFN,70618,"F")
 D CHKTF^%ut(+%=0)
 quit
 ;
TADDMEDADR3 ; @TEST Pharmacological or Allergic (Simvastatin CD)
 ; ZEXCEPT: DFN
 N % S %=$$ADDMEDADR(DFN,198211,"D","P")
 D CHKTF^%ut(+%=0)
 quit
 ;
TADDMEDADR4 ; @TEST Different Originator (Tamoxifen CD)
 ; ZEXCEPT: DFN
 N ORIG S ORIG=$O(^XUSEC("PROVIDER",""))
 N % S %=$$ADDMEDADR(DFN,313195,"D","P",ORIG)
 D CHKTF^%ut(+%=0)
 quit
 ;
TADDMEDADR5 ; @TEST Different Origination date (Aliskiren/Amlodipine IN)
 ; ZEXCEPT: DFN
 N ORIG S ORIG=$O(^XUSEC("PROVIDER",""))
 N % S %=$$ADDMEDADR(DFN,1009219,"D","P",ORIG,,$$FMADD^XLFDT(DT,-120))
 D CHKTF^%ut(+%=0)
 quit
 ;
TADDMEDADR6 ; @TEST Signs and symptoms singular (Cephalexin CD)
 ; ZEXCEPT: DFN
 N ORIG S ORIG=$O(^XUSEC("PROVIDER",""))
 N % S %=$$ADDMEDADR(DFN,309110,"D","A",ORIG,"HIVES",$$FMADD^XLFDT(DT,-120))
 D CHKTF^%ut(+%=0)
 quit
 ;
TADDMEDADR7 ; @TEST Signs and symptoms plural (Cephalexin IN)
 ; ZEXCEPT: DFN
 N ORIG S ORIG=$O(^XUSEC("PROVIDER",""))
 N % S %=$$ADDMEDADR(DFN,2231,"D","A",ORIG,"HIVES;RHINITIS;WHEEZING",$$FMADD^XLFDT(DT,-120))
 D CHKTF^%ut(+%=0)
 quit
 ;
TADDMEDADR8 ; @TEST Comments (Levothyroxine IN)
 ; ZEXCEPT: DFN
 N ORIG S ORIG=$O(^XUSEC("PROVIDER",""))
 N COMM S COMM(1)="This seems to only happen with specific forumlations of Synthroid"
 S COMM(2)="I think it's just the 125mcg (pink one)"
 N % S %=$$ADDMEDADR(DFN,10582,"D","A",ORIG,"HIVES;RHINITIS;WHEEZING",$$FMADD^XLFDT(DT,-120),.COMM)
 D CHKTF^%ut(+%=0)
 quit
 ;
TADDMEDERR1 ; @TEST Test error messages: -1 Bad Rxn
 ; ZEXCEPT: DFN
 N % S %=$$ADDMEDADR(DFN,83153328978194871234)
 D CHKTF^%ut(+%=-1)
 quit
TADDMEDERR2 ; @TEST Test error messages: -2 No VUID for Rxn - too hard
 ; ZEXCEPT: DFN
 quit
 ;
TADDMEDERR3 ; @TEST Test error messages: -3 NDF product cannot be found - too hard
 ; ZEXCEPT: DFN
 quit
 ;
TADDMEDERR4 ; @TEST Test error messages: -4 Bad S/S
 ; ZEXCEPT: DFN
 N ORIG S ORIG=$O(^XUSEC("PROVIDER",""))
 N % S %=$$ADDMEDADR(DFN,309110,"D","A",ORIG,"OIUSLDFKJLSKDJF",$$FMADD^XLFDT(DT,-120))
 D CHKTF^%ut(+%=-4)
 quit
 ;
TADDMEDERR5 ; @TEST Test error message: -5 API error
 ; ZEXCEPT: DFN
 N ORIG S ORIG=$O(^XUSEC("PROVIDER",""))
 N % S %=$$ADDMEDADR(DFN,2231,"D","A",ORIG,"HIVES;RHINITIS;WHEEZING",$$FMADD^XLFDT(DT,-120))
 D CHKTF^%ut(+%=-5)
 quit
 ;
SHUTDOWN ; M-UNIT SHUTDOWN
 ; ZEXCEPT: DFN
 K DFN
 QUIT
 ;

SYNFAPT
SYNFAPT ;ven/gpl - fhir loader utilities ; 2/20/18 4:11am
        ;;1.0;fhirloader;;oct 19, 2017;Build 2
        ;
        ; Authored by George P. Lilly 2017-2018
        ;
        q
        ;
importAppointment(rtn,ien,args) ; entry point for loading Appointment for a patient
        ; calls the intake Appointment web service directly
        ;
        n grtn
        n root s root=$$setroot^%wd("fhir-intake")
        d wsIntakeAppointment(.args,,.grtn,ien)
        i $d(grtn) d  ; something was returned
        . k @root@(ien,"load","appointment")
        . m @root@(ien,"load","appointment")=grtn("appointment")
        . if $g(args("debug"))=1 m rtn=grtn
        s rtn("conditionsStatus","status")=$g(grtn("status","status"))
        s rtn("conditionsStatus","loaded")=$g(grtn("status","loaded"))
        s rtn("conditionsStatus","errors")=$g(grtn("status","errors"))
        ;b
        ;
        ;
        q
        ;
wsIntakeAppointment(args,body,result,ien)       ; web service entry (post)
        ; for intake of one or more Appointment. input are fhir resources
        ; result is json and summarizes what was done
        ; args include patientId
        ; ien is specified for internal calls, where the json is already in a graph
        n jtmp,json,jrslt,eval
        i $g(ien)'="" d  ; internal call
        . d getIntakeFhir^SYNFHIR("json",,"Appointment",ien,1)
        e  d  ; 
        . s args("load")=0
        . merge jtmp=BODY
        . do DECODE^VPRJSON("jtmp","json")
        if '$d(json) d  ; if no appointment, get a random set of appointments
        . d getRandomApt(.json) ; get a random set of appointments
        i '$d(json) q  ;
        m ^gpl("gjson")=json
        ;b
        ;
        ; determine the patient
        ;
        n dfn,eval
        if $g(ien)'="" d  ;
        . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
        else  d  ;
        . s dfn=$g(args("dfn"))
        . i dfn="" d  ;
        . . n icn s icn=$g(args("icn"))
        . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
        i $g(dfn)="" do  quit  ; need the patient
        . s result("appointment",1,"log",1)="Error, patient not found.. terminating"
        ;
        ;
        new zi s zi=0
        for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
        . ;
        . ; define a place to log the processing of this entry
        . ;
        . new jlog set jlog=$name(eval("appointment",zi))
        . ;
        . ; insure that the resourceType is Apppointment
        . ;
        . new type set type=$get(json("entry",zi,"resource","resourceType"))
        . if type'="Appointment" do  quit  ;
        . . set eval("appointment",zi,"vars","resourceType")=type
        . . do log(jlog,"Resource type not Appointment, skipping entry")
        . set eval("appointment",zi,"vars","resourceType")=type
        . ;
        . ; see if this resource has already been loaded. if so, skip it
        . ;
        . if $g(ien)'="" if $$loadStatus("appointment",zi,ien)=1 do  quit  ;
        . . d log(jlog,"Appointment already loaded, skipping")
        . ;
        . ; determine the id of the resource
        . ;
        . ;new id set id=$get(json("entry",zi,"resource","id"))
        . ;set eval("appointment",zi,"vars","id")=id
        . ;d log(jlog,"ID is: "_id)
        . ;
        . ; determine the onset date and time
        . ;
        . new startdate set startdate=$get(json("entry",zi,"resource","start"))
        . do log(jlog,"startDateTime is: "_startdate)
        . set eval("appointment",zi,"vars","startDateTime")=startdate
        . new fmStartDateTime s fmStartDateTime=$$fhirTfm^SYNFUTL(startdate)
        . d log(jlog,"fileman startDateTime is: "_fmStartDateTime)
        . set eval("appointment",zi,"vars","fmStarttDateTime")=fmStartDateTime ;
        . new hl7StartDateTime s hl7StartDateTime=$$fhirThl7^SYNFUTL(startdate)
        . d log(jlog,"hl7 startDateTime is: "_hl7StartDateTime)
        . set eval("appointment",zi,"vars","hl7StartDateTime")=hl7StartDateTime ;
        . ;
        . ; determine clinical status (active vs inactive)
        . ;
        . n clinicalstatus set clinicalstatus=$get(json("entry",zi,"resource","status"))
        . ;
        . ; set up to call the data loader
        . ;
        . ;APPTADD(RETSTA,DHPPAT,DHPCLIN,DHPAPTDT,DHPLEN) ;Create appointment
        . ;
        . ; Input:
        . ;   DHPPAT   - Patient ICN (required)
        . ;   DHPCLIN  - Clinic Name (required)
        . ;   DHPAPTDT - Appointment Date & Time (required) all dates received in HL7 format
        . ;   DHPLEN   - Appointment length as minutes (optional, defaults to 15 mins.)
        . ;
        . ; Output:   RETSTA
        . ;  1 - success
        . ; -1 - failure -1^message
        . ;
        . n RETSTA,DHPPAT,DHPCLIN,DHPAPTDT,DHPLEN,DHPCIDT,DHPCODT
        . s (RETSTA,DHPPAT,DHPCLIN,DHPAPTDT,DHPLEN,DHPCIDT,DHPCODT)=""      ;Appointment update
        . ;
        . s DHPPAT=$$dfn2icn^SYNFUTL(dfn)
        . s eval("appointment",zi,"parms","DHPPAT")=DHPPAT
        . ;
        . s DHPAPTDT=hl7StartDateTime
        . s eval("appointment",zi,"parms","DHPAPTDT")=DHPAPTDT
        . ;
        . ;s DHPPROV=$$MAP^SYNQLDM("OP","provider") ; map should return the NPI number
        . ;n DHPPROVIEN s DHPPROVIEN=$o(^VA(200,"B",DHPPROV,""))
        . ;if DHPPROVIEN="" S DHPPROVIEN=3
        . ;s eval("appointment",zi,"parms","DHPPROV")=DHPPROV
        . ; log(jlog,"Provider NPI for outpatient is: "_DHPPROV)
        . ;
        . s DHPCLIN=$$MAP^SYNQLDM("OP","location")
        . n DHPLOCIEN s DHPLOCIEN=$o(^SC("B",DHPCLIN,""))
        . if DHPLOCIEN="" S DHPLOCIEN=4 S DHPCLIN=$$GET1^DIQ(44,DHPLOCIEN_",",.01)
        . s eval("appointment",zi,"parms","DHPCLIN")=DHPCLIN
        . d log(jlog,"Location for outpatient is: #"_DHPLOCIEN_" "_DHPCLIN)
        . ;
        . s eval("appointment",zi,"status","loadstatus")="readyToLoad"
        . ;
        . if $g(args("load"))=1 d  ; only load if told to
        . . if $g(ien)'="" if $$loadStatus("appointment",zi,ien)=1 do  quit  ;
        . . . d log(jlog,"Appointment already loaded, skipping")
        . . d log(jlog,"Calling APPTUPDT^SYNDHP62 to add appointment")
        . . D APPTADD^SYNDHP62(.RETSTA,DHPPAT,DHPCLIN,DHPAPTDT,DHPLEN) ;Create appointment
        . . ;D APPTUPDT^SYNDHP62(.RETSTA,DHPPAT,DHPCLIN,DHPAPTDT,DHPLEN,DHPCIDT,DHPCODT)        ;Appointment update
        . . m eval("appointment",zi,"status")=RETSTA
        . . d log(jlog,"Return from data loader was: "_$g(RETSTA))
        . . if +$g(RETSTA)=1 do  ;
        . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
        . . . s eval("appointment",zi,"status","loadstatus")="loaded"
        . . else  d  ;
        . . . s eval("status","errors")=$g(eval("status","errors"))+1
        . . . s eval("appointment",zi,"status","loadstatus")="notLoaded"
        . . . s eval("appointment",zi,"status","loadMessage")=$g(RETSTA)
        . . n root s root=$$setroot^%wd("fhir-intake")
        . . k @root@(ien,"load","appointment",zi)
        . . m @root@(ien,"load","appointment",zi)=eval("appointment",zi)
        ;
        if $get(args("debug"))=1 do  ;
        . m jrslt("source")=json
        . m jrslt("args")=args
        . m jrslt("eval")=eval
        m jrslt("appointmentStatus")=eval("appointmentStatus")
        set jrslt("result","status")="ok"
        set jrslt("result","loaded")=$g(eval("status","loaded"))
        i $g(ien)'="" d  ; called internally
        . m result=eval
        . m result("status")=jrslt("result")
        . m result("dfn")=dfn
        . m result("ien")=ien
        . ;b
        e  d  ;
        . d ENCODE^VPRJSON("jrslt","result")
        . set HTTPRSP("mime")="application/json" 
        q
        ;
log(ary,txt)    ; adds a text line to @ary@("log")
        s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
        q
        ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
        n root s root=$$setroot^%wd("fhir-intake")
        n rt s rt=0
        i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
        i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
        q rt
        ;
testall ; run the appointment import on all imported patients
        new root s root=$$setroot^%wd("fhir-intake")
        new indx s indx=$na(@root@("POS","DFN"))
        n dfn,ien,filter,reslt
        s dfn=0
        f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
        . s ien=$o(@indx@(dfn,""))
        . q:ien=""
        . s filter("dfn")=dfn
        . k reslt
        . d wsIntakeAppointment(.filter,,.reslt,ien)
        q
        ;
testone(reslt,doload)   ; run the appointment import on imported patient
        new root s root=$$setroot^%wd("fhir-intake")
        new indx s indx=$na(@root@("POS","DFN"))
        n dfn,ien,filter
        n done s done=0
        s dfn=0
        f  s dfn=$o(@indx@(dfn)) q:+dfn=0  q:done   d  ;
        . s ien=$o(@indx@(dfn,""))
        . q:ien=""
        . q:$d(@root@(ien,"load","appointment"))
        . s filter("dfn")=dfn
        . s filter("debug")=1
        . i $g(doload)=1 s filter("load")=1
        . k reslt
        . ;w !,"loading appointments for ien=",ien,!
        . d wsIntakeAppointment(.filter,,.reslt,ien)
        . ;zwr reslt
        . s done=1
        q
        ;
getRandomApt(ary)       ; make a web service call to get random appointments
        n srvr
        s srvr="http://postfhir.vistaplex.org:9080/"
        i srvr["postfhir.vistaplex.org" s srvr="http://138.197.70.229:9080/"
        i $g(^%WURL)["http://postfhir.vistaplex.org:9080" d  q  ;
        . s srvr="localhost:9080/"
        . n url
        . s url=srvr_"randomappointment"
        . n ok,r1
        . s ok=$$%^%WC(.r1,"GET",url)
        . i '$d(r1) q  ;
        . d DECODE^VPRJSON("r1","ary")
        n url
        s url=srvr_"randomAllergy"
        n ret,json,jtmp
        s ret=$$GETURL^XTHC10(url,,"jtmp")
        d assemble^SYNFPUL("jtmp","json")
        i '$d(json) q  ;
        d DECODE^VPRJSON("json","ary")
        q
        ;

SYNFCON
SYNFCON ;ven/gpl - fhir loader utilities ; 10/19/17 4:33pm
        ;;1.0;fhirloader;;oct 19, 2017;Build 2
        ;
        ; Authored by George P. Lilly 2017-2018
        ;
        q
        ;
importConditions(rtn,ien,args)  ; entry point for loading conditions for a patient
        ; calls the intake Conditions web service directly
        ;
        n grtn
        n root s root=$$setroot^%wd("fhir-intake")
        d wsIntakeConditions(.args,,.grtn,ien)
        i $d(grtn) d  ; something was returned
        . k @root@(ien,"load","conditions")
        . m @root@(ien,"load","conditions")=grtn("conditions")
        . if $g(args("debug"))=1 m rtn=grtn
        s rtn("conditionsStatus","status")=$g(grtn("status","status"))
        s rtn("conditionsStatus","loaded")=$g(grtn("status","loaded"))
        s rtn("conditionsStatus","errors")=$g(grtn("status","errors"))
        ;b
        ;
        ;
        q
        ;
wsIntakeConditions(args,body,result,ien)        ; web service entry (post)
        ; for intake of one or more Conditions. input are fhir resources
        ; result is json and summarizes what was done
        ; args include patientId
        ; ien is specified for internal calls, where the json is already in a graph
        n jtmp,json,jrslt,eval
        ;i $g(ien)'="" if $$loadStatus("conditions","",ien)=1 d  q  ;
        ;. s result("conditionsStatus","status")="alreadyLoaded"
        i $g(ien)'="" d  ; internal call
        . d getIntakeFhir^SYNFHIR("json",,"Condition",ien,1)
        e  d  ; 
        . s args("load")=0
        . merge jtmp=BODY
        . do DECODE^VPRJSON("jtmp","json")
        i '$d(json) q  ;
        m ^gpl("gjson")=json
        ;
        ; determine the patient
        ;
        n dfn,eval
        if $g(ien)'="" d  ;
        . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
        else  d  ;
        . s dfn=$g(args("dfn"))
        . i dfn="" d  ;
        . . n icn s icn=$g(args("icn"))
        . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
        i $g(dfn)="" do  quit  ; need the patient
        . s result("conditions",1,"log",1)="Error, patient not found.. terminating"
        ;
        ;
        new zi s zi=0
        for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
        . ;
        . ; define a place to log the processing of this entry
        . ;
        . new jlog set jlog=$name(eval("conditions",zi))
        . ;
        . ; insure that the resourceType is Condition
        . ;
        . new type set type=$get(json("entry",zi,"resource","resourceType"))
        . if type'="Condition" do  quit  ;
        . . set eval("conditions",zi,"vars","resourceType")=type
        . . do log(jlog,"Resource type not Condition, skipping entry")
        . set eval("conditions",zi,"vars","resourceType")=type
        . ;
        . ; see if this resource has already been loaded. if so, skip it
        . ;
        . if $g(ien)'="" if $$loadStatus("conditions",zi,ien)=1 do  quit  ;
        . . d log(jlog,"Vital sign already loaded, skipping")
        . ;
        . ; determine Conditions code, coding system, and display text
        . ;
        . ;
        . ; determine the id of the resource
        . ;
        . new id set id=$get(json("entry",zi,"resource","id"))
        . set eval("conditions",zi,"vars","id")=id
        . d log(jlog,"ID is: "_id)
        . ;
        . new concode set concode=$get(json("entry",zi,"resource","code","coding",1,"code"))
        . do log(jlog,"code is: "_concode)
        . set eval("conditions",zi,"vars","code")=concode
        . ;
        . ;
        . new codesystem set codesystem=$get(json("entry",zi,"resource","code","coding",1,"system"))
        . do log(jlog,"code system is: "_codesystem)
        . set eval("conditions",zi,"vars","codeSystem")=codesystem
        . ;
        . ; determine the code display text
        . ;
        . new context s context=$get(json("entry",zi,"resource","code","coding",1,"display"))
        . do log(jlog,"display text is: "_context)
        . set eval("conditions",zi,"vars","text")=context
        . ;
        . ; determine the effective date
        . ;
        . new effdate set effdate=$get(json("entry",zi,"resource","onsetDateTime"))
        . do log(jlog,"effectiveDateTime is: "_effdate)
        . set eval("conditions",zi,"vars","effectiveDateTime")=effdate
        . new fmtime s fmtime=$$fhirTfm^SYNFUTL(effdate)
        . d log(jlog,"fileman dateTime is: "_fmtime)
        . set eval("conditions",zi,"vars","fmDateTime")=fmtime ;
        . new hl7time s hl7time=$$fhirThl7^SYNFUTL(effdate)
        . d log(jlog,"hl7 dateTime is: "_hl7time)
        . set eval("conditions",zi,"vars","hl7DateTime")=hl7time ;
        . ;
        . ; determine the abatement date
        . ;
        . new abatedate set abatedate=$get(json("entry",zi,"resource","abatementDateTime"))
        . do log(jlog,"abatementDateTime is: "_abatedate)
        . set eval("conditions",zi,"vars","abatementDateTime")=effdate
        . new fmtime s fmtime=$$fhirTfm^SYNFUTL(abatedate)
        . d log(jlog,"fileman abatementDateTime is: "_fmtime)
        . set eval("conditions",zi,"vars","fmAbatementDateTime")=fmtime ;
        . new hl7time s hl7time=$$fhirThl7^SYNFUTL(abatedate)
        . d log(jlog,"hl7 abatementDateTime is: "_hl7time)
        . set eval("conditions",zi,"vars","hl7AbatementDateTime")=hl7time ;
        . ;
        . ; determine the status
        . ;
        . n constatus s constatus=$get(json("entry",zi,"resource","clinicalStatus"))
        . do log(jlog,"Clinical Status is: "_constatus)
        . set eval("conditions",zi,"vars","clinicalStatus")=constatus
        . ;
        . ; set up to call the data loader
        . ;
        . n RETSTA,DHPPAT,DHPSCT,DHPDTM,DHPPROV,DHPLOC,DHPTXT
        . ;
        . s DHPPAT=$$dfn2icn^SYNFUTL(dfn)
        . s eval("conditions",zi,"parms","DHPPAT")=DHPPAT
        . ;
        . s DHPSCT=concode
        . s eval("conditions",zi,"parms","DHPSCT")=DHPSCT
        . ;
        . s DHPTXT=context
        . s eval("conditions",zi,"parms","DHPTXT")=DHPTXT
        . ;
        . ;
        . s DHPDTM=hl7time
        . s eval("conditions",zi,"parms","DHPDTM")=hl7time
        . d log(jlog,"HL7 DateTime is: "_hl7time)
        . ;
        . s DHPPROV=$$MAP^SYNQLDM("OP","provider")
        . n DHPPROVIEN s DHPPROVIEN=$o(^VA(200,"B",DHPPROV,""))
        . if DHPPROVIEN="" S DHPPROVIEN=3
        . s eval("conditions",zi,"parms","DHPPROV")=DHPPROVIEN
        . d log(jlog,"Provider for outpatient is: #"_DHPPROVIEN_" "_DHPPROV)
        . ;
        . s DHPLOC=$$MAP^SYNQLDM("OP","location")
        . n DHPLOCIEN s DHPLOCIEN=$o(^SC("B",DHPLOC,""))
        . if DHPLOCIEN="" S DHPLOCIEN=4
        . s eval("conditions",zi,"parms","DHPLOC")=DHPLOCIEN
        . d log(jlog,"Location for outpatient is: #"_DHPLOCIEN_" "_DHPLOC)
        . ;
        . s eval("conditions",zi,"status","loadstatus")="readyToLoad"
        . ;
        . if $g(args("load"))=1 d  ; only load if told to
        . . if $g(ien)'="" if $$loadStatus("conditions",zi,ien)=1 do  quit  ;
        . . . d log(jlog,"Vital sign already loaded, skipping")
        . . d log(jlog,"Calling data loader to add encounter")
        . . d log(jlog,"Return from data loader was: "_$g(RETSTA))
        . . if +$g(RETSTA)=1 do  ;
        . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
        . . . s eval("conditions",zi,"status","loadstatus")="loaded"
        . . else  s eval("status","errors")=$g(eval("status","errors"))+1
        ;
        if $get(args("debug"))=1 do  ;
        . m jrslt("source")=json
        . m jrslt("args")=args
        . m jrslt("eval")=eval
        m jrslt("conditionsStatus")=eval("conditionsStatus")
        set jrslt("result","status")="ok"
        set jrslt("result","loaded")=$g(eval("status","loaded"))
        i $g(ien)'="" d  ; called internally
        . m result=eval
        . m result("status")=jrslt("result")
        . ;b
        e  d  ;
        . d ENCODE^VPRJSON("jrslt","result")
        . set HTTPRSP("mime")="application/json" 
        q
        ;
log(ary,txt)    ; adds a text line to @ary@("log")
        s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
        q
        ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
        n root s root=$$setroot^%wd("fhir-intake")
        n rt s rt=0
        i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
        i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
        q rt
        ;
testall ; run the conditions import on all imported patients
        new root s root=$$setroot^%wd("fhir-intake")
        new indx s indx=$na(@root@("POS","DFN"))
        n dfn,ien,filter,reslt
        s dfn=0
        f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
        . s ien=$o(@indx@(dfn,""))
        . q:ien=""
        . s filter("dfn")=dfn
        . k reslt
        . d wsIntakeConditions(.filter,,.reslt,ien)
        q
        ;

SYNFENC
SYNFENC ;ven/gpl - fhir loader utilities ; 2/24/18 9:56pm
        ;;1.0;fhirloader;;oct 19, 2017;Build 2
        ;
        ; Authored by George P. Lilly 2017-2018
        ;
        q
        ;
importEncounters(rtn,ien,args)  ; entry point for loading encounters for a patient
        ; calls the intake Encounters web service directly
        ;
        n grtn
        n root s root=$$setroot^%wd("fhir-intake")
        d wsIntakeEncounters(.args,,.grtn,ien)
        i $d(grtn) d  ; something was returned
        . k @root@(ien,"load","encounters")
        . m @root@(ien,"load","encounters")=grtn("encounters")
        . if $g(args("debug"))=1 m rtn=grtn
        s rtn("encountersStatus","status")=$g(grtn("status","status"))
        s rtn("encountersStatus","loaded")=$g(grtn("status","loaded"))
        s rtn("encountersStatus","errors")=$g(grtn("status","errors"))
        ;b
        ;
        ;
        q
        ;
wsIntakeEncounters(args,body,result,ien)        ; web service entry (post)
        ; for intake of one or more Encounters. input are fhir resources
        ; result is json and summarizes what was done
        ; args include patientId
        ; ien is specified for internal calls, where the json is already in a graph
        n jtmp,json,jrslt,eval
        ;i $g(ien)'="" if $$loadStatus("encounters","",ien)=1 d  q  ;
        ;. s result("encountersStatus","status")="alreadyLoaded"
        i $g(ien)'="" d  ; internal call
        . d getIntakeFhir^SYNFHIR("json",,"Encounter",ien,1)
        e  d  ; 
        . ;s args("load")=0
        . merge jtmp=BODY
        . do DECODE^VPRJSON("jtmp","json")
        i '$d(json) q  ;
        m ^gpl("gjson")=json
        ;
        ; determine the patient
        ;
        n dfn,eval
        if $g(ien)'="" d  ;
        . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
        else  d  ;
        . s dfn=$g(args("dfn"))
        . i dfn="" d  ;
        . . n icn s icn=$g(args("icn"))
        . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
        i $g(dfn)="" do  quit  ; need the patient
        . s result("encounters",1,"log",1)="Error, patient not found.. terminating"
        ;
        ;
        new zi s zi=0
        for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
        . ;
        . ; define a place to log the processing of this entry
        . ;
        . new jlog set jlog=$name(eval("encounters",zi))
        . ;
        . ; insure that the resourceType is Observation
        . ;
        . new type set type=$get(json("entry",zi,"resource","resourceType"))
        . if type'="Encounter" do  quit  ;
        . . set eval("encounters",zi,"vars","resourceType")=type
        . . do log(jlog,"Resource type not Observation, skipping entry")
        . set eval("encounters",zi,"vars","resourceType")=type
        . ;
        . ; see if this resource has already been loaded. if so, skip it
        . ;
        . if $g(ien)'="" if $$loadStatus("encounters",zi,ien)=1 do  quit  ;
        . . d log(jlog,"Vital sign already loaded, skipping")
        . ;
        . ; determine Encounters code, coding system, and display text
        . ;
        . ;
        . ; determine the id of the resource
        . ;
        . new id set id=$get(json("entry",zi,"resource","id"))
        . set eval("encounters",zi,"vars","id")=id
        . d log(jlog,"ID is: "_id)
        . ;
        . new enccode set enccode=$get(json("entry",zi,"resource","type",1,"coding",1,"code"))
        . do log(jlog,"code is: "_enccode)
        . set eval("encounters",zi,"vars","code")=enccode
        . ;
        . ;
        . new codesystem set codesystem=$get(json("entry",zi,"resource","type",1,"coding",1,"system"))
        . do log(jlog,"code system is: "_codesystem)
        . set eval("encounters",zi,"vars","codeSystem")=codesystem
        . ;
        . ; determine the reason code and system (Encounter Diagnosis)
        . ;
        . n reasoncode s reasoncode=$get(json("entry",zi,"resource","reason","coding",1,"code"))
        . d log(jlog,"reasonCode is: "_reasoncode)
        . set eval("encounters",zi,"vars","reasonCode")=reasoncode
        . ;
        . ; determine reason code system
        . ;
        . new reasoncdsys set reasoncdsys=$get(json("entry",zi,"resource","reason","coding",1,"system"))
        . d log(jlog,"reasonCode system is: "_reasoncdsys)
        . set eval("encounters",zi,"vars","reasonCodeSys")=reasoncdsys
        . ;
        . ; determine the effective date
        . ;
        . new effdate set effdate=$get(json("entry",zi,"resource","period","start"))
        . do log(jlog,"effectiveDateTime is: "_effdate)
        . set eval("encounters",zi,"vars","effectiveDateTime")=effdate
        . new fmtime s fmtime=$$fhirTfm^SYNFUTL(effdate)
        . d log(jlog,"fileman dateTime is: "_fmtime)
        . set eval("encounters",zi,"vars","fmDateTime")=fmtime ;
        . new hl7time s hl7time=$$fhirThl7^SYNFUTL(effdate)
        . d log(jlog,"hl7 dateTime is: "_hl7time)
        . set eval("encounters",zi,"vars","hl7DateTime")=hl7time ;
        . ;
        . new effdateEnd set effdateEnd=$get(json("entry",zi,"resource","period","end"))
        . do log(jlog,"endDateTime is: "_effdateEnd)
        . set eval("encounters",zi,"vars","endDateTime")=effdateEnd
        . new fmtimeEnd s fmtimeEnd=$$fhirTfm^SYNFUTL(effdateEnd)
        . d log(jlog,"fileman endDateTime is: "_fmtimeEnd)
        . set eval("encounters",zi,"vars","fmEndDateTime")=fmtimeEnd ;
        . new hl7endTime s hl7endTime=$$fhirThl7^SYNFUTL(effdateEnd)
        . d log(jlog,"hl7 endDateTime is: "_hl7endTime)
        . set eval("encounters",zi,"vars","hl7endDateTime")=hl7endTime ;
        . ;
        . ; set up to call the data loader
        . ;
        . ;ENCTUPD(RETSTA,DHPPAT,STARTDT,ENDDT,ENCPROV,CLINIC,SCTDX,SCTCPT)     ;Encounter update
        . ;
        . n RETSTA,DHPPAT,STARTDT,ENDDT,ENCPROV,CLINIC,SCTDX,SCTCPT
        . ;
        . s DHPPAT=$$dfn2icn^SYNFUTL(dfn)
        . s eval("encounters",zi,"parms","DHPPAT")=DHPPAT
        . ;
        . s SCTCPT=enccode
        . s eval("encounters",zi,"parms","SCTCPT")=SCTCPT
        . ;
        . ; reason code
        . s SCTDX=reasoncode
        . s eval("encounters",zi,"parms","SCTDX")=SCTDX
        . ;
        . s STARTDT=hl7time
        . s eval("encounters",zi,"parms","STARTDT")=hl7time
        . d log(jlog,"HL7 StartDateTime is: "_hl7time)
        . ;
        . s ENDDT=hl7endTime
        . s eval("encounters",zi,"parms","ENDDT")=ENDDT
        . d log(jlog,"HL7 End DateTime is: "_ENDDT)
        . ;
        . s ENCPROV=$$MAP^SYNQLDM("OP","provider") ; map should return the NPI number
        . ;n DHPPROVIEN s DHPPROVIEN=$o(^VA(200,"B",ENCPROV,"")) ; this has to be the NPI number
        . ;if DHPPROVIEN="" S DHPPROVIEN=3
        . s eval("encounters",zi,"parms","ENCPROV")=ENCPROV
        . d log(jlog,"Provider for outpatient is: "_ENCPROV)
        . ;
        . s CLINIC=$$MAP^SYNQLDM("OP","location") ; map containes the name of the clinic file #44
        . ;n DHPLOCIEN s DHPLOCIEN=$o(^SC("B",CLINIC,""))
        . ;if DHPLOCIEN="" S DHPLOCIEN=4
        . s eval("encounters",zi,"parms","CLINIC")=CLINIC
        . d log(jlog,"Location for outpatient is: "_CLINIC)
        . ;
        . s eval("encounters",zi,"status","loadstatus")="readyToLoad"
        . ;
        . if $g(args("load"))=1 d  ; only load if told to
        . . if $g(ien)="" n ien s ien=$$dfn2ien^SYNFUTL(dfn)
        . . i ien="" q  ;
        . . if $$loadStatus("encounters",zi,ien)=1 do  quit  ;
        . . . d log(jlog,"Encounter already loaded, skipping")
        . . d log(jlog,"Calling ENCTUPD^SYNDHP61 data loader to add encounter")
        . . d ENCTUPD^SYNDHP61(.RETSTA,DHPPAT,STARTDT,ENDDT,ENCPROV,CLINIC,SCTDX,SCTCPT)        ;Encounter update
        . . d log(jlog,"Return from data loader was: "_$g(RETSTA))
        . . ;
        . . m eval("encounters",zi,"status","return")=RETSTA
        . . i $g(DEBUG)=1 ZWR RETSTA
        . . n root s root=$$setroot^%wd("fhir-intake")
        . . n visitIen s visitIen=$p(RETSTA,"^",2) ; returned visit ien
        . . i +visitIen>0 d
        . . . ;
        . . . n groot s groot=$na(@root@(ien))
        . . . d setIndex^SYNFHIR(groot,id,"visitIen",visitIen) ; save the visit ien in the indexes
        . . . s eval("encounters",zi,"visitIen")=visitIen
        . . e  s visitIen=""
        . . if +$g(RETSTA)=1 do  ;
        . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
        . . . s eval("encounters",zi,"status","loadstatus")="loaded"
        . . else  d  ;
        . . . s eval("status","errors")=$g(eval("status","errors"))+1
        . . . s eval("encounters",zi,"status","loadstatus")="notLoaded"
        . . . s eval("encounters",zi,"status","loadMessage")=$g(RETSTA)
        . . k @root@(ien,"load","encounters",zi)
        . . m @root@(ien,"load","encounters",zi)=eval("encounters",zi)
        ;
        if $get(args("debug"))=1 do  ;
        . m jrslt("source")=json
        . m jrslt("args")=args
        . m jrslt("eval")=eval
        m jrslt("encountersStatus")=eval("encountersStatus")
        set jrslt("result","status")="ok"
        set jrslt("result","loaded")=$g(eval("status","loaded"))
        i $g(ien)'="" d  ; called internally
        . m result=eval
        . m result("status")=jrslt("result")
        . ;b
        e  d  ;
        . d ENCODE^VPRJSON("jrslt","result")
        . set HTTPRSP("mime")="application/json" 
        q
        ;
log(ary,txt)    ; adds a text line to @ary@("log")
        s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
        w:$G(DEBUG) !,"      ",$G(txt)
        q
        ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
        n root s root=$$setroot^%wd("fhir-intake")
        n rt s rt=0
        i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
        i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
        q rt
        ;
visitIen(ien,encId)     ; extrinsic returns the visit ien for the Encounter ID
        ; returns -1 if none found
        i $g(encId)="" q -1
        n root s root=$$setroot^%wd("fhir-intake")
        n vrtn
        s vrtn=$o(@root@(ien,"SPO",encId,"visitIen",""))
        i vrtn="" s vrtn=-1
        q vrtn
        ;
testall ; run the encounters import on all imported patients
        new root s root=$$setroot^%wd("fhir-intake")
        new indx s indx=$na(@root@("POS","DFN"))
        n dfn,ien,filter,reslt
        s dfn=0
        f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
        . s ien=$o(@indx@(dfn,""))
        . q:ien=""
        . s filter("dfn")=dfn
        . k reslt
        . d wsIntakeEncounters(.filter,,.reslt,ien)
        q
        ;
IMPORT(rtn,ien) ; encounters, immunizations, problems for patient ien
        n filter
        k rtn
        s filter("load")=1
        s filter("debug")=1
        d importEncounters^SYNFENC(.rtn,ien,.filter)
        d importImmu^SYNFIMM(.rtn,ien,.filter)
        d importConditions^SYNFPR2(.rtn,ien,.filter)
        q
        ;
        ;
LOADALL(count) ; count is how many to do. default is 1000
        i '$d(count) s count=1000
        n root s groot=$$setroot^%wd("fhir-intake")
        n cnt s cnt=0
        n %1 s %1=0
        f  s %1=$o(@groot@(%1)) q:+%1=0  q:cnt=count  d  ;
        . n eroot s eroot=$na(@groot@(%1,"load","encounters"))
        . q:$d(@eroot)
        . q:%1=33
        . q:%1=82
        . q:$g(@eroot@("loadstatus"))="started"
        . s cnt=cnt+1
        . s @eroot@("loadstatus")="started"
        . n filter
        . s filter("load")=1
        . n g s $p(g,"+",80)="" w !,g
        . w !,"loading "_%1_" "_$$FMTE^XLFDT($$NOW^XLFDT)
        . w !,g
        . n rtn
        . d importEncounters^SYNFENC(.rtn,%1,.filter)
        . d importImmu^SYNFIMM(.rtn,%1,.filter)
        . d importConditions^SYNFPRB(.rtn,%1,.filter)
        q
        ;
NEXT(start) ; extrinsic which returns the next patient for encounter loading    
            ; start is the dfn to start looking, default is zerro
        i '$d(start) s start=0
        n root s groot=$$setroot^%wd("fhir-intake")
        n %1 s %1=start
        n returnien s returnien=0
        f  s %1=$o(@groot@(%1)) q:+%1=0  q:+returnien>0  d  ;
        . n eroot s eroot=$na(@groot@(%1,"load","encounters"))
        . q:$d(@eroot)
        . q:%1=33
        . q:%1=82
        . q:$g(@eroot@("loadstatus"))="started"
        . s returnien=%1
        q returnien
        ;

SYNFGR
SYNFGR  ;ven/gpl - fhir loader utilities ; 2/23/18 5:51am
        ;;1.0;fhirloader;;oct 19, 2017;Build 2
        ;
        ; Authored by George P. Lilly 2017-2018
        ;
        q
               ;
resources(ary,lvl)      ; finds all the fhir resources and counts them up
        ; returns ary, passed by name
        ;
        n root s root=$$setroot^%wd("fhir-intake")
        n ien,rien
        s (ien,rien)=0
        f  s ien=$o(@root@(ien)) q:+ien=0  d  ;
        . s rien=0
        . f  s rien=$o(@root@(ien,"json","entry",rien)) q:+rien=0  d  ;
        . . n rtype,rtext,rcode
        . . s rtype=$g(@root@(ien,"json","entry",rien,"resource","resourceType"))
        . . q:rtype=""
        . . s @ary@(rtype)=$g(@ary@(rtype))+1
        . . q:$g(lvl)<2
        . . i rtype="Goal" d  ;
        . . . s rtext=$g(@root@(ien,"json","entry",rien,"resource","description","text"))
        . . . q:rtext=""
        . . . s @ary@(rtype,rtext)=$g(@ary@(rtype,rtext))+1
        . . i rtype="Observation" d  ;
        . . . s rtext=$g(@root@(ien,"json","entry",rien,"resource","category",1,"coding",1,"code"))
        . . . q:rtext=""
        . . . ;i rtext="procedure" b
        . . . s @ary@(rtype,rtext)=$g(@ary@(rtype,rtext))+1
        . . i rtype="Procedure" d  ;
        . . . s rtext=$g(@root@(ien,"json","entry",rien,"resource","code","text"))
        . . . q:rtext=""
        . . . s rcode=$g(@root@(ien,"json","entry",rien,"resource","code","coding",1,"code"))
        . . . q:rcode=""
        . . . s @ary@(rtype,rtext,rcode)=$g(@ary@(rtype,rtext,rcode))+1
        . . i rtype="DiagnosticReport" d  ;
        . . . s rtext=$g(@root@(ien,"json","entry",rien,"resource","code","coding",1,"display"))
        . . . q:rtext=""
        . . . s @ary@(rtype,rtext)=$g(@ary@(rtype,rtext))+1
        q
        ;

SYNFHIR
SYNFHIR ;ven/gpl - fhir loader utilities ; 2/24/18 8:23pm
        ;;1.0;fhirloader;;oct 19, 2017;Build 12
        ;
        ; Authored by George P. Lilly 2017-2018
        ;
        q
        ;
wsPostFHIR(ARGS,BODY,RESULT)    ; recieve from addpatient
        ;
        s U="^"
        S DUZ=1
        S DUZ("AG")="V"
        ;
        new json,ien,root,gr,id,return
        set root=$$setroot^%wd("fhir-intake")
        set id=$get(ARGS("id"))
        ;
        set ien=$order(@root@(" "),-1)+1
        set gr=$name(@root@(ien,"json"))
        merge json=BODY
        do DECODE^VPRJSON("json",gr)
        do indexFhir(ien)
        ;
        if id'="" do  ;
        . set @root@("B",id,ien)=""
        else  do  ;
        . ;
        ;
        if $get(ARGS("returngraph"))=1 do  ;
        . merge return("graph")=@root@(ien,"graph")
        set return("status")="ok"
        set return("id")=id
        set return("ien")=ien
        ;
        do importPatient^SYNFPAT(.return,ien)
        ;
        new rdfn set rdfn=$get(return("dfn"))
        if rdfn'="" set @root@("DFN",rdfn,ien)=""
        ;
        if rdfn'="" do  ; patient creation was successful
        . if $g(ARGS("load"))="" s ARGS("load")=1
        . do importVitals^SYNFVIT(.return,ien,.ARGS)
        . do importEncounters^SYNFENC(.return,ien,.ARGS)
        . do importImmu^SYNFIMM(.return,ien,.ARGS)
        . do importConditions^SYNFPRB(.return,ien,.ARGS)
        . do importAllergy^SYNFALG(.return,ien,.ARGS)
        . do importAppointment^SYNFAPT(.return,ien,.ARGS)
        ;
        do ENCODE^VPRJSON("return","RESULT")
        set HTTPRSP("mime")="application/json"
        ;
        quit 1
        ;
indexFhir(ien)  ; generate indexes for parsed fhir json
        ;
        new root set root=$$setroot^%wd("fhir-intake")
        if $get(ien)="" quit  ;
        ;
        new jroot set jroot=$name(@root@(ien,"json","entry")) ; root of the json
        if '$data(@jroot) quit  ; can't find the json to index
        ;
        new jindex set jindex=$name(@root@(ien)) ; root of the index
        d clearIndexes(jindex)
        ;
        new %wi s %wi=0
        for  set %wi=$order(@jroot@(%wi)) quit:+%wi=0  do  ;
        . new type
        . set type=$get(@jroot@(%wi,"resource","resourceType"))
        . if type="" do  quit  ;
        . . w !,"error resource type not found ien= ",ien," entry= ",%wi
        . set @jindex@("type",type,%wi)=""
        . d triples(jindex,$na(@jroot@(%wi)),%wi)
        quit
        ;
triples(index,ary,%wi)  ; index and array are passed by name
        ;
        i type="Patient" d  q  ;
        . n purl s purl=$g(@ary@("fullUrl"))
        . i purl="" s purl=type_"/"_$g(@ary@("resource","id"))
        . i $e(purl,$l(purl))="/" s purl=purl_%wi
        . d setIndex(index,purl,"type",type)
        . d setIndex(index,purl,"rien",%wi)
        i type="Encounter" d  q  ;
        . n purl s purl=$g(@ary@("fullUrl"))
        . i purl="" s purl=type_"/"_$g(@ary@("resource","id"))
        . i $e(purl,$l(purl))="/" s purl=purl_%wi
        . d setIndex(index,purl,"type",type)
        . d setIndex(index,purl,"rien",%wi)
        . n sdate s sdate=$g(@ary@("resource","period","start")) q:sdate=""
        . n hl7date s hl7date=$$fhirThl7^SYNFUTL(sdate)
        . d setIndex(index,purl,"dateTime",sdate)
        . d setIndex(index,purl,"hl7dateTime",hl7date)
        . n class s class=$g(@ary@("resource","class","code")) q:class=""
        . d setIndex(index,purl,"class",class)
        i type="Condition" d  q  ;
        . n purl s purl=$g(@ary@("fullUrl"))
        . i purl="" s purl=type_"/"_$g(@ary@("resource","id"))
        . i $e(purl,$l(purl))="/" s purl=purl_%wi
        . d setIndex(index,purl,"type",type)
        . d setIndex(index,purl,"rien",%wi)
        . n enc s enc=$g(@ary@("resource","context","reference")) q:enc=""
        . d setIndex(index,purl,"encounterReference",enc)
        . n pat s pat=$g(@ary@("resource","subject","reference")) q:pat=""
        . d setIndex(index,purl,"patientReference",pat)
        i type="Observation" d  q  ;
        . n purl s purl=$g(@ary@("fullUrl"))
        . i purl="" s purl=type_"/"_$g(@ary@("resource","id"))
        . i $e(purl,$l(purl))="/" s purl=purl_%wi
        . d setIndex(index,purl,"type",type)
        . d setIndex(index,purl,"rien",%wi)
        . n enc s enc=$g(@ary@("resource","context","reference")) q:enc=""
        . d setIndex(index,purl,"encounterReference",enc)
        . n pat s pat=$g(@ary@("resource","subject","reference")) q:pat=""
        . d setIndex(index,purl,"patientReference",pat)
        i type="Medication" d  q  ;
        . n purl s purl=$g(@ary@("fullUrl"))
        . i purl="" s purl=type_"/"_$g(@ary@("resource","id"))
        . i $e(purl,$l(purl))="/" s purl=purl_%wi
        . i purl="" s purl=type_"/"_$g(@ary@("resource","id"))
        . d setIndex(index,purl,"type",type)
        . d setIndex(index,purl,"rien",%wi)
        i type="medicationReference" d  q  ;
        . n purl s purl=$g(@ary@("fullUrl"))
        . i purl="" s purl=type_"/"_$g(@ary@("resource","id"))
        . i $e(purl,$l(purl))="/" s purl=purl_%wi
        . d setIndex(index,purl,"type",type)
        . d setIndex(index,purl,"rien",%wi)
        . n enc s enc=$g(@ary@("resource","context","reference")) q:enc=""
        . d setIndex(index,purl,"encounterReference",enc)
        . n pat s pat=$g(@ary@("resource","subject","reference")) q:pat=""
        . d setIndex(index,purl,"patientReference",pat)
        i type="Immunizationi" d  q  ;
        . n purl s purl=$g(@ary@("fullUrl"))
        . i purl="" s purl=type_"/"_$g(@ary@("resource","id"))
        . i $e(purl,$l(purl))="/" s purl=purl_%wi
        . d setIndex(index,purl,"type",type)
        . d setIndex(index,purl,"rien",%wi)
        . n enc s enc=$g(@ary@("resource","encounter","reference")) q:enc=""
        . d setIndex(index,purl,"encounterReference",enc)
        . n pat s pat=$g(@ary@("resource","patient","reference")) q:pat=""
        . d setIndex(index,purl,"patientReference",pat)
        n purl s purl=$g(@ary@("fullUrl"))
        i purl="" s purl=type_"/"_$g(@ary@("resource","id"))
        i $e(purl,$l(purl))="/" s purl=purl_%wi
        d setIndex(index,purl,"type",type)
        d setIndex(index,purl,"rien",%wi)
        n enc s enc=$g(@ary@("resource","context","reference")) q:enc=""
        d setIndex(index,purl,"encounterReference",enc)
        n pat s pat=$g(@ary@("resource","subject","reference")) q:pat=""
        d setIndex(index,purl,"patientReference",pat)
        q
        ;
setIndex(gn,sub,pred,obj)       ; set the graph indexices
        ;n gn s gn=$$setroot^%wd("fhir-intake")
        q:sub=""
        q:pred=""
        q:obj=""
        s @gn@("SPO",sub,pred,obj)=""
        s @gn@("POS",pred,obj,sub)=""
        s @gn@("PSO",pred,sub,obj)=""
        s @gn@("OPS",obj,pred,sub)=""
        q
        ;
clearIndexes(gn)        ; kill the indexes
        k @gn@("SPO")
        k @gn@("POS")
        k @gn@("PSO")
        k @gn@("OPS")
        q
        ;
wsShow(rtn,filter)      ; web service to show the fhir
        new ien set ien=$g(filter("ien"))
        if ien="" quit  ;
        new type set type=$get(filter("type"))
        new root set root=$$setroot^%wd("fhir-intake")
        new jroot set jroot=$name(@root@(ien,"json"))
        ;
        new jtmp,juse
        set juse=jroot
        if type'="" do  ;
        . do getIntakeFhir("jtmp",,type,ien,1)
        . set juse="jtmp"
        do ENCODE^VPRJSON(juse,"rtn")
        s HTTPRSP("mime")="application/json" 
        quit
        ;
getIntakeFhir(rtn,id,type,ien,plain)    ; returns fhir vars for patient id resourceType type
        ; id is optional
        ; if id is not specified, ien can be passed instead. 
        ; if id and ien are passed, only ien is used
        ; rtn passed by name. it will overlay results in @rtn, so is additive
        ; if plain is 1 then the array is returned without the type as the first 
        ;    element of each node
        ;
        new root set root=$$setroot^%wd("fhir-intake")
        if $g(ien)="" set ien=$order(@root@("B",id,""))
        if ien="" quit  ;
        ;
        if $get(type)="" set type="all"
        kill @rtn
        ;
        if type'="all" do  quit  ;
        . do get1FhirType(rtn,root,ien,type,$get(plain))
        ;
        new jindex set jindex=$name(@root@(ien))
        new %wj set %wj=""
        for  set %wj=$order(@jindex@("type",%wj)) quit:%wj=""  do  ;
        . ;w !,"type ",%wj
        . do get1FhirType(rtn,root,ien,%wj,$get(plain))
        ;
        quit
        ;
get1FhirType(rtn,root,ien,type,plain)   ; get one resourceType from the json
        new %wi set %wi=0
        new jindex set jindex=$name(@root@(ien))
        if '$data(@jindex@("type",type)) quit  ;
        for  s %wi=$order(@jindex@("type",type,%wi)) quit:+%wi=0  do  ;
        . if $get(plain)=1 merge @rtn@("entry",%wi)=@root@(ien,"json","entry",%wi)
        . else  merge @rtn@(type,"entry",%wi)=@root@(ien,"json","entry",%wi)
        quit
        ;
fhir2graph(in,out)      ; transforms fhir to a graph
        ; in and out are passed by name
        ; detects if json parser has been run and will run it if not
        ;
        new json
        if $ql($q(@in@("")))<2 do DECODE^VPRJSON(in,"json") set in="json"
        ;
        new rootj
        set rootj=$na(@in@("entry"))
        new i,cnt
        for i=1:1:$order(@rootj@(" "),-1) do  ;
        . new rname
        . set rname=$get(@rootj@(i,"resource","resourceType"))
        . if rname="" do  quit  ;
        . . w !,"error no resourceType in entry: ",i
        . . zwr @rootj@(i,*)
        . . b
        . if '$data(@out@(rname)) set cnt=1
        . else  set cnt=$order(@out@(rname,""),-1)+1
        . merge @out@(rname,cnt)=@rootj@(i,"resource")
        quit
        ;
getEntry(ary,ien,rien) ; returns one entry in ary, passed by name
 n root s root=$$setroot^%wd("fhir-intake")
 i '$d(@root@(ien,"json","entry",rien)) q  ;
 m @ary@("entry",rien)=@root@(ien,"json","entry",rien)
 q
 ;
loadStatus(ary,ien,rien) ; returns the "load" section of the patient graph
 ; if rien is not specified, all entries are included
 n root s root=$$setroot^%wd("fhir-intake")
 i '$d(@root@(ien)) q  
 i $g(rien)="" d  q  ;
 . k @ary
 . m @ary@(ien)=@root@(ien,"load")
 n zi s zi=""
 f  s zi=$o(@root@(ien,"load",zi)) q:$d(@root@(ien,"load",zi,rien))
 k @ary
 m @ary@(ien,rien)=@root@(ien,"load",zi,rien)
 q
 ;
wsLoadStatus(rtn,filter) ; displays the load status 
 ; filter must have ien or dfn to specify the patient
 ; optionally, entry number (rien) for a single entry
 ; if ien and dfn are both specified, dfn is used
 ; now supports latest=1 to show the load status of the lastest added patient
 n root s root=$$setroot^%wd("fhir-intake")
 n ien s ien=$g(filter("ien"))
 i $g(filter("latest"))=1 d  ;
 . set ien=$o(@root@(" "),-1)
 n dfn s dfn=$g(filter("dfn"))
 i dfn'="" s ien=$$dfn2ien^SYNFUTL(dfn)
 n rien s rien=$g(filter("rien"))
 q:ien=""
 n load
 d loadStatus("load",ien,rien)
 s filter("root")="load"
 s filter("local")=1
 d wsGLOBAL^SYNVPR(.rtn,.filter)
 q
 ;

SYNFIMM
SYNFIMM ;ven/gpl - fhir loader utilities ;2018-05-08  4:38 PM
 ;;1.0;fhirloader;;oct 19, 2017;Build 2
 ;
 ; Authored by George P. Lilly 2017-2018
 ;
 q
 ;
importImmu(rtn,ien,args) ; entry point for loading Immunizations for a patient
 ; calls the intake Immunizations web service directly
 ;
 n grtn
 n root s root=$$setroot^%wd("fhir-intake")
 d wsIntakeImmu(.args,,.grtn,ien)
 i $d(grtn) d  ; something was returned
 . k @root@(ien,"load","immunizations")
 . m @root@(ien,"load","immunizations")=grtn("immunizations")
 . if $g(args("debug"))=1 m rtn=grtn
 s rtn("immunizationsStatus","status")=$g(grtn("status","status"))
 s rtn("immunizationsStatus","loaded")=$g(grtn("status","loaded"))
 s rtn("immunizationsStatus","errors")=$g(grtn("status","errors"))
 ;b
 ;
 ;
 q
 ;
wsIntakeImmu(args,body,result,ien) ; web service entry (post)
 ; for intake of one or more Immunizations. input are fhir resources
 ; result is json and summarizes what was done
 ; args include patientId
 ; ien is specified for internal calls, where the json is already in a graph
 n jtmp,json,jrslt,eval
 ;i $g(ien)'="" if $$loadStatus("immunizations","",ien)=1 d  q  ;
 ;. s result("immunizationsStatus","status")="alreadyLoaded"
 i $g(ien)'="" d  ; internal call
 . d getIntakeFhir^SYNFHIR("json",,"Immunization",ien,1)
 e  d  ; 
 . s args("load")=0
 . merge jtmp=BODY
 . do DECODE^VPRJSON("jtmp","json")
 i '$d(json) q  ;
 m ^gpl("gjson")=json
 ;
 ; determine the patient
 ;
 n dfn,eval
 if $g(ien)'="" d  ;
 . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
 else  d  ;
 . s dfn=$g(args("dfn"))
 . i dfn="" d  ;
 . . n icn s icn=$g(args("icn"))
 . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
 i $g(dfn)="" do  quit  ; need the patient
 . s result("immunizations",1,"log",1)="Error, patient not found.. terminating"
 ;
 ;
 new zi s zi=0
 for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
 . ;
 . ; define a place to log the processing of this entry
 . ;
 . new jlog set jlog=$name(eval("immunizations",zi))
 . ;
 . ; insure that the resourceType is Observation
 . ;
 . new type set type=$get(json("entry",zi,"resource","resourceType"))
 . if type'="Immunization" do  quit  ;
 . . set eval("immunizations",zi,"vars","resourceType")=type
 . . do log(jlog,"Resource type not Immunization, skipping entry")
 . set eval("immunizations",zi,"vars","resourceType")=type
 . ;
 . ; see if this resource has already been loaded. if so, skip it
 . ;
 . if $g(ien)'="" if $$loadStatus("immunization",zi,ien)=1 do  quit  ;
 . . d log(jlog,"Immunization already loaded, skipping")
 . ;
 . ; determine Immunization cvx code, coding system, and display text
 . ;
 . ;
 . ; determine the id of the resource
 . ;
 . ;new id set id=$get(json("entry",zi,"resource","id"))
 . ;set eval("immunizations",zi,"vars","id")=id
 . ;d log(jlog,"ID is: "_id)
 . ;
 . new cvxcode set cvxcode=$get(json("entry",zi,"resource","vaccineCode","coding",1,"code"))
 . do log(jlog,"code is: "_cvxcode)
 . set eval("immunizations",zi,"vars","code")=cvxcode
 . ;
 . ;
 . new codesystem set codesystem=$get(json("entry",zi,"resource","vaccineCode","coding",1,"system"))
 . do log(jlog,"code system is: "_codesystem)
 . set eval("immunizations",zi,"vars","codeSystem")=codesystem
 . ;
 . ; determine the effective date
 . ;
 . new effdate set effdate=$get(json("entry",zi,"resource","date"))
 . do log(jlog,"effectiveDateTime is: "_effdate)
 . set eval("immunizations",zi,"vars","effectiveDateTime")=effdate
 . new fmtime s fmtime=$$fhirTfm^SYNFUTL(effdate)
 . d log(jlog,"fileman dateTime is: "_fmtime)
 . set eval("immunizations",zi,"vars","fmDateTime")=fmtime ;
 . new hl7time s hl7time=$$fhirThl7^SYNFUTL(effdate)
 . d log(jlog,"hl7 dateTime is: "_hl7time)
 . set eval("immunizations",zi,"vars","hl7DateTime")=hl7time ;
 . ;
 . ; determine the encounter visit ien
 . n encounterId
 . s encounterId=$g(json("entry",zi,"resource","encounter","reference"))
 . i encounterId["urn:uuid:" s encounterId=$p(encounterId,"urn:uuid:",2)
 . s eval("immunizations",zi,"vars","encounterId")=encounterId
 . d log(jlog,"reference encounter ID is : "_encounterId)
 . ;
 . n visitIen s visitIen=$$visitIen^SYNFENC(ien,encounterId)
 . s eval("immunizations",zi,"vars","visitIen")=visitIen
 . d log(jlog,"visit ien is: "_visitIen)
 . ;
 . ; set up to call the data loader
 . ;
 . ;IMMUNUPD(RETSTA,DHPPAT,VISIT,IMMUNIZ,ANATLOC,ADMINRT,DOSE,EVENTDT,IMMPROV)  ;Immunization update
 . n RETSTA,DHPPAT,VISIT,IMMUNIZ,ANATLOC,ADMINRT,DOSE,EVENTDT,IMMPROV      ;Immunization update
 . s (DHPPAT,VISIT,IMMUNIZ,ANATLOC,ADMINRT,DOSE,EVENTDT,IMMPROV)=""      ;Immunization update
 . ;
 . s DHPPAT=$$dfn2icn^SYNFUTL(dfn)
 . s eval("immunizations",zi,"parms","DHPPAT")=DHPPAT
 . ;
 . s VISIT=visitIen
 . s eval("immunizations",zi,"parms","VISIT")=visitIen
 . ;
 . s IMMUNIZ=cvxcode
 . s eval("immunizations",zi,"parms","IMMUNIZ")=IMMUNIZ
 . ;
 . ;
 . s EVENTDT=hl7time
 . s eval("immunizations",zi,"parms","EVENTDT")=hl7time
 . d log(jlog,"HL7 DateTime is: "_hl7time)
 . ;
 . s IMMPROV=$$MAP^SYNQLDM("OP","provider") ; should map to an NPI
 . ;n DHPPROVIEN s DHPPROVIEN=$o(^VA(200,"B",IMMPROV,""))
 . ;if DHPPROVIEN="" S DHPPROVIEN=3
 . s eval("immunizations",zi,"parms","IMMPROV")=IMMPROV
 . d log(jlog,"Provider NPI for outpatient is: "_IMMPROV)
 . ;
 . s DHPLOC=$$MAP^SYNQLDM("OP","location")
 . n DHPLOCIEN s DHPLOCIEN=$o(^SC("B",DHPLOC,""))
 . if DHPLOCIEN="" S DHPLOCIEN=4
 . s eval("immunizations",zi,"parms","DHPLOC")=DHPLOCIEN
 . d log(jlog,"Location for outpatient is: #"_DHPLOCIEN_" "_DHPLOC)
 . ;
 . s eval("immunizations",zi,"status","loadstatus")="readyToLoad"
 . ;
 . if $g(args("load"))=1 d  ; only load if told to
 . . if $g(ien)'="" if $$loadStatus("immunizations",zi,ien)=1 do  quit  ;
 . . . d log(jlog,"Immunization already loaded, skipping")
 . . d log(jlog,"Calling IMMUNUPD^ZZDHP61 to add immunization")
 . . D IMMUNUPD^SYNDHP61(.RETSTA,DHPPAT,.VISIT,IMMUNIZ,ANATLOC,ADMINRT,DOSE,EVENTDT,IMMPROV) ;Immunization update
 . . m eval("immunizations",zi,"status")=RETSTA
 . . d log(jlog,"Return from data loader was: "_$g(RETSTA))
 . . if +$g(RETSTA)=1 do  ;
 . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
 . . . s eval("immunizations",zi,"status","loadstatus")="loaded"
 . . else  d  ;
 . . . s eval("status","errors")=$g(eval("status","errors"))+1
 . . . s eval("immunizations",zi,"status","loadstatus")="notLoaded"
 . . . s eval("immunizations",zi,"status","loadMessage")=$g(RETSTA)
 . . n root s root=$$setroot^%wd("fhir-intake")
 . . k @root@(ien,"load","immunizations",zi)
 . . m @root@(ien,"load","immunizations",zi)=eval("immunizations",zi)
 ;
 if $get(args("debug"))=1 do  ;
 . m jrslt("source")=json
 . m jrslt("args")=args
 . m jrslt("eval")=eval
 m jrslt("immunizationsStatus")=eval("immunizationsStatus")
 set jrslt("result","status")="ok"
 set jrslt("result","loaded")=$g(eval("status","loaded"))
 i $g(ien)'="" d  ; called internally
 . m result=eval
 . m result("status")=jrslt("result")
 . m result("dfn")=dfn
 . m result("ien")=ien
 . ;b
 e  d  ;
 . d ENCODE^VPRJSON("jrslt","result")
 . set HTTPRSP("mime")="application/json" 
 q
 ;
log(ary,txt) ; adds a text line to @ary@("log")
 s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
 q
 ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
 n root s root=$$setroot^%wd("fhir-intake")
 n rt s rt=0
 i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
 i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
 q rt
 ;
testall ; run the immunizations import on all imported patients
 new root s root=$$setroot^%wd("fhir-intake")
 new indx s indx=$na(@root@("POS","DFN"))
 n dfn,ien,filter,reslt
 s dfn=0
 f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
 . s ien=$o(@indx@(dfn,""))
 . q:ien=""
 . s filter("dfn")=dfn
 . k reslt
 . d wsIntakeImmu(.filter,,.reslt,ien)
 q
 ;
testone(reslt,doload) ; run the immunizations import on all imported patients
 new root s root=$$setroot^%wd("fhir-intake")
 new indx s indx=$na(@root@("POS","DFN"))
 n dfn,ien,filter
 n done s done=0
 s dfn=0
 f  s dfn=$o(@indx@(dfn)) q:+dfn=0  q:done   d  ;
 . s ien=$o(@indx@(dfn,""))
 . q:ien=""
 . q:$d(@root@(ien,"load","immunizations"))
 . s filter("dfn")=dfn
 . s filter("debug")=1
 . i $g(doload)=1 s filter("load")=1
 . k reslt
 . d wsIntakeImmu(.filter,,.reslt,ien)
 . s done=1
 q
 ;

SYNFLAB
SYNFLAB ;ven/gpl - fhir loader utilities ;2018-05-08  4:23 PM
 ;;1.0;fhirloader;;oct 19, 2017;Build 2
 ;
 ; Authored by George P. Lilly 2017-2018
 ;
 q
 ;
importLabs(rtn,ien,args) ; entry point for loading labs for a patient
 ; calls the intake Labs web service directly
 ;
 n grtn
 n root s root=$$setroot^%wd("fhir-intake")
 n % s %=$$wsIntakeLabs(.args,,.grtn,ien)
 i $d(grtn) d  ; something was returned
 . k @root@(ien,"load","labs")
 . m @root@(ien,"load","labs")=grtn("labs")
 . if $g(args("debug"))=1 m rtn=grtn
 s rtn("labsStatus","status")=$g(grtn("status","status"))
 s rtn("labsStatus","loaded")=$g(grtn("status","loaded"))
 s rtn("labsStatus","errors")=$g(grtn("status","errors"))
 ;b
 ;
 ;
 q
 ;
wsIntakeLabs(args,body,result,ien) ; web service entry (post)
 ; for intake of one or more Lab results. input are fhir resources
 ; result is json and summarizes what was done
 ; args include patientId
 ; ien is specified for internal calls, where the json is already in a graph
 n jtmp,json,jrslt,eval
 ;i $g(ien)'="" if $$loadStatus("labs","",ien)=1 d  q  ;
 ;. s result("labsStatus","status")="alreadyLoaded"
 i $g(ien)'="" d  ; internal call
 . d getIntakeFhir^SYNFHIR("json",,"Observation",ien,1)
 e  d  ; 
 . ;s args("load")=0
 . merge jtmp=BODY
 . do DECODE^VPRJSON("jtmp","json")
 i '$d(json) q 0  ;
 m ^gpl("gjson")=json
 ;
 ; determine the patient
 ;
 n dfn,eval
 if $g(ien)'="" d  ;
 . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
 else  d  ;
 . s dfn=$g(args("dfn"))
 . i dfn="" d  ;
 . . n icn s icn=$g(args("icn"))
 . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
 i $g(dfn)="" do  quit 0  ; need the patient
 . s result("labs",1,"log",1)="Error, patient not found.. terminating"
 ;
 ;
 new zi s zi=0
 for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
 . ;
 . ; define a place to log the processing of this entry
 . ;
 . new jlog set jlog=$name(eval("labs",zi))
 . ;
 . ; insure that the resourceType is Observation
 . ;
 . new type set type=$get(json("entry",zi,"resource","resourceType"))
 . if type'="Observation" do  quit  ;
 . . set eval("labs",zi,"vars","resourceType")=type
 . . do log(jlog,"Resource type not Observation, skipping entry")
 . set eval("labs",zi,"vars","resourceType")=type
 . ;
 . ; determine the Observation category and quit if not labs
 . ;
 . new obstype set obstype=$get(json("entry",zi,"resource","category",1,"coding",1,"code"))
 . if obstype="" do  ; category is missing, try mapping the code
 . . new trycode,trydisp,tryy 
 . . set trycode=$g(json("entry",zi,"resource","code","coding",1,"code"))
 . . set trydisp=$g(json("entry",zi,"resource","code","coding",1,"display"))
 . . s tryy=$$loinc2sct(trycode)
 . . if tryy="" d  quit  ;
 . . . d log(jlog,"Observation Category missing, not vital signs; code is: "_trycode_" "_trydisp)
 . . if tryy'="" set obstype="laboratory"
 . . d log(jlog,"Derived category is "_obstype)
 . ;
 . if obstype'="laboratory" do  quit  ;
 . . set eval("labs",zi,"vars","observationCategory")=obstype
 . . do log(jlog,"Observation Category is not laboratory, skipping")
 . set eval("labs",zi,"vars","observationCategory")=obstype
 . ;
 . ; see if this resource has already been loaded. if so, skip it
 . ;
 . if $g(ien)'="" if $$loadStatus("labs",zi,ien)=1 do  quit  ;
 . . d log(jlog,"Lab already loaded, skipping")
 . ;
 . ; determine Labs type, code, coding system, and display text
 . ;
 . new labtype set labtype=$get(json("entry",zi,"resource","code","text"))
 . if labtype="" set labtype=$get(json("entry",zi,"resource","code","coding",1,"display"))
 . do log(jlog,"Labs type is: "_labtype)
 . set eval("labs",zi,"vars","type")=labtype
 . ;
 . ; determine the id of the resource
 . ;
 . new id set id=$get(json("entry",zi,"resource","id"))
 . set eval("labs",zi,"vars","id")=id
 . d log(jlog,"ID is: "_id)
 . ;
 . new obscode set obscode=$get(json("entry",zi,"resource","code","coding",1,"code"))
 . do log(jlog,"code is: "_obscode)
 . set eval("labs",zi,"vars","code")=obscode
 . ;
 . s ^gpl("labs",obscode,labtype)=""
 . ;
 . new codesystem set codesystem=$get(json("entry",zi,"resource","code","coding",1,"system"))
 . do log(jlog,"code system is: "_codesystem)
 . set eval("labs",zi,"vars","codeSystem")=codesystem
 . ;
 . ; determine the value and units
 . ;
 . new value set value=$get(json("entry",zi,"resource","valueQuantity","value"))
 . do log(jlog,"value is: "_value)
 . set eval("labs",zi,"vars","value")=value
 . ;
 . new unit set unit=$get(json("entry",zi,"resource","valueQuantity","unit"))
 . do log(jlog,"units are: "_unit)
 . set eval("labs",zi,"vars","units")=unit
 . ;
 . ; determine the effective date
 . ;
 . new effdate set effdate=$get(json("entry",zi,"resource","effectiveDateTime"))
 . do log(jlog,"effectiveDateTime is: "_effdate)
 . set eval("labs",zi,"vars","effectiveDateTime")=effdate
 . new fmtime s fmtime=$$fhirTfm^SYNFUTL(effdate)
 . d log(jlog,"fileman dateTime is: "_fmtime)
 . set eval("labs",zi,"vars","fmDateTime")=fmtime ;
 . new hl7time s hl7time=$$fhirThl7^SYNFUTL(effdate)
 . d log(jlog,"hl7 dateTime is: "_hl7time)
 . set eval("labs",zi,"vars","hl7DateTime")=hl7time ;
 . ;
 . ; set up to call the data loader
 . ;
 . n RETSTA,DHPPAT,DHPSCT,DHPOBS,DHPUNT,DHPDTM,DHPPROV,DHPLOC,DHPLOINC
 . ;
 . s DHPPAT=$$dfn2icn^SYNFUTL(dfn)
 . s eval("labs",zi,"parms","DHPPAT")=DHPPAT
 . ;
 . ;n vistalab s vistalab=$$MAP^SYNQLDM(obscode)
 . s DHPLOINC=obscode
 . n vistalab s vistalab=$$graphmap^SYNGRAPH("loinc-code-map",obscode)
 . i +vistalab=-1 s vistalab=$$graphmap^SYNGRAPH("loinc-code-map"," "_obscode)
 . if +vistalab=-1 s vistalab=labtype
 . s vistalab=$$trim^%ts(vistalab) ; get rid of trailing blanks
 . ;n sct s sct=$$loinc2sct(obscode) ; find the snomed code
 . ;i vistalab="" d  quit
 . ;. d log(jlog,"VistA lab not found for loinc code: "_obscode_" "_labtype_" -- skipping")
 . ;. s eval("labs",zi,"status","loadstatus")="cannotLoad"
 . ;. s eval("labs",zi,"status","issue")="VistA lab not found for loinc code: "_obscode_" "_labtype_" -- skipping"
 . ;. s eval("status","errors")=$g(eval("status","errors"))+1
 . s eval("labs",zi,"parms","DHPLAB")=vistalab
 . d log(jlog,"VistA Lab is: "_vistalab)
 . s DHPLAB=vistalab
 . ;
 . s DHPOBS=value
 . s eval("labs",zi,"parms","DHPOBS")=value
 . d log(jlog,"Value is: "_value)
 . ;
 . s DHPUNT=unit
 . s eval("labs",zi,"parms","DHPUNT")=unit
 . d log(jlog,"Units are: "_unit)
 . ;
 . s DHPDTM=hl7time
 . s eval("labs",zi,"parms","DHPDTM")=hl7time
 . d log(jlog,"HL7 DateTime is: "_hl7time)
 . ;
 . s DHPPROV=$$MAP^SYNQLDM("OP","provider")
 . n DHPPROVIEN s DHPPROVIEN=$o(^VA(200,"B",DHPPROV,""))
 . if DHPPROVIEN="" S DHPPROVIEN=3
 . s eval("labs",zi,"parms","DHPPROV")=DHPPROVIEN
 . d log(jlog,"Provider for outpatient is: #"_DHPPROVIEN_" "_DHPPROV)
 . ;
 . s DHPLOC=$$MAP^SYNQLDM("OP","location")
 . n DHPLOCIEN s DHPLOCIEN=$o(^SC("B",DHPLOC,""))
 . if DHPLOCIEN="" S DHPLOCIEN=4
 . s eval("labs",zi,"parms","DHPLOC")=DHPLOCIEN
 . d log(jlog,"Location for outpatient is: #"_DHPLOCIEN_" "_DHPLOC)
 . ;
 . s eval("labs",zi,"status","loadstatus")="readyToLoad"
 . ;
 . if $g(args("load"))=1 d  ; only load if told to
 . . if $g(ien)'="" if $$loadStatus("labs",zi,ien)=1 do  quit  ;
 . . . d log(jlog,"Lab already loaded, skipping")
 . . d log(jlog,"Calling LABADD^SYNDHP63 to add lab")
 . . ;LABADD(RETSTA,DHPPAT,DHPLOC,DHPTEST,DHPRSLT,DHPRSDT) ;Create lab test
 . . D LABADD^SYNDHP63(.RETSTA,DHPPAT,DHPLOC,DHPLAB,DHPOBS,DHPDTM,DHPLOINC)     ; labs update
 . . d log(jlog,"Return from LABADD^ZZDHP63 was: "_$g(RETSTA))
 . . i $g(DEBUG)=1 ZWR RETSTA
 . . if +$g(RETSTA)=1 do  ;
 . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
 . . . s eval("labs",zi,"status","loadstatus")="loaded"
 . . else  s eval("status","errors")=$g(eval("status","errors"))+1
 ;
 if $get(args("debug"))=1 do  ;
 . m jrslt("source")=json
 . m jrslt("args")=args
 . m jrslt("eval")=eval
 m jrslt("labsStatus")=eval("labsStatus")
 set jrslt("result","status")="ok"
 set jrslt("result","loaded")=$g(eval("status","loaded"))
 i $g(ien)'="" d  ; called internally
 . m result=eval
 . m result("status")=jrslt("result")
 . ;b
 e  d  ;
 . d ENCODE^VPRJSON("jrslt","result")
 . set HTTPRSP("mime")="application/json" 
 q 1
 ;
log(ary,txt) ; adds a text line to @ary@("log")
 s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
 w:$G(DEBUG) !,"      ",$G(txt)
 q
 ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
 n root s root=$$setroot^%wd("fhir-intake")
 n rt s rt=0
 i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
 i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
 q rt
loinc2sct(loinc) ; extrinsic returns a Snomed code for a Loinc code
 ; for labs
 ; thanks to Ferdi for the Snomed mapping
 ;
 ; here's what we got so far:
 ;^gpl("labs","29463-7","Body Weight")=""
 ;^gpl("labs","39156-5","Body Mass Index")="" ; oops
 ;^gpl("labs","55284-4","Blood Pressure")=""
 ;^gpl("labs","8302-2","Body Height")=""
 ;^gpl("labs","8331-1","Oral temperature")="" ;
 ;
 S SCTA("29463-7",27113001)="9^Body weight"
 S SCTA("8302-2",50373000)="8^Body height"
 S SCTA("55284-4",75367002)="1^Blood pressure"
 S SCTA(78564009)="5^Pulse rate"
 S SCTA("8331-1",386725007)="2^Body Temperature"
 S SCTA(86290005)="3^Respiration"
 S SCTA(48094003)="10^Abdominal girth measurement"
 S SCTA(21727005)="11^Audiometry"
 S SCTA(252465000)="21^Pulse oximetry"
 S SCTA(22253000)="22^Pain"
 ;
 q $o(SCTA(loinc,""))
 ;
testall ; run the labs import on all imported patients
 new root s root=$$setroot^%wd("fhir-intake")
 new indx s indx=$na(@root@("POS","DFN"))
 n dfn,ien,filter,reslt
 s dfn=0
 f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
 . s ien=$o(@indx@(dfn,""))
 . q:ien=""
 . s filter("dfn")=dfn
 . k reslt
 . d wsIntakeLabs(.filter,,.reslt,ien)
 q
 ;
labsum ; summary of lab tests for patient ien pien
 n root s root=$$setroot^%wd("fhir-intake")
 n table
 n zzi s zzi=0
 f  s zzi=$o(@root@(zzi)) q:+zzi=0  d  ;
 . n labs
 . d getIntakeFhir^SYNFHIR("labs",,"Observation",zzi,1)
 . n zi s zi=0
 . f  s zi=$o(labs("entry",zi)) q:+zi=0  d  ;
 . . n groot s groot=$na(labs("entry",zi,"resource"))
 . . i $g(@groot@("category",1,"coding",1,"code"))'="laboratory" q  ;
 . . n loinc
 . . s loinc=$g(@groot@("code","coding",1,"code"))
 . . q:loinc=""
 . . ;i loinc="6082-2" b  ;
 . . n text s text=$g(@groot@("code","coding",1,"display"))
 . . i $d(table(loinc_" "_text)) d  ;
 . . . s table(loinc_" "_text)=table(loinc_" "_text)+1
 . . e  d  ;
 . . . s table(loinc_" "_text)=1
 . . . w !,"patient= "_zzi_" entry= "_zi,!
 . . . n rptary m rptary=@root@(zzi,"json","entry",zi,"resource")
 . . . zwr rptary
 zwr table
 q
 ;

SYNFMED
SYNFMED ;OSE/SMH - Add Medications to Patient Record;May 23, 2018
 ;;1.0;SYNTHETIC PATIENTS LOADER;
 ; (C) 2018 Sam Habiel
 ; See accompanying license for terms of use.
 ;
 ; TODO list
 ; - Implement Web Services lookup
 ; - Auto create site parameters for outpatient pharmacy
 ; - Set-up Patient Characteristics in 55
 ; - release Rx to signify the patient has it in its pocket
 ;
RXN2MEDS(RXN) ; [Public] Get Drugs that are associated with an RxNorm
 Q $$MATCHVM($$RXN2VUI(RXN))
 ;
RXN2VUI(RXN) ; [Public] Get ^ delimited VUIDs for an RxNorm
 N VUIDS S VUIDS=""
 n file
 I $T(^ETSRXN)]"" d  quit VUIDS
 . n fileVUIDs s fileVUIDs=$$ETSRXN2VUID(RXN)
 . n i f i=1:1:$l(fileVUIDs,U) do
 .. n fileVUID s fileVUID=$p(fileVUIDs,U,i)
 .. s file=$p(fileVUID,"~")
 .. i file'=50.68 quit
 .. n vuid s vuid=$p(fileVUID,"~",2)
 .. s VUIDS=VUIDS_vuid_U
 . i $e(VUIDS,$l(VUIDS))=U S $E(VUIDS,$L(VUIDS))=""
 ;
 ; TODO: Rest is not implemented yet.
 N URL S URL="https://rxnav.nlm.nih.gov/REST/rxcui/{RXN}/property.json?propName=VUID"
 N % S %("{RXN}")=RXN
 S URL=$$REPLACE^XLFSTR(URL,.%)
 N C0CRETURN
 D GET(.C0CRETURN,URL)
 N C0COUT
 D DECODE^XLFJSON($NA(C0CRETURN),$NA(C0COUT))
 N J F J=0:0 S J=$O(C0COUT("propConceptGroup","propConcept",J)) Q:'J  D
 . S VUIDS=VUIDS_C0COUT("propConceptGroup","propConcept",J,"propValue")_U
 S $E(VUIDS,$L(VUIDS))="" ; rm trailing ^
 QUIT VUIDS
 ;
RXN2NDC(RXN) ; [Public] Get ^ delimited NDCs for an RxNorm SCD
 I $T(^ETSRXN)]"" Q $$ETSRXN2NDC(RXN)
 ; TODO: Implement web service
 QUIT
 ;
ETSRXN2VUID(RXN) ; [Private] Return delimited list of file~VUID^file~VUID based on ETS
 ; Input: RxNorm Number for IN or CD TTY
 ; Output: file~VUID~name^file~VUID~name..., where file is 50.6 or 50.68.
 ;         or -1^vuid-not-found
 ; 
 ; Translate RXN to VUID
 new numVUID set numVUID=+$$RXN2OUT^ETSRXN(RXN)
 if 'numVUID quit:$quit "-1^vuid-not-found" quit
 ;
 ; loop through VUIDs, and grab a good one (CD or IN)
 ; ^TMP("ETSOUT",69531,831533,"VUID",1,0)="296833^831533^VANDF^AB^4031994^N"
 ; ^TMP("ETSOUT",69531,831533,"VUID",1,1)="ERRIN 0.35MG TAB,28"
 new done s done=0
 new out set out=""
 new vuid,name
 new type,file
 new i for i=0:0 set i=$o(^TMP("ETSOUT",$J,RXN,"VUID",i)) quit:'i  do  quit:done
 . new node0 set node0=^TMP("ETSOUT",$J,RXN,"VUID",i,0)
 . new node1 set node1=^TMP("ETSOUT",$J,RXN,"VUID",i,1)
 . set type=$p(node0,U,4)
 . if "^CD^IN^"'[(U_type_U) quit
 . ;
 . set vuid=$p(node0,U,5)
 . set file=$s(type="CD":50.68,type="IN":50.6,1:1/0) ; any other type is invalid!
 . set name=node1
 . set out=out_file_"~"_vuid_"~"_name_U
 if $extract(out,$length(out))=U set $extract(out,$length(out))=""
 K ^TMP("ETSOUT",$J)
 quit out
 ;
ETSRXN2NDC(RXN) ; [Private] Return delimited list of NDCs from RxNorm (only active ones)
 ; Translate RXN to VUID
 new numNDC set numNDC=$P($$RXN2OUT^ETSRXN(RXN),U,2)
 if 'numNDC quit:$quit "-1^rxncui-not-found" quit
 ;
 ; loop through NDCs, and grab good ones 
 ; ^TMP("ETSOUT",2199,831533,"NDC")=6
 ; ^TMP("ETSOUT",2199,831533,"NDC",1,0)="600680^831533^831533^RXNORM^N"
 ; ^TMP("ETSOUT",2199,831533,"NDC",1,1)="NDC"
 ; ^TMP("ETSOUT",2199,831533,"NDC",1,2)="00555034458"
 ; ^TMP("ETSOUT",2199,831533,"NDC",2,0)="600681^831533^831533^RXNORM^N"
 ; ^TMP("ETSOUT",2199,831533,"NDC",2,1)="NDC"
 ; ^TMP("ETSOUT",2199,831533,"NDC",2,2)="00555034479"
 new out set out=""
 new type,supp
 new i for i=0:0 set i=$o(^TMP("ETSOUT",$J,RXN,"NDC",i)) quit:'i  do
 . new node0 set node0=^TMP("ETSOUT",$J,RXN,"NDC",i,0)
 . new ndc set ndc=^TMP("ETSOUT",$J,RXN,"NDC",i,2)
 . set type=$p(node0,U,4)
 . set supp=$p(node0,U,5)
 . ;
 . ; We want RxNorm NDCs that are not suppressed.
 . i type'="RXNORM" quit
 . i supp'="N" quit
 . ;
 . set out=out_ndc_U
 if $extract(out,$length(out))=U set $extract(out,$length(out))=""
 K ^TMP("ETSOUT",$J)
 quit out
 ;
MATCHVM(VUIDS) ; [Public] Match delimited list of VUIDs to delimited set of drugs (not one to one)
 N MATCHES S MATCHES=""
 N I,VUID
 F I=1:1 S VUID=$P(VUIDS,U,I) Q:VUID=""  D
 . N MATCH S MATCH=$$MATCHV1(VUID)
 . I MATCH S MATCHES=MATCHES_MATCH_U
 S $E(MATCHES,$L(MATCHES))="" ; rm trailing ^
 QUIT MATCHES
 ;
 ;
MATCHV1(VUID) ; [Public] Match a single VUID to a set of drugs.
 N VAP S VAP=$$VUI2VAP(VUID) ; says it's supposed to be plural, but that's not possible??
 I 'VAP S $EC=",U-VUID-SHOULD-NOT-BE-MISSING,"
 N MEDS S MEDS=$$VAP2MED(VAP)
 QUIT MEDS
 ;
VUI2VAP(VUID) ; $$ Public - Get VA Product IEN(s) from VUID
 ; Input VUID by Value
 ; Output: Extrinsic
 D FIND^DIC(50.68,,"@","QP",VUID,,"AVUID") ; Find all in VUID index
 N O S O="" ; Output
 N I F I=0:0 S I=$O(^TMP("DILIST",$J,I)) Q:'I  S O=O_^(I,0)_U ; Concat results together
 S O=$E(O,1,$L(O)-1) ; remove trailing ^
 Q O
 ;
VAP2MED(VAPROD) ; $$ Public - Get Drug(s) using VA Product IEN
 ; Un-Unit-testable: Drug files differ between sites.
 ; Input: VA Product IEN By Value
 ; OUtput: Caret delimited extrinsic
 ; This code inspired from PSNAPIs
 ; WHY THE HELL WOULD I USE A TEXT INDEX?
 ; It's my only option. Creating new xrefs on the drug file doesn't help
 ; as they are not filled out when adding a drug (IX[ALL]^DIK isn't called).
 N MEDS S MEDS="" ; result
 N PN,PN1 ; Product Name, abbreviated product name.
 S PN=$P(^PSNDF(50.68,VAPROD,0),"^"),PN1=$E(PN,1,30)
 N P50 S P50=0 ; looper through VAPN index which is DRUG file entry
 F  S P50=$O(^PSDRUG("VAPN",PN1,P50)) Q:'P50  D  ; for each text match
 . I $P(^PSDRUG(P50,"ND"),"^",3)=VAPROD S MEDS=$G(MEDS)_P50_U  ; check that the VA PRODUCT pointer is the same as ours.
 S:MEDS MEDS=$E(MEDS,1,$L(MEDS)-1) ; remove trailing ^
 Q MEDS
 ;
ADDDRUG(RXN,BARCODE) ; [Public] Add Drug to Drug File
 ; Input: RXN - RxNorm Semantic Clinical Drug CUI by Value. Required.
 ; Input: BARCODE - Wand Barcode. Optional. Pass exactly as wand reads minus control characters.
 ; Output: Internal Entry Number
 ;
 ; Get first VUID for this RxNorm drug
 N VUID S VUID=+$$RXN2VUI(RXN)
 Q:'VUID ""
 G NEXT
ADDDRUG2(RXN,VUID) ;
 ; ZEXCEPT: NDC,BARCODE
NEXT ;
 N PSSZ S PSSZ=1    ; Needed for the drug file to let me in!
 ; 
 ; W "(debug) VUID for RxNorm CUI "_RXN_" is "_VUID,!
 ;
 ; IEN in 50.68
 N C0XVUID ; For Searching Compound Index
 S C0XVUID(1)=VUID
 S C0XVUID(2)=1
 N F5068IEN S F5068IEN=$$FIND1^DIC(50.68,"","XQ",.C0XVUID,"AMASTERVUID")
 Q:'F5068IEN ""
 ; 
 ; W "F 50.68 IEN (debug): "_F5068IEN,!
 ;
 ; Guard against adding the drug back in again.
 N EXISTING S EXISTING=$$VAP2MED(F5068IEN)
 I EXISTING Q EXISTING
 ;
 ; FDA Array
 N C0XFDA
 ;
 ; Name, shortened
 S C0XFDA(50,"+1,",.01)=$E($$GET1^DIQ(50.68,F5068IEN,.01),1,40)
 ;
 ; File BarCode as a Synonym for BCMA
 I $L($G(BARCODE)) D
 . S C0XFDA(50.1,"+2,+1,",.01)=BARCODE
 . S C0XFDA(50.1,"+2,+1,",1)="Q"
 ;
 N NDCS S NDCS=$$RXN2NDC^SYNFMED(RXN)
 N NDC S NDC=$P(NDCS,U,1)
 ;
 ; NDC field
 I $G(NDC) S C0XFDA(50,"+1,",31)=$E(NDC,1,5)_"-"_$E(NDC,6,9)_"-"_$E(NDC,10,11)
 ;
 ; NDCs to synonyms
 N C0XI F C0XI=1:1:$L(NDCS,U) D
 . S NDC=$P(NDCS,U,C0XI)
 . S C0XFDA(50.1,"+"_(C0XI+10)_",+1,",.01)=NDC
 . S C0XFDA(50.1,"+"_(C0XI+10)_",+1,",1)="Q"
 . S C0XFDA(50.1,"+"_(C0XI+10)_",+1,",2)=NDC
 ;
 ; Brand Names & NDCs
 ; N NDCS
 ; N URL S URL="https://rxnav.nlm.nih.gov/REST/rxcui/{RXN}/ndcs.json"
 ; N % S %("{RXN}")=RXN
 ; S URL=$$REPLACE^XLFSTR(URL,.%)
 ; N C0CRETURN
 ; D GET(.C0CRETURN,URL)
 ; N C0COUT
 ; D DECODE^XLFJSON($NA(C0CRETURN),$NA(C0COUT))
 ; ZWRITE C0COUT
 ; QUIT
 ; ;
 ; N BNS S BNS="" ; S BNS=$$RXN2BNS^C0CRXNLK(RXN) ; Brands
 ; I $L(BNS) N I F I=1:1:$L(BNS,U) D
 ; . N IENS S IENS=I+2
 ; . S C0XFDA(50.1,"+"_IENS_",+1,",.01)=$$UP^XLFSTR($E($P(BNS,U,I),1,40))
 ; . S C0XFDA(50.1,"+"_IENS_",+1,",1)="T"
 ;
 ;
 ; Dispense Unit (string)
 S C0XFDA(50,"+1,",14.5)=$$GET1^DIQ(50.68,F5068IEN,"VA DISPENSE UNIT")
 ;
 ; National Drug File Entry (pointer to 50.6)
 S C0XFDA(50,"+1,",20)="`"_$$GET1^DIQ(50.68,F5068IEN,"VA GENERIC NAME","I")
 ;
 ; VA Product Name (string)
 S C0XFDA(50,"+1,",21)=$E($$GET1^DIQ(50.68,F5068IEN,.01),1,70)
 ;
 ; PSNDF VA PRODUCT NAME ENTRY (pointer to 50.68)
 S C0XFDA(50,"+1,",22)="`"_F5068IEN
 ;
 ; DEA, SPECIAL HDLG (string)
 D  ; From ^PSNMRG ; ZEXCEPT: n
 . N CS S CS=$$GET1^DIQ(50.68,F5068IEN,"CS FEDERAL SCHEDULE","I")
 . S CS=$S(CS?1(1"2n",1"3n"):+CS_"C",+CS=2!(+CS=3)&(CS'["C"):+CS_"A",1:CS)
 . S C0XFDA(50,"+1,",3)=CS
 ;
 ; NATIONAL DRUG CLASS (pointer to 50.605) (triggers VA Classification field)
 S C0XFDA(50,"+1,",25)="`"_$$GET1^DIQ(50.68,F5068IEN,"PRIMARY VA DRUG CLASS","I")
 ;
 ; Right Now, I don't file the following which ^PSNMRG does (cuz I don't need them)
 ; - Package Size (derived from NDC/UPN file)
 ; - Package Type (ditto)
 ; - CMOP ID (from $$PROD2^PSNAPIS)
 ; - National Formulary Indicator (from 50.68)
 ;
 ; Next Step is to kill Old OI if Dosage Form doesn't match
 ; Won't do that here as it's assumed any drugs that's added is new.
 ; This happens at ^PSNPSS
 ;
 ; Now add drug to drug file, as we need the IEN for the dosages call.
 N C0XERR,C0XIEN
 D UPDATE^DIE("E","C0XFDA","C0XIEN","C0XERR")
 S:$D(C0XERR) $EC=",U1,"
 ;
 ; Next Step: Kill off old doses and add new ones.
 D EN2^PSSUTIL(C0XIEN(1))
 ;
 ; Mark uses for the Drug; use the undocumented Silent call in PSSGIU
 N PSIUDA,PSIUX ; Expected Input variables
 S PSIUDA=C0XIEN(1),PSIUX="O^Outpatient Pharmacy" D ENS^PSSGIU
 S PSIUDA=C0XIEN(1),PSIUX="U^Unit Dose" D ENS^PSSGIU
 S PSIUDA=C0XIEN(1),PSIUX="X^Non-VA Med" D ENS^PSSGIU
 ;
 ; Get VA Generic text and VA Product pointer for Orderable Item creation plus dosage form information
 N VAGENP S VAGENP=$P(^PSDRUG(C0XIEN(1),"ND"),U) ; VA Generic Pointer
 N VAGEN S VAGEN=$$VAGN^PSNAPIS(VAGENP) ; VA Generic Full name
 N VAPRODP S VAPRODP=$P(^PSDRUG(C0XIEN(1),"ND"),U,3) ; VA Product Pointer
 N DOSAGE S DOSAGE=$$PSJDF^PSNAPIS(0,VAPRODP) ; IEN of dose form in 50.606 ^ Text
 N DOSEPTR S DOSEPTR=$P(DOSAGE,U) ; ditto
 N DOSEFORM S DOSEFORM=$P(DOSAGE,U,2) ;ditto
 ;
 ; Get the (possibly new) Orderable Item Text
 N VAG40 S VAG40=$E(VAGEN,1,40) ; Max length of .01 field
 ;
 ; See if there is an existing orderable item already. If so, populate the Pharmacy Orderable item on drug file.
 N OI S OI=$O(^PS(50.7,"ADF",VAG40,DOSEPTR,""))
 ;
 ; Otherwise, add a new one. (See MCHAN+12^PSSPOIMN)
 N FLAGNEWOI S FLAGNEWOI=0
 I 'OI D
 . N C0XFDA,C0XERR
 . S C0XFDA(50.7,"+1,",.01)=VAG40
 . S C0XFDA(50.7,"+1,",.02)=DOSEPTR
 . D UPDATE^DIE("",$NA(C0XFDA),$NA(OI),$NA(C0XERR))
 . I $D(C0XERR) S $EC=",U1,"
 . S OI=OI(1) ; For ease of use...
 . S FLAGNEWOI=1
 ;
 ; Add the orderable Item to the drug file.
 N C0XFDA,C0XERR S C0XFDA(50,C0XIEN(1)_",",2.1)=OI ; Orderable Item
 D FILE^DIE("",$NA(C0XFDA),$NA(C0XERR))
 ;
 ; Mailman throws an error into DIERR, which ANNOYS me! So we won't check for errors here.
 ; S:$D(C0XERR) $EC=",U1,"
 ; Special $ZSTEP to find the problem: zp @$zpos b:($g(olddierr)'=$g(DIERR))  s olddierr=$g(DIERR) zstep into
 ;
 ; Previously, we did the CPRS HL7 message here; but we don't need to anymore. The OI xref does it for us.
 ;
EX QUIT C0XIEN(1)
 ;
GET(RETURN,URL) ; [Public] Get a URL
 ;
 ; Timeout
 N TO S TO=5
 N HEADERS
 ; Action
 I $T(^%WC)]"" D %^%WC(.RETURN,"GET",URL,,,TO,.HEADERS) I 1
 E  N STATUS S STATUS=$$GETURL^XTHC10(URL,TO,$NA(RETURN)),HEADERS("STATUS")=STATUS
 ;
 ; ZWRITE HEADERS
 ; ZWRITE RETURN
 ;
 ; Check status code to be 200.
 I "^200^302^"'[HEADERS("STATUS") S %XOBWERR=HEADERS("STATUS"),$EC=",UXOBWHTTP,"
 QUIT
 ;
WRITERXRXN(PSODFN,RXNCDCUI,RXDATE) ; [$$/D Public] Create a new prescription for a patient using RxNorm SCD CUI
 ; Input: PSODFN = DFN
 ; Input: RXNCDCUI = RxNorm SCD CUI. ONLY SCDs!!! No other RxNorm type is resolvable.
 ; Input: RXDATE = Prescription Date
 ;
 ; $$ Output: Prescription Number (not IEN) or -1^error message
 ;
 N DRUG S DRUG=$$ADDDRUG(RXNCDCUI)
 I 'DRUG Q -1_U_"RxNorm CUI "_RXNCDCUI_" could not be resolved into a drug."
 I $QUIT QUIT $$WRITERXPS(PSODFN,DRUG,RXDATE)
 D WRITERXPS(PSODFN,DRUG,RXDATE)
 QUIT
 ; 
WRITERXPS(PSODFN,DRUG,RXDATE) ; [$$/D Public] Create a new prescription for a patient using drug IEN
 ; Input: PSODFN = DFN
 ; Input: DRUG = Drug (file 50) IEN
 ; Input: RXDATE = Prescription Date
 ; $$ Output: Prescription Number (not IEN) or -1^error message
 ;
 ; Little by little we will work this out!
 ; Assumptions right now:
 ; XXX: Site in 59 is created
 ;
 ; Drug Array we will pass by reference
 N PSONEW
 ; 
 ; Call to get drug demographics
 N PSOY
 S PSOY=DRUG
 S PSOY(0)=^PSDRUG(DRUG,0)
 N PSODRUG
 D SET^PSODRG
 M PSONEW=PSODRUG
 ;
 ; Days and refills
 S PSONEW("ISSUE DATE")=RXDATE
 S PSONEW("FILL DATE")=RXDATE
 S PSONEW("DAYS SUPPLY")=30
 S PSONEW("# OF REFILLS")=1
 ;
 ; Pharmacist here!
 S PSONEW("VERIFY")=1
 S PSONEW("PHARMACIST")=$$PHARM^SYNINIT()
 S PSONEW("CLERK CODE")=PSONEW("PHARMACIST") ; Needed for CPRS for "Entered By" field.
 ;
 ; Provider
 S PSONEW("PROVIDER")=$$PROV^SYNINIT()
 ;
 ; Clinic
 S PSONEW("CLINIC")=$$HL^SYNINIT()
 ;
 ; Get Prescription Number
 N PSOSITE S PSOSITE=$O(^PS(59,0))
 I PSOSITE="" S $EC=",U-SITE-NOT-SET-UP," ; XXX I am not sure if that's a good idea! Maybe create the outpatient site?
 D AUTO^PSONRXN
 ;
 N SYNRXN S SYNRXN=PSONEW("RX #")
 ;
 ; Dosage
 S PSONEW("ENT")=1
 S PSONEW("DOSE",PSONEW("ENT"))="ONE TABLET DAILY"
 ;
 ; Copay
 N PSOSCP S PSOSCP=""
 ;
 ; Quantity
 S PSONEW("QTY")=30 ; Non-sense number
 ;
 ; Counseling
 N PSOCOU,PSOCOUU
 S PSOCOU=1,PSOCOUU=1
 ;
 ;
 ; Nature of order
 N PSONOOR S PSONOOR="W"
 ;
 ; File in 52
 D EN^PSON52(.PSONEW)
 ;
 ; HL7 to OE/RR to update the Order File
 D EOJ^PSONEW
 QUIT:$QUIT SYNRXN QUIT
 ;
TEST D EN^%ut($T(+0),3) QUIT
 ;
STARTUP ; M-Unit Startup
 ; ZEXCEPT: DFN,DRGRXN
 N DA,DIK
 S DRGRXN=313195
 S DFN=1
 N DRG S DRG=$$ADDDRUG(DRGRXN) ; This finds it and also creates it; but normally it will be there from previous test runs
 D KILLONEDRUG(DRG)
 ;
 ; Delete patient rx data
 N PSOI F PSOI=0:0 S PSOI=$O(^PS(55,DFN,"P",PSOI)) Q:'PSOI  D
 . N RXIEN S RXIEN=^PS(55,DFN,"P",PSOI,0)
 . I $D(^PSRX(RXIEN,"OR1")) N ORNUM S ORNUM=$P(^("OR1"),U,2) S DA=ORNUM,DIK="^OR(100," D ^DIK
 . S DIK="^PSRX(",DA=RXIEN D ^DIK
 S DA=DFN,DIK="^PS(55," D ^DIK
 ;
 QUIT
 ;
SHUTDOWN ; M-Unit Shutdown
 ; ZEXCEPT: DFN,DRGRXN
 K DFN
 K DRGRXN
 QUIT
 ;
T0 ; @TEST Test $$ETSRXN2VUID^SYNFMED API
 D CHKTF^%ut($$ETSRXN2VUID^SYNFMED(831533)["50.68~4031994~ERRIN 0.35MG TAB,28")
 D CHKTF^%ut($$ETSRXN2VUID^SYNFMED(70618)["50.6~4019880~PENICILLIN")
 D CHKTF^%ut($$ETSRXN2VUID^SYNFMED(198211)["50.68~4016607~SIMVASTATIN 40MG TAB,UD")
 D CHKTF^%ut($$ETSRXN2VUID^SYNFMED(313195)["50.68~4004891~TAMOXIFEN CITRATE 20MG TAB")
 D CHKTF^%ut($$ETSRXN2VUID^SYNFMED(1009219)["50.6~4030995~ALISKIREN/AMLODIPINE")
 D CHKTF^%ut($$ETSRXN2VUID^SYNFMED(309110)["50.68~4007024~CEPHALEXIN 125MG/5ML SUSP")
 D CHKTF^%ut($$ETSRXN2VUID^SYNFMED(2231)["50.6~4018891~CEPHALEXIN")
 D CHKTF^%ut($$ETSRXN2VUID^SYNFMED(10582)["50.6~4022126~LEVOTHYROXINE")
 QUIT
 ;
T1 ; @TEST Test get VUIDs
 D CHKTF^%ut($$RXN2VUI^SYNFMED(1014675)[4033356)
 D CHKTF^%ut($$RXN2VUI^SYNFMED(197379)[4014051)
 QUIT
 ;
T2 ; @TEST Get Local Matches for VUID (no actual tests as drug file is local)
 W " "
 W $$MATCHV1(4004876)," "
 W $$MATCHV1(4033365)," "
 W $$MATCHV1(4014051)," "
 D SUCCEED^%ut
 QUIT
 ;
T3 ; @TEST Get Local Matches for RxNorm (no actual tests as drug file is local)
 W $$RXN2MEDS(1014675)," " ; Ceterizine capsule
 W $$RXN2MEDS(197379)," "  ; Atenolol 100
 W $$RXN2MEDS(1085640)," " ;  Triamcinolone Acetonide 0.005 MG/MG Topical Ointment
 D SUCCEED^%ut
 QUIT
 ;
T4 ; @TEST Write Rx Using Drug IEN
 ; ZEXCEPT: DFN,DRGRXN
 N DA,DIK
 N DRUG S DRUG=$$ADDDRUG(DRGRXN)
 N RXN S RXN=$$WRITERXPS(DFN,DRUG,DT)
 N RXIEN S RXIEN=$$FIND1^DIC(52,,"QX",RXN,"B")
 N RX0 S RX0=^PSRX(RXIEN,0)
 N PAT S PAT=$P(RX0,U,2)
 N DRG S DRG=$P(RX0,U,6)
 D CHKEQ^%ut(PAT,1)
 D CHKEQ^%ut(DRG,DRUG)
 QUIT
 ;
T5 ; @TEST Write Rx Using Drug RxNorm SCD
 ; ZEXCEPT: DFN,DRGRXN
 N RXN S RXN=$$WRITERXRXN(DFN,DRGRXN,DT) ; Tamoxifen Citrate 20mg tab
 N RXIEN S RXIEN=$$FIND1^DIC(52,,"QX",RXN,"B")
 N RX0 S RX0=^PSRX(RXIEN,0)
 N PAT S PAT=$P(RX0,U,2)
 N DRG S DRG=$P(RX0,U,6)
 N DRGNM S DRGNM=$P(^PSDRUG(DRG,0),U)
 D CHKEQ^%ut(PAT,1)
 D CHKTF^%ut(DRGNM["TAMOXIFEN")
 QUIT
 ;
T55 ; @TEST Write an Rx with a bad Rxnorm number
 N RXN S RXN=$$WRITERXRXN(DFN,989892842342,DT) ; Tamoxifen Citrate 20mg tab
 D CHKTF^%ut(RXN<0)
 QUIT
 ;
VUI2VAPT ; @TEST Get VA Product IEN from VUID
 N L F L=1:1 N LN S LN=$T(VUI2VAPD+L) Q:LN["<<END>>"  Q:LN=""  D
 . N VUID S VUID=$P(LN,";",3)
 . N VAP S VAP=$P(LN,";",4)
 . D CHKEQ^%ut($$VUI2VAP(VUID),VAP,"Translation from VUID to VA PRODUCT failed")
 QUIT
 ;
VUI2VAPD ; @DATA - Data for above test
 ;;4006455;5932
 ;;4002369;1784
 ;;4000874;252
 ;;4003335;2756
 ;;4002469;1884
 ;;4009488;9046^10090
 ;;<<END>>
 ;
T6 ; @TEST Get NDCs for a drug
 D CHKTF^%ut($$RXN2NDC^SYNFMED(198211)["16252050890")
 QUIT
 ;
KILLDRUG ; [Public] Remove all Drug Data
 ; WARNING: DO NOT CALL THIS UNLESS YOU ARE ON A BRAND NEW SYSTEM AND ARE TESTING.
 D DT^DICRW ; Min FM Vars
 D MES^XPDUTL("Killing Drug (50)") D DRUG
 D MES^XPDUTL("Killing Pharmacy Orderable Item (OI) (50.7)") D PO
 D MES^XPDUTL("Killing Drug Text (51.7)") D DRUGTEXT
 D MES^XPDUTL("Killing IV Additives (52.6)") D IVADD
 D MES^XPDUTL("Killing IV Solutions (52.7)") D IVSOL
 D MES^XPDUTL("Killing Drug Electrolytes (50.4)") D DRUGELEC
 D MES^XPDUTL("Removing Pharmacy OIs from the Orderable Item (101.43)") D O
 D MES^XPDUTL("Syncing the Order Quick View (101.44)") D CPRS
 QUIT
 ;
KILLONEDRUG(DRG) ; [Public] Kill just one drug
 ; Called by the Unit Test
 ; 
 ; Get OI
 N DIK,DA
 N OI S OI=+^PSDRUG(DRG,2)
 ;
 ; Delete drug
 S DA=DRG,DIK="^PSDRUG(" D ^DIK
 I 'OI QUIT
 ;
 ; Delete OI
 S DA=OI,DIK="^PS(50.7," D ^DIK
 ;
 ; Delete CPRS synced version of OI
 N OERROI S OERROI=$O(^ORD(101.43,"ID",OI_";99PSP",""))
 I OERROI S DIK="^ORD(101.43,",DA=OERROI D ^DIK
 ;
 ; Update CPRS view of pharmacy OIs
 D CPRS
 QUIT 
 ;
RESTOCK ; [Public] Restock CPRS Orderable Items from new Drug & Pharmacy Orderable Item 
 ; File. Public Entry Point. 
 ; Call this after repopulating the drug file (50) and the pharmacy orderable 
 ; item file (50.7)
 N PSOIEN ; Looper variable
 D DT^DICRW ; Establish FM Basic Variables
 ; 
 ; Loop through Orderable Item file and call 
 ; 1. The Active/Inactive Updater for the Orderable Item
 ; 2. the protocol file updater to CPRS Files
 S PSOIEN=0 F  S PSOIEN=$O(^PS(50.7,PSOIEN)) Q:'PSOIEN  D 
 . D MES^XPDUTL("Syncing Pharamcy Orderable Item "_PSOIEN)
 . D EN^PSSPOIDT(PSOIEN),EN2^PSSHL1(PSOIEN,"MUP")
 D CPRS ; Update Orderable Item View files 
 QUIT
 ;
 ; -- END Public Entry Points --
 ; 
 ; -- The rest is private --
DRUG ; Kill Drug File; Private
 N DA,DIK
 S DIK="^PSDRUG("
 F DA=0:0 S DA=$O(^PSDRUG(DA)) Q:'DA  D ^DIK
 S $P(^PSDRUG(0),U,3,4)=""
 K ^DIA(50)
 QUIT
 ;
PO ; Kill Pharmacy Orderable Items; Private
 N %1 S %1=^PS(50.7,0)
 K ^PS(50.7)
 S ^PS(50.7,0)=%1
 S $P(^PS(50.7,0),"^",3,4)=""
 QUIT
 ;
DRUGTEXT ; Kill Drug Text Entries ; Private
 N %1 S %1=^PS(51.7,0)
 K ^PS(51.7)
 S ^PS(51.7,0)=%1
 S $P(^PS(51.7,0),"^",3,4)=""
 QUIT
 ;
IVADD ; Kill IV Additives ; Private
 N %1 S %1=^PS(52.6,0)
 K ^PS(52.6)
 S ^PS(52.6,0)=%1
 S $P(^PS(52.6,0),"^",3,4)=""
 QUIT
 ;
IVSOL ; Kill IV Solutions ; Private
 N %1 S %1=^PS(52.7,0)
 K ^PS(52.7)
 S ^PS(52.7,0)=%1
 S $P(^PS(52.7,0),"^",3,4)=""
 QUIT
 ;
DRUGELEC ; Kill Drug Electrolytes ; Private
 N %1 S %1=^PS(50.4,0)
 K ^PS(50.4)
 S ^PS(50.4,0)=%1
 S $P(^PS(50.4,0),"^",3,4)=""
 QUIT
 ;
O ; Kill off Pharamcy Order Items (Only!) in the Orderable Item file; Private
 N DA ; Used in For loop below
 N DIK S DIK="^ORD(101.43,"
 N I S I=0
 FOR  S I=$O(^ORD(101.43,"ID",I)) QUIT:I=""  DO
 . I I["PSP" S DA=$O(^ORD(101.43,"ID",I,"")) D ^DIK
 QUIT
 ;
CPRS ; Now, update the CPRS lists (sync with Orderable Item file) - 
 ; Uses a CPRS API to do this; Private
 ; Next 3 variables are required as inputs
 N ATTEMPT S ATTEMPT=0 ; Attempt to Update
 N UPDTIME S UPDTIME=$HOROLOG ; Update Time
 N DGNM ; Dialog Name
 ; IVA RX -> Additives; IVB RX -> Solutions
 ; IVM RX -> Inpatient Meds for Outpatients
 ; NV RX -> Non-VA Meds ; O RX -> Outpatient
 ; UD RX -> Unit Dose
 FOR DGNM="IVA RX","IVB RX","IVM RX","NV RX","O RX","UD RX" DO
 . D MES^XPDUTL(" --> Rebuilding "_DGNM)
 . D FVBLD^ORWUL
 QUIT
 ;

SYNFMED2
SYNFMED2        ;ven/gpl - fhir loader utilities ; 2/20/18 4:11am
        ;;1.0;fhirloader;;oct 19, 2017;Build 10
        ;
        ; Authored by George P. Lilly 2017-2018
        ;
        q
        ;
importMeds(rtn,ien,args)        ; entry point for loading Medications for a patient
        ; calls the intake Medications web service directly
        ;
        n grtn
        n root s root=$$setroot^%wd("fhir-intake")
        d wsIntakeMeds(.args,,.grtn,ien)
        i $d(grtn) d  ; something was returned
        . k @root@(ien,"load","meds")
        . m @root@(ien,"load","meds")=grtn("meds")
        . if $g(args("debug"))=1 m rtn=grtn
        s rtn("conditionsStatus","status")=$g(grtn("status","status"))
        s rtn("conditionsStatus","loaded")=$g(grtn("status","loaded"))
        s rtn("conditionsStatus","errors")=$g(grtn("status","errors"))
        ;b
        ;
        ;
        q
        ;
wsIntakeMeds(args,body,result,ien)      ; web service entry (post)
        ; for intake of one or more Meds. input are fhir resources
        ; result is json and summarizes what was done
        ; args include patientId
        ; ien is specified for internal calls, where the json is already in a graph
        n jtmp,json,jrslt,eval
        ;i $g(ien)'="" if $$loadStatus("meds","",ien)=1 d  q  ;
        ;. s result("medstatus","status")="alreadyLoaded"
        i $g(ien)'="" d  ; internal call
        . d getIntakeFhir^SYNFHIR("json",,"MedicationRequest",ien,1)
        e  d  ; 
        . merge jtmp=BODY
        . do DECODE^VPRJSON("jtmp","json")
        ;
        ;i '$d(json) d getRandomMeds(.json)
        ;
        i '$d(json) q  ;
        m ^gpl("gjson")=json
        ;
        ; determine the patient
        ;
        n dfn,eval
        if $g(ien)'="" d  ;
        . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
        else  d  ;
        . s dfn=$g(args("dfn"))
        . i dfn="" d  ;
        . . n icn s icn=$g(args("icn"))
        . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
        i $g(dfn)="" do  quit  ; need the patient
        . s result("meds",1,"log",1)="Error, patient not found.. terminating"
        ;
        new zi s zi=0
        for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
        . ;
        . ; define a place to log the processing of this entry
        . ;
        . new jlog set jlog=$name(eval("meds",zi))
        . ;
        . ; insure that the resourceType is MedsIntolerance
        . ;
        . new type set type=$get(json("entry",zi,"resource","resourceType"))
        . if type'="MedicationRequest" do  quit  ;
        . . set eval("meds",zi,"vars","resourceType")=type
        . . do log(jlog,"Resource type not MedicationReference, skipping entry")
        . set eval("meds",zi,"vars","resourceType")=type
        . ;
        . ; see if this resource has already been loaded. if so, skip it
        . ;
        . if $g(ien)'="" if $$loadStatus("meds",zi,ien)=1 do  quit  ;
        . . d log(jlog,"Meds already loaded, skipping")
        . ;
        . ; determine Meds rxnorm code, coding system, and display text
        . ;
        . n med,rxnorm,codesystem,drugname
        . d getEntry^SYNFHIR("med",ien,zi-1) ; meds are in the previous entry
        . n gmed s gmed=$na(med("entry",zi-1,"resource"))
        . q:$g(@gmed@("resourceType"))'="Medication"
        . s rxnorm=$g(@gmed@("code","coding",1,"code"))
        . q:rxnorm=""
        . s drugname=$g(@gmed@("code","coding",1,"display"))
        . s codesystem=$g(@gmed@("code","coding",1,"system"))
        . s codesystem=$re($p($re(codesystem),"/"))
        . ;
        . do log(jlog,"rxnorm code is: "_rxnorm)
        . set eval("meds",zi,"vars","rxnorm")=rxnorm
        . do log(jlog,"drug name is: "_drugname)
        . set eval("meds",zi,"vars","drugname")=drugname
        . ;
        . ;
        . do log(jlog,"code system is: "_codesystem)
        . set eval("meds",zi,"vars","codeSystem")=codesystem
        . ;
        . ; determine the order date and time
        . ;
        . new orderdate set orderdate=$get(json("entry",zi,"resource","authoredOn"))
        . do log(jlog,"orderdateTime is: "_orderdate)
        . set eval("meds",zi,"vars","orderdateTime")=orderdate
        . new fmOrderDateTime s fmOrderDateTime=$$fhirTfm^SYNFUTL(orderdate)
        . d log(jlog,"fileman orderdateTime is: "_fmOrderDateTime)
        . set eval("meds",zi,"vars","fmOrderdateTime")=fmOrderDateTime ;
        . new hl7OrderdateTime s hl7OrderdateTime=$$fhirThl7^SYNFUTL(orderdate)
        . d log(jlog,"hl7 orderdateTime is: "_hl7OrderdateTime)
        . set eval("meds",zi,"vars","hl7OrderdateTime")=hl7OrderdateTime ;
        . ;
        . ; determine clinical status (active vs inactive)
        . ;
        . n clinicalstatus set clinicalstatus=$get(json("entry",zi,"resource","verificationStatus"))
        . ;
        . ;
        . ; set up to call the data loader
        . ;
        . ;
        . if $g(args("load"))=1 d  ; only load if told to
        . . if $g(ien)'="" if $$loadStatus("meds",zi,ien)=1 do  quit  ;
        . . . d log(jlog,"Meds already loaded, skipping")
        . . d log(jlog,"Calling WRITERXRXN^SYNFMED to add meds")
        . . n RESTA
        . . S RESTA=$$WRITERXRXN^SYNFMED(dfn,rxnorm,fmOrderDateTime)
        . . m eval("meds",zi,"status")=RESTA
        . . d log(jlog,"Response from WRITERXRXN^SYNFMED is: "_RESTA)
        . . d log(jlog,"Medication loaded: "_rxnorm_" "_drugname)
        . . if RESTA>1 d  ; success
        . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
        . . . s eval("meds",zi,"status","loadstatus")="loaded"
        . . else  d  ;
        . . . s eval("status","errors")=$g(eval("status","errors"))+1
        . . . s eval("meds",zi,"status","loadstatus")="notLoaded"
        . . . s eval("meds",zi,"status","loadMessage")=$g(RETSTA)
        . . n root s root=$$setroot^%wd("fhir-intake")
        . . k @root@(ien,"load","meds",zi)
        . . m @root@(ien,"load","meds",zi)=eval("meds",zi)
        ;
        if $get(args("debug"))=1 do  ;
        . m jrslt("source")=json
        . m jrslt("args")=args
        . m jrslt("eval")=eval
        m jrslt("medsStatus")=eval("medsStatus")
        set jrslt("result","status")="ok"
        set jrslt("result","loaded")=$g(eval("status","loaded"))
        i $g(ien)'="" d  ; called internally
        . m result=eval
        . m result("status")=jrslt("result")
        . m result("dfn")=dfn
        . m result("ien")=ien
        . ;b
        e  d  ;
        . d ENCODE^VPRJSON("jrslt","result")
        . set HTTPRSP("mime")="application/json" 
        q
        ;
log(ary,txt)    ; adds a text line to @ary@("log")
        s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
        w:$G(DEBUG) !,"      ",$G(txt)
        q
        ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
        n root s root=$$setroot^%wd("fhir-intake")
        n rt s rt=0
        i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
        i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
        q rt
        ;
testall ; run the meds import on all imported patients
        new root s root=$$setroot^%wd("fhir-intake")
        new indx s indx=$na(@root@("POS","DFN"))
        n dfn,ien,filter,reslt
        s dfn=0
        f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
        . s ien=$o(@indx@(dfn,""))
        . q:ien=""
        . s filter("dfn")=dfn
        . k reslt
        . d wsIntakeMeds(.filter,,.reslt,ien)
        q
        ;
testone(reslt,doload)   ; run the meds import on one imported patient
        new root s root=$$setroot^%wd("fhir-intake")
        new indx s indx=$na(@root@("POS","DFN"))
        n dfn,ien,filter
        n done s done=0
        s dfn=0
        f  s dfn=$o(@indx@(dfn)) q:+dfn=0  q:done   d  ;
        . s ien=$o(@indx@(dfn,""))
        . q:ien=""
        . q:$d(@root@(ien,"load","meds"))
        . s filter("dfn")=dfn
        . s filter("debug")=1
        . i $g(doload)=1 s filter("load")=1
        . k reslt
        . d wsIntakeMeds(.filter,,.reslt,ien)
        . s done=1
        q
        ;
getRandomMeds(ary) ; make a web service call to get random allergies
 n srvr
 s srvr="http://postfhir.vistaplex.org:9080/"
 i srvr["postfhir.vistaplex.org" s srvr="http://138.197.70.229:9080/"
 i $g(^%WURL)["http://postfhir.vistaplex.org:9080" d  q  ;
 . s srvr="localhost:9080/"
 . n url
 . s url=srvr_"randommeds"
 . n ok,r1
 . s ok=$$%^%WC(.r1,"GET",url)
 . i '$d(r1) q  ;
 . d DECODE^VPRJSON("r1","ary")
 n url
 s url=srvr_"randommeds"
 n ret,json,jtmp
 s ret=$$GETURL^XTHC10(url,,"jtmp")
 d assemble^SYNFPUL("jtmp","json")
 i '$d(json) q  ;
 d DECODE^VPRJSON("json","ary")
 q
 ;
medsum ; search all loaded patients and catelog the procedure codes
 n root,json,ien,table
 s root=$$setroot^%wd("fhir-intake")
 s ien=0
 f  s ien=$o(@root@(ien)) q:+ien=0  d  ;
 . k json
 . d getIntakeFhir^SYNFHIR("json",,"MedicationRequest",ien,1)
 . n cde,txt,rien
 . s rien=0
 . f  s rien=$o(json("entry",rien)) q:+rien=0  d  ;
 . . n med
 . . d getEntry^SYNFHIR("med",ien,rien-1) ; meds are in the previous entry
 . . n gmed s gmed=$na(med("entry",rien-1,"resource"))
 . . q:$g(@gmed@("resourceType"))'="Medication"
 . . s cde=$g(@gmed@("code","coding",1,"code"))
 . . q:cde=""
 . . s txt=$g(@gmed@("code","coding",1,"display"))
 . . n sys s sys=$g(@gmed@("code","coding",1,"system"))
 . . s sys=$re($p($re(sys),"/"))
 . . s txt=txt_" - "_sys
 . . i '$d(table(cde_" "_txt)) s table(cde_" "_txt)=1 q  ;
 . . s table(cde_" "_txt)=$g(table(cde_" "_txt))+1
 zwr table
 q
 ;

SYNFPAT
SYNFPAT ;ven/gpl - fhir loader utilities ;2018-05-08  4:18 PM
 ;;1.0;fhirloader;;oct 19, 2017;Build 2
 ;
 ; Authored by George P. Lilly 2017-2018
 ;
 q
 ;
importPatient(rtn,ien) ; register and import a fhir patient (demographics only)
 ;
 if $get(ien)="" quit
 new fhir
 do getIntakeFhir^SYNFHIR("fhir",,"Patient",ien)
 ;
 ; set up logging and parameter area
 ;
 new PLD merge PLD=@$$setPLD^SYNFUTL(ien,"Patient")
 new parms set parms=PLD("parms") ; global name of where to put the parms
 ;
 if $g(@PLD("status")@("loadStatus"))="loaded" do  quit  ;
 . new zdfn s zdfn=$g(@PLD("status")@("DFN"))
 . do log^SYNFUTL("Patient "_ien_" already loaded DFN= "_zdfn)
 . set rtn("loadStatus")="already loaded"
 . set rtn("dfn")=zdfn
 ;
 kill @PLD("parms")
 kill @PLD("log")
 ;
 do log^SYNFUTL("Patient load begins for fhirien= "_ien)
 ;
 ; name
 ;
 new patname
 set patname=$$patname("fhir") 
 if patname'="" do  ;
 . set @parms@("NAME")=patname
 . do log^SYNFUTL("Patient name is: "_patname)
 else  do log^SYNFUTL("Patient Name Error")
 ; need to find the entry for the Patient resource
 ;
 n zntry s zntry=$o(fhir("Patient","entry",""))
 ;
 ;
 ; gender
 ;
 new psex
 set psex=$get(fhir("Patient","entry",zntry,"resource","gender"))
 if psex'="" do  ;
 . do log^SYNFUTL("Patient gender is: "_psex)
 . set @parms@("SEX")=$select(psex="male":"M",psex="female":"F",1:"F")
 else  do log^SYNFUTL("Patient gender not found")
 ;
 ; date of birth
 ;
 new dob
 set dob=$get(fhir("Patient","entry",zntry,"resource","birthDate"))
 if dob'="" do  ;
 . new X,Y
 . set X=dob
 . do ^%DT
 . if Y=-1 do log^SYNFUTL("Patient date of birth error "_dob) quit  ;
 . set @parms@("DOB")=Y
 else  do log^SYNFUTL("Patient date of birth error "_dob)
 ;
 ; id - fhir id, not ICN
 ;
 new pid
 set pid=$get(fhir("Patient","entry",zntry,"resource","id"))
 if pid="" do log^SYNFUTL("Patient ID is missing")
 else  do  ;
 . set @parms@("ID")=pid
 . do log^SYNFUTL("Patient ID is "_pid)
 ;
 ; ethnicity code
 ;
 do INITMAPS^SYNQLDM
 new eary,ecd
 ;do adb^SYNFUTL("eary","fhir","text","ethnicity") ; array defined by 
 ;set ecd=$get(eary("coding",1,"code")) ; the ethnic code
 set ecd=$$deriveCode("fhir","us-core-ethnicity",zntry)
 if ecd'="" d  ;
 . do log^SYNFUTL("Ethnicity code is "_ecd)
 . new ecdn
 . set ecdn=$$MAP^SYNQLDM(ecd)
 . if ecdn="" do  quit  ;
 . . do log^SYNFUTL("Ethnicity code "_ecd_" does not map")
 . set @parms@("ETHNICITY")=ecdn
 else  do log^SYNFUTL("Ethnicity code missing")
 ;
 ; race code
 ;
 new rary,rcd
 ;do adb^SYNFUTL("rary","fhir","text","race") ; array defined by 
 ;set rcd=$get(rary("coding",1,"code")) ; the ethnic code
 set rcd=$$deriveCode("fhir","us-core-race",zntry)
 if rcd'="" d  ;
 . do log^SYNFUTL("Race code is "_rcd)
 . new rcdn
 . set rcdn=$$MAP^SYNQLDM(rcd)
 . if rcdn="" do  quit  ;
 . . do log^SYNFUTL("Race code "_rcd_" does not map")
 . set @parms@("RACE")=rcdn
 else  do log^SYNFUTL("Race code missing")
 ;
 ; address
 ;
 s @parms@("CITY")=$g(fhir("Patient","entry",zntry,"resource","address",1,"city"))
 s @parms@("STATE")=$g(fhir("Patient","entry",zntry,"resource","address",1,"state"))
 s @parms@("ZIP")=$g(fhir("Patient","entry",zntry,"resource","address",1,"postalCode"))
 s @parms@("STREET_ADD1")=$g(fhir("Patient","entry",zntry,"resource","address",1,"line",1))
 s @parms@("PH_NUM")=$g(fhir("Patient","entry",zntry,"resource","telecom",1,"value"))
 s @parms@("IMP_TYPE")="I" ; individual not batch load
 s @parms@("SSN")=$$patssn("fhir")
 s @parms@("MARITAL_STATUS")=$get(fhir("Patient","entry",zntry,"resource","maritalStatus","coding",1,"code"))
 ;
 ; call import routine
 ;
 n MISC
 m MISC=@parms
 n ISIRC s ISIRC=$$IMPORTPT^ISIIMP03(.MISC)
 d log^SYNFUTL("Called IMPORTPT^ISIIMP03 to import patient")
 d log^SYNFUTL("Return code from Import: "_ISIRC)
 d log^SYNFUTL("Return values from Import: "_$G(ISIRESUL(1)))
 i ISIRC="" do  quit  ;
 . d log^SYNFUTL("No return from patient load")
 . s rtn("status")="Patient load error"
 n zdfn s zdfn=0
 i $g(ISIRESUL(1))'="" s zdfn=$P(ISIRESUL(1),"^",1)
 ;
 ; load failed
 ;
 i +zdfn<1 d  q  ;
 . s rtn("loadStatus")="notLoaded"
 . s rtn("loadMessage")=ISIRC
 . s @PLD("status")@("loadStatus")="notLoaded"
 . s @PLD("status")@("loadMessage")=ISIRC
 ;
 ; load successful
 ;
 new icn set icn=$$newIcn(zdfn)
 if icn'=-1 s @PLD("status")@("ICN")=icn
 s @PLD("status")@("DFN")=zdfn
 s @PLD("status")@("loadStatus")="loaded"
 set @PLD("index")@("DFN",zdfn,ien)=""
 set @PLD("index")@("ICN",icn,ien)=""
 set @PLD("index")@(ien,"DFN",zdfn)=""
 set @PLD("index")@(ien,"ICN",icn)=""
 d setIndex^SYNFUTL(ien,"DFN",zdfn)
 d setIndex^SYNFUTL(ien,"ICN",icn)
 ;
 s rtn("dfn")=zdfn
 s rtn("loadStatus")="loaded" 
 if icn'=-1 s rtn("icn")=icn
 ;
 quit
 ;
deriveCode(zary,zname,zntry) ; finds the code for ethnicity and race
 ;
 n zary2,zdex,zz1,zurl,done,zcode
 s zcode=""
 s done=0
 s zzi=0
 f  s zzi=$o(@zary@("Patient","entry",zntry,"resource","extension",zzi)) q:+zzi=0  q:done  d  ;
 . s zurl=$g(@zary@("Patient","entry",zntry,"resource","extension",zzi,"url"))
 . i $$urlEnd^SYNFUTL(zurl)=zname d  ;
 . . m zary2=@zary@("Patient","entry",zntry,"resource","extension",zzi)
 . . d valueDex2^SYNFUTL("zary2","zdex")
 . . q:'$d(zdex)
 . . s zcode=$o(zdex("code",""))
 . . q:zcode=""
 . . s done=1
 q zcode
 ;
patname(ary) ; ary is passed by name
 new given,family
 n zntry s zntry=$o(@ary@("Patient","entry","")) ; which resource is the Patient
 ;
 ; Synthea patient resources are 1; new fhir Patient resources are 2
 ;
 set family=$get(@ary@("Patient","entry",zntry,"resource","name",1,"family"))
 set given=$get(@ary@("Patient","entry",zntry,"resource","name",1,"given",1))
 if family="" quit ""
 if given="" quit ""
 new X,Y
 set X=family
 x ^%ZOSF("UPPERCASE")
 set family=Y
 set X=given
 x ^%ZOSF("UPPERCASE")
 set given=Y
 ;
 quit family_","_given
 ;
patssn(fary) ; extrinsic returns the ssn of the patient extracted from
 ; the fhir array, passed by name
 new ssnref,tary,ssn
 ; set ssnref="http://standardhealthrecord.org/fhir/StructureDefinition/shr-demographics-SocialSecurityNumber-extension"
 set ssnref="http://hl7.org/fhir/sid/us-ssn"
 do adb^SYNFUTL("tary",fary,"system",ssnref) ; array defined by
 ;
 set ssn=$get(tary("value"))
 if ssn["-" set ssn=$tr(ssn,"-","")
 quit ssn
 ;
 ; sample patient fhir
 ;g("Patient","entry",1,"fullUrl")="urn:uuid:a13f2440-a3ec-419a-8259-82710d695fdf"
 ;g("Patient","entry",1,"resource","address",1,"city")="Fitchburg"
 ;g("Patient","entry",1,"resource","address",1,"country")="US"
 ;g("Patient","entry",1,"resource","address",1,"extension",1,"extension",1,"url")="latitude"
 ;g("Patient","entry",1,"resource","address",1,"extension",1,"extension",1,"valueDecimal")=42.562168065623744
 ;g("Patient","entry",1,"resource","address",1,"extension",1,"extension",2,"url")="longitude"
 ;g("Patient","entry",1,"resource","address",1,"extension",1,"extension",2,"valueDecimal")=-71.81748413047194
 ;g("Patient","entry",1,"resource","address",1,"extension",1,"url")="http://hl7.org/fhir/StructureDefinition/geolocation"
 ;g("Patient","entry",1,"resource","address",1,"line",1)="9802 Bosco Field"
 ;g("Patient","entry",1,"resource","address",1,"line",2)="Suite 454"
 ;g("Patient","entry",1,"resource","address",1,"postalCode")="01420"
 ;g("Patient","entry",1,"resource","address",1,"state")="MA"
 ;g("Patient","entry",1,"resource","birthDate")="1925-06-02"
 ;g("Patient","entry",1,"resource","communication",1,"language","coding",1,"code")="en-US"
 ;g("Patient","entry",1,"resource","communication",1,"language","coding",1,"display")="English (United States)"
 ;g("Patient","entry",1,"resource","communication",1,"language","coding",1,"system")="http://hl7.org/fhir/ValueSet/languages"
 ;g("Patient","entry",1,"resource","deceasedDateTime")="2002-10-08T06:31:48-04:00"
 ;g("Patient","entry",1,"resource","extension",1,"url")="http://hl7.org/fhir/us/core/StructureDefinition/us-core-race"
 ;g("Patient","entry",1,"resource","extension",1,"valueCodeableConcept","coding",1,"code")="2106-3"
 ;g("Patient","entry",1,"resource","extension",1,"valueCodeableConcept","coding",1,"display")="White"
 ;g("Patient","entry",1,"resource","extension",1,"valueCodeableConcept","coding",1,"system")="http://hl7.org/fhir/v3/Race"
 ;g("Patient","entry",1,"resource","extension",1,"valueCodeableConcept","text")="race"
 ;g("Patient","entry",1,"resource","extension",2,"url")="http://hl7.org/fhir/us/core/StructureDefinition/us-core-ethnicity"
 ;g("Patient","entry",1,"resource","extension",2,"valueCodeableConcept","coding",1,"code")="2186-5"
 ;g("Patient","entry",1,"resource","extension",2,"valueCodeableConcept","coding",1,"display")="Nonhispanic"
 ;g("Patient","entry",1,"resource","extension",2,"valueCodeableConcept","coding",1,"system")="http://hl7.org/fhir/v3/Ethnicity"
 ;g("Patient","entry",1,"resource","extension",2,"valueCodeableConcept","text")="ethnicity"
 ;g("Patient","entry",1,"resource","extension",3,"url")="http://hl7.org/fhir/StructureDefinition/birthPlace"
 ;g("Patient","entry",1,"resource","extension",3,"valueAddress","city")="Easton"
 ;g("Patient","entry",1,"resource","extension",3,"valueAddress","country")="US"
 ;g("Patient","entry",1,"resource","extension",3,"valueAddress","state")="MA"
 ;g("Patient","entry",1,"resource","extension",4,"url")="http://hl7.org/fhir/StructureDefinition/patient-mothersMaidenName"
 ;g("Patient","entry",1,"resource","extension",4,"valueString")="Jeramie91 Waelchi310"
 ;g("Patient","entry",1,"resource","extension",5,"url")="http://hl7.org/fhir/us/core/StructureDefinition/us-core-birthsex"
 ;g("Patient","entry",1,"resource","extension",5,"valueCode")="M"
 ;g("Patient","entry",1,"resource","extension",6,"url")="http://hl7.org/fhir/StructureDefinition/patient-interpreterRequired"
 ;g("Patient","entry",1,"resource","extension",6,"valueBoolean")="false"
 ;g("Patient","entry",1,"resource","extension",7,"url")="http://standardhealthrecord.org/fhir/StructureDefinition/shr-actor-FictionalPerson-extension"
 ;g("Patient","entry",1,"resource","extension",7,"valueBoolean")="true"
 ;g("Patient","entry",1,"resource","extension",8,"url")="http://standardhealthrecord.org/fhir/StructureDefinition/shr-demographics-FathersName-extension"
 ;g("Patient","entry",1,"resource","extension",8,"valueHumanName","text")="Veronica383 Abbott509"
 ;g("Patient","entry",1,"resource","extension",9,"url")="http://standardhealthrecord.org/fhir/StructureDefinition/shr-demographics-SocialSecurityNumber-extension"
 ;g("Patient","entry",1,"resource","extension",9,"valueString")="999-67-7452"
 ;g("Patient","entry",1,"resource","gender")="male"
 ;g("Patient","entry",1,"resource","id")="a13f2440-a3ec-419a-8259-82710d695fdf"
 ;g("Patient","entry",1,"resource","identifier",1,"system")="https://github.com/synthetichealth/synthea"
 ;g("Patient","entry",1,"resource","identifier",1,"value")="72bcbb80-2cbd-4523-82c1-30a34e08a72a"
 ;g("Patient","entry",1,"resource","identifier",2,"system")="http://hl7.org/fhir/sid/us-ssn"
 ;g("Patient","entry",1,"resource","identifier",2,"type","coding",1,"code")="SB"
 ;g("Patient","entry",1,"resource","identifier",2,"type","coding",1,"system")="http://hl7.org/fhir/identifier-type"
 ;g("Patient","entry",1,"resource","identifier",2,"value")=999677452
 ;g("Patient","entry",1,"resource","identifier",2,"value","\s")=""
 ;g("Patient","entry",1,"resource","identifier",3,"system")="urn:oid:2.16.840.1.113883.4.3.25"
 ;g("Patient","entry",1,"resource","identifier",3,"type","coding",1,"code")="DL"
 ;g("Patient","entry",1,"resource","identifier",3,"type","coding",1,"system")="http://hl7.org/fhir/v2/0203"
 ;g("Patient","entry",1,"resource","identifier",3,"value")="S99925046"
 ;g("Patient","entry",1,"resource","maritalStatus","coding",1,"code")="M"
 ;g("Patient","entry",1,"resource","maritalStatus","coding",1,"system")="http://hl7.org/fhir/v3/MaritalStatus"
 ;g("Patient","entry",1,"resource","maritalStatus","text")="M"
 ;g("Patient","entry",1,"resource","meta","profile",1)="http://standardhealthrecord.org/fhir/StructureDefinition/shr-demographics-PersonOfRecord"
 ;g("Patient","entry",1,"resource","multipleBirthBoolean")="false"
 ;g("Patient","entry",1,"resource","name",1,"family")="Abbott509"
 ;g("Patient","entry",1,"resource","name",1,"given",1)="Arlie395"
 ;g("Patient","entry",1,"resource","name",1,"prefix",1)="Mr."
 ;g("Patient","entry",1,"resource","name",1,"use")="official"
 ;g("Patient","entry",1,"resource","resourceType")="Patient"
 ;g("Patient","entry",1,"resource","telecom",1,"system")="phone"
 ;g("Patient","entry",1,"resource","telecom",1,"use")="home"
 ;g("Patient","entry",1,"resource","telecom",1,"value")="(454) 841-5126"
 ;g("Patient","entry",1,"resource","text","div")="<div>Generated by <a href=""https://github.com/synthetichealth/synthea"""
 ;g("Patient","entry",1,"resource","text","div","\",1)=">Synthea</a>. Version identifier: 4d02400401b9fab839e47bf5b2f1f6a8c683ab55</div>"
 ;g("Patient","entry",1,"resource","text","status")="generated"
 ;
 ; patient load template (D LOADMISC^ISIIMPU1(.G))
 ;G("CITY")="FIELD|.114"
 ;G("DFN_NAME")="PARAM|"
 ;G("DOB")="FIELD|.03"
 ;G("EMPLOY_STAT")="FIELD|.31115"
 ;G("ETHNICITY")="FIELD|2.06,.01"
 ;G("IMP_BATCH_NUM")="PARAM|"
 ;G("IMP_TYPE")="PARAM|"
 ;G("INSUR_TYPE")="FIELD|2.312,.01"
 ;G("LOW_DOB")="PARAM|.03"
 ;G("MARITAL_STATUS")="FIELD|.05"
 ;G("MRG_SOURCE")="FIELD|.01"
 ;G("NAME")="FIELD|.01"
 ;G("NAME_MASK")="MASK|.01"
 ;G("OCCUPATION")="FIELD|.07"
 ;G("PH_NUM")="FIELD|.131"
 ;G("PH_NUM_MASK")="MASK|.131"
 ;G("RACE")="FIELD|2.02,.01"
 ;G("SEX")="FIELD|.02"
 ;G("SSN")="FIELD|.09"
 ;G("SSN_MASK")="MASK|.09"
 ;G("STATE")="FIELD|.115"
 ;G("STREET_ADD1")="FIELD|.111"
 ;G("STREET_ADD2")="FIELD|.112"
 ;G("TEMPLATE")="PARAM|"
 ;G("TYPE")="FIELD|391"
 ;G("UP_DOB")="PARAM|.03"
 ;G("VETERAN")="FIELD|1901"
 ;G("ZIP_4")="FIELD|.1112"
 ;G("ZIP_4_MASK")="MASK|.1112
 ;"
newIcn(dfn) ; extrinsic which creates a new ICN for the patient
 ; if none exists. returns the ICN
 ;
 new tmpicn
 set tmpicn=$$icn(dfn)
 if tmpicn'=-1 do  quit tmpicn  
 . n ien s ien=$$dfn2ien^SYNFUTL(dfn)
 . if ien'="" do setIndex^SYNFUTL(ien,"ICN",tmpicn)
 ;
 ; lock here
 ;
 set tmpicn=$o(^DPT("AICN",99999999999),-1)+1
 if tmpicn=1 s tmpicn=50000001 ; first ICN in the system
 ;
 ;991.01    INTEGRATION CONTROL NUMBER (NJ12,0Xa), [MPI;1]          
 ;991.02    ICN CHECKSUM (Fa), [MPI;2]
 ;991.1     FULL ICN (FXa), [MPI;10]
 ;
 new fda,tchk
 set tchk=$$CHECKDG^MPIFSPC(tmpicn)
 set fda(2,dfn_",",991.01)=tmpicn
 set fda(2,dfn_",",991.02)=tchk
 set fda(2,dfn_",",991.1)=tmpicn_"V"_tchk
 do UPDATE^DIE("","fda",,"err")
 if $data(err) do  quit -1
 . D ^ZTER
 ;
 new ficn s ficn=tmpicn_"V"_tchk
 S ^DPT("AFICN",ficn,dfn)=""
 S ^DPT("ARFICN",dfn,ficn)=""
 ;
 n ien s ien=$$dfn2ien^SYNFUTL(dfn)
 if ien'="" do setIndex^SYNFUTL(ien,"ICN",ficn)
 ;
 quit ficn
 ;
icn(dfn) ; extrinsic returns the ICN of the patient
 ; returns -1 if none exists
 new zicn
 set zicn=$$GET1^DIQ(2,dfn_",",991.01)
 ;set zicn=$o(^DPT("AICN",dfn,""))
 if zicn="" q -1
 ;
 quit zicn_"V"_$$CHECKDG^MPIFSPC(zicn)
 ;
fixindex1 ; create the ICN and DFN indexes
 d clearIndexes^SYNFUTL ; blow away the indexes
 n gn,zi
 s gn=$$setroot^%wd("fhir-intake")
 s zi=0
 f  s zi=$o(@gn@(zi)) q:+zi=0  d  ;
 . n gn2,dfn,icn
 . s gn2=$na(@gn@(zi,"load","Patient","status"))
 . w !,gn2," ",$g(@gn2@("DFN"))
 . s dfn=$g(@gn2@("DFN"))
 . q:dfn=""
 . ;s icn=$g(@gn2@("ICN"))
 . s icn=$o(^DPT("ARFICN",dfn,""))
 . q:icn=""
 . s @gn@(zi,"DFN",dfn)=""
 . d setIndex^SYNFUTL(zi,"DFN",dfn)
 . i icn'="" d  
 . . s @gn@(zi,"ICN",icn)=""
 . . d setIndex^SYNFUTL(zi,"ICN",icn)
 q
 ;
fixicn1 ; fix all DPT ICN indexes
 k ^DPT("AICN")
 K ^DPT("AFICN")
 K ^DPT("AFRICN")
 n zi s zi=0
 f  s zi=$o(^DPT(zi)) q:+zi=0  d  ;
 . n icn,icnck
 . s icn=$$GET1^DIQ(2,zi_",",991.01)
 . s icnck=$$GET1^DIQ(2,zi_",",991.02)
 . q:icn=""
 . q:icnck=""
 . n ficn s ficn=icn_"V"_icnck
 . s ^DPT("AICN",icn,zi)=""
 . s ^DPT("AFICN",ficn,zi)=""
 . s ^DPT("ARFICN",zi,ficn)=""
 q
 ;

SYNFPR2
SYNFPR2 ;ven/gpl - fhir loader utilities ; 2/24/18 4:55am
        ;;1.0;fhirloader;;oct 19, 2017;Build 2
        ;
        ; Authored by George P. Lilly 2017-2018
               ;
        ; use SYNDHP61 instead of SYNDHP62 for problem update
        q
        ;
importConditions(rtn,ien,args)   ; entry point for loading Problems for a patient
               ; calls the intake Conditions web service directly
               ;
               n grtn
               n root s root=$$setroot^%wd("fhir-intake")
               d wsIntakeConditions(.args,,.grtn,ien)
               i $d(grtn) d  ; something was returned
               . k @root@(ien,"load","conditions")
               . m @root@(ien,"load","conditions")=grtn("conditions")
               . if $g(args("debug"))=1 m rtn=grtn
               s rtn("conditionsStatus","status")=$g(grtn("status","status"))
               s rtn("conditionsStatus","loaded")=$g(grtn("status","loaded"))
               s rtn("conditionsStatus","errors")=$g(grtn("status","errors"))
               ;b
               ;
               ;
               q
               ;
wsIntakeConditions(args,body,result,ien)               ; web service entry (post)
               ; for intake of one or more Conditions. input are fhir resources
               ; result is json and summarizes what was done
               ; args include patientId
               ; ien is specified for internal calls, where the json is already in a graph
               n jtmp,json,jrslt,eval
               ;i $g(ien)'="" if $$loadStatus("conditions","",ien)=1 d  q  ;
               ;. s result("conditionsStatus","status")="alreadyLoaded"
               i $g(ien)'="" d  ; internal call
               . d getIntakeFhir^SYNFHIR("json",,"Condition",ien,1)
               e  d  ; 
               . s args("load")=0
               . merge jtmp=BODY
               . do DECODE^VPRJSON("jtmp","json")
               i '$d(json) q  ;
               m ^gpl("gjson")=json
               ;
               ; determine the patient
               ;
               n dfn,eval
               if $g(ien)'="" d  ;
               . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
               else  d  ;
               . s dfn=$g(args("dfn"))
               . i dfn="" d  ;
               . . n icn s icn=$g(args("icn"))
               . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
               i $g(dfn)="" do  quit  ; need the patient
               . s result("conditions",1,"log",1)="Error, patient not found.. terminating"
               ;
               ;
               new zi s zi=0
               for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
               . ;
               . ; define a place to log the processing of this entry
               . ;
               . new jlog set jlog=$name(eval("conditions",zi))
               . ;
               . ; insure that the resourceType is Observation
               . ;
               . new type set type=$get(json("entry",zi,"resource","resourceType"))
               . if type'="Condition" do  quit  ;
               . . set eval("conditions",zi,"vars","resourceType")=type
               . . do log(jlog,"Resource type not Condition, skipping entry")
               . set eval("conditions",zi,"vars","resourceType")=type
               . ;
               . ; see if this resource has already been loaded. if so, skip it
               . ;
               . if $g(ien)'="" if $$loadStatus("condition",zi,ien)=1 do  quit  ;
               . . d log(jlog,"Condition already loaded, skipping")
               . ;
               . ; determine Condition snomed code, coding system, and display text
               . ;
               . ;
               . ; determine the id of the resource
               . ;
               . ;new id set id=$get(json("entry",zi,"resource","id"))
               . ;set eval("conditions",zi,"vars","id")=id
               . ;d log(jlog,"ID is: "_id)
               . ;
               . new sctcode set sctcode=$get(json("entry",zi,"resource","code","coding",1,"code"))
               . do log(jlog,"code is: "_sctcode)
               . set eval("conditions",zi,"vars","code")=sctcode
               . ;
               . ;
               . new codesystem set codesystem=$get(json("entry",zi,"resource","code","coding",1,"system"))
               . do log(jlog,"code system is: "_codesystem)
               . set eval("conditions",zi,"vars","codeSystem")=codesystem
               . ;
               . ; determine the onset date and time
               . ;
               . new onsetdate set onsetdate=$get(json("entry",zi,"resource","onsetDateTime"))
               . do log(jlog,"onsetDateTime is: "_onsetdate)
               . set eval("conditions",zi,"vars","onsetDateTime")=onsetdate
               . new fmOnsetDateTime s fmOnsetDateTime=$$fhirTfm^SYNFUTL(onsetdate)
               . d log(jlog,"fileman onsetDateTime is: "_fmOnsetDateTime)
               . set eval("conditions",zi,"vars","fmOnsetDateTime")=fmOnsetDateTime ;
               . new hl7OnsetDateTime s hl7OnsetDateTime=$$fhirThl7^SYNFUTL(onsetdate)
               . d log(jlog,"hl7 onsetDateTime is: "_hl7OnsetDateTime)
               . set eval("conditions",zi,"vars","hl7OnsetDateTime")=hl7OnsetDateTime ;
               . ;
               . ; determine the abatement date and time, if any
               . ;
               . new abatementdate set abatementdate=$get(json("entry",zi,"resource","abatementDateTime"))
               . if abatementdate'="" d  ;
               . . do log(jlog,"abatementDateTime is: "_abatementdate)
               . . set eval("conditions",zi,"vars","abatementDateTime")=abatementdate
               . . new fmAbatementDateTime s fmAbatementDateTime=$$fhirTfm^SYNFUTL(abatementdate)
               . . d log(jlog,"fileman abatementDateTime is: "_fmAbatementDateTime)
               . . set eval("conditions",zi,"vars","fmAbatementDateTime")=fmAbatementDateTime ;
               . . new hl7AbatementDateTime s hl7AbatementDateTime=$$fhirThl7^SYNFUTL(abatementdate)
               . . d log(jlog,"hl7 abatementDateTime is: "_hl7AbatementDateTime)
               . . set eval("conditions",zi,"vars","hl7AbatementDateTime")=hl7AbatementDateTime ;
               . else  d log(jlog,"no abatementDateTime")
               . ;
               . ; determine clinical status (active vs inactive)
               . ;
               . n clinicalstatus set clinicalstatus=$get(json("entry",zi,"resource","clinicalStatus"))
               . i $get(abatementdate)'="" set clinicalstatus="inactive" ; VistA doesn't allow active problems with a resolution date
               . ;
               . ; determine the encounter visit ien
               . n encounterId
               . s encounterId=$g(json("entry",zi,"resource","context","reference"))
               . i encounterId["urn:uuid:" s encounterId=$p(encounterId,"urn:uuid:",2)
               . s eval("conditions",zi,"vars","encounterId")=encounterId
               . d log(jlog,"reference encounter ID is : "_encounterId)
               . ;
               . ; determine visit ien
               . ;
               . n visitIen s visitIen=$$visitIen^SYNFENC(ien,encounterId)
               . s eval("conditions",zi,"vars","visitIen")=visitIen
               . d log(jlog,"visit ien is: "_visitIen)
               . ;
               . ; ckeck to see if the problem is an allergy in VistA
               . ;
               . n algy s algy=$$ISGMR^SYNFALG(sctcode)
               . i algy'=-1 d  ; this condition is an allergy in VistA
               . . n aname s aname=$p(algy,"^",2)
               . . d QADDALGY^KBIAFALG(aname,fmOnsetDateTime,ien)
               . ;
               . ; set up to call the data loader
               . ;
               . ;PRBUPDT(RETSTA,DHPPAT,DHPVST,DHPROV,DHPONS,DHPABT,DHPCLNST,DHPSCT)   ;Problem/Condition update - deprecated
               . ;PROBUPD(RETSTA,DHPPAT,DHPSCT,DHPSDES,DHPROV,DHPDTM,DHPRID) ; problems update - use this one
               . n RETSTA,DHPPAT,DHPSCT,DHPSDES,DHPROV,DHPDTM,DHPRID ;
               . ;n RETSTA,DHPPAT,DHPVST,DHPROV,DHPONS,DHPABT,DHPCLNST,DHPSCT ;Problem/Condition update
               . ;s (DHPPAT,DHPVST,DHPROV,DHPONS,DHPABT,DHPCLNST,DHPSCT)=""      ;Condition update
               . s (DHPPAT,DHPSCT,DHPSDES,DHPROV,DHPDTM,DHPRID)=""
               . ;
               . s DHPPAT=$$dfn2icn^SYNFUTL(dfn)
               . s eval("conditions",zi,"parms","DHPPAT")=DHPPAT
               . ;
               . s DHPVST=visitIen
               . s eval("conditions",zi,"parms","DHPVST")=visitIen
               . ;
               . s DHPSCT=sctcode
               . s eval("conditions",zi,"parms","DHPSCT")=DHPSCT
               . ;
               . ;s DHPCLNST=$S(clinicalstatus="Active":"A",1:"I")
               . ;s eval("conditions",zi,"parms","DHPCLNST")=DHPCLNST
               . ;
               . s DHPDTM=hl7OnsetDateTime
               . s eval("conditions",zi,"parms","DHPDTM")=DHPDTM
               . ;
               . s DHPPROV=$$MAP^SYNQLDM("OP","provider") ; map should return the NPI number
               . ;n DHPPROVIEN s DHPPROVIEN=$o(^VA(200,"B",IMMPROV,""))
               . ;if DHPPROVIEN="" S DHPPROVIEN=3
               . s eval("conditions",zi,"parms","DHPPROV")=DHPPROV
               . d log(jlog,"Provider NPI for outpatient is: "_DHPPROV)
               . ;
               . ;s DHPLOC=$$MAP^SYNQLDM("OP","location")
               . ;n DHPLOCIEN s DHPLOCIEN=$o(^SC("B",DHPLOC,""))
               . ;if DHPLOCIEN="" S DHPLOCIEN=4
               . ;s eval("conditions",zi,"parms","DHPLOC")=DHPLOCIEN
               . ;d log(jlog,"Location for outpatient is: #"_DHPLOCIEN_" "_DHPLOC)
               . ;
               . s eval("conditions",zi,"status","loadstatus")="readyToLoad"
               . ;
               . if $g(args("load"))=1 d  ; only load if told to
               . . if $g(ien)'="" if $$loadStatus("conditions",zi,ien)=1 do  quit  ;
               . . . d log(jlog,"Condition already loaded, skipping")
               . . d log(jlog,"Calling PROBUPD^SYNDHP61 to add condition")
               . . D PROBUPD^SYNDHP61(.RETSTA,DHPPAT,DHPSCT,DHPSDES,DHPROV,DHPDTM,DHPRID) ; problems update - use this one
               . . ;D PRBUPDT^SYNDHP62(.RETSTA,DHPPAT,DHPVST,DHPROV,DHPONS,DHPABT,DHPCLNST,DHPSCT)      ;Problem/Condition update
               . . m eval("conditions",zi,"status")=RETSTA
               . . d log(jlog,"Return from data loader was: "_$g(RETSTA))
               . . if +$g(RETSTA)=1 do  ;
               . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
               . . . s eval("conditions",zi,"status","loadstatus")="loaded"
               . . else  d  ;
               . . . s eval("status","errors")=$g(eval("status","errors"))+1
               . . . s eval("conditions",zi,"status","loadstatus")="notLoaded"
               . . . s eval("conditions",zi,"status","loadMessage")=$g(RETSTA)
               . . n root s root=$$setroot^%wd("fhir-intake")
               . . k @root@(ien,"load","conditions",zi)
               . . m @root@(ien,"load","conditions",zi)=eval("conditions",zi)
               ;
               if $get(args("debug"))=1 do  ;
               . m jrslt("source")=json
               . m jrslt("args")=args
               . m jrslt("eval")=eval
               m jrslt("conditionsStatus")=eval("conditionsStatus")
               set jrslt("result","status")="ok"
               set jrslt("result","loaded")=$g(eval("status","loaded"))
               i $g(ien)'="" d  ; called internally
               . m result=eval
               . m result("status")=jrslt("result")
               . m result("dfn")=dfn
               . m result("ien")=ien
               . ;b
               e  d  ;
               . d ENCODE^VPRJSON("jrslt","result")
               . set HTTPRSP("mime")="application/json" 
               q
               ;
log(ary,txt)       ; adds a text line to @ary@("log")
               s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
               q
               ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
               n root s root=$$setroot^%wd("fhir-intake")
               n rt s rt=0
               i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
               i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
               q rt
               ;
testall ; run the conditions import on all imported patients
               new root s root=$$setroot^%wd("fhir-intake")
               new indx s indx=$na(@root@("POS","DFN"))
               n dfn,ien,filter,reslt
               s dfn=0
               f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
               . s ien=$o(@indx@(dfn,""))
               . q:ien=""
               . s filter("dfn")=dfn
               . k reslt
               . d wsIntakeConditions(.filter,,.reslt,ien)
               q
               ;
testone(reslt,doload)     ; run the conditions import on all imported patients
               new root s root=$$setroot^%wd("fhir-intake")
               new indx s indx=$na(@root@("POS","DFN"))
               n dfn,ien,filter
               n done s done=0
               s dfn=0
               f  s dfn=$o(@indx@(dfn)) q:+dfn=0  q:done   d  ;
               . s ien=$o(@indx@(dfn,""))
               . q:ien=""
               . q:$d(@root@(ien,"load","conditions"))
               . s filter("dfn")=dfn
               . s filter("debug")=1
               . i $g(doload)=1 s filter("load")=1
               . k reslt
               . d wsIntakeConditions(.filter,,.reslt,ien)
               . s done=1
               q
               ;

SYNFPRB
SYNFPRB ;ven/gpl - fhir loader utilities ; 2/20/18 4:11am
        ;;1.0;fhirloader;;oct 19, 2017;Build 2
        ;
        ; Authored by George P. Lilly 2017-2018
        ;
        q
        ;
importConditions(rtn,ien,args)  ; entry point for loading Problems for a patient
        ; calls the intake Conditions web service directly
        ;
        n grtn
        n root s root=$$setroot^%wd("fhir-intake")
        d wsIntakeConditions(.args,,.grtn,ien)
        i $d(grtn) d  ; something was returned
        . k @root@(ien,"load","conditions")
        . m @root@(ien,"load","conditions")=grtn("conditions")
        . if $g(args("debug"))=1 m rtn=grtn
        s rtn("conditionsStatus","status")=$g(grtn("status","status"))
        s rtn("conditionsStatus","loaded")=$g(grtn("status","loaded"))
        s rtn("conditionsStatus","errors")=$g(grtn("status","errors"))
        ;b
        ;
        ;
        q
        ;
wsIntakeConditions(args,body,result,ien)        ; web service entry (post)
        ; for intake of one or more Conditions. input are fhir resources
        ; result is json and summarizes what was done
        ; args include patientId
        ; ien is specified for internal calls, where the json is already in a graph
        n jtmp,json,jrslt,eval
        ;i $g(ien)'="" if $$loadStatus("conditions","",ien)=1 d  q  ;
        ;. s result("conditionsStatus","status")="alreadyLoaded"
        i $g(ien)'="" d  ; internal call
        . d getIntakeFhir^SYNFHIR("json",,"Condition",ien,1)
        e  d  ; 
        . s args("load")=0
        . merge jtmp=BODY
        . do DECODE^VPRJSON("jtmp","json")
        i '$d(json) q  ;
        m ^gpl("gjson")=json
        ;
        ; determine the patient
        ;
        n dfn,eval
        if $g(ien)'="" d  ;
        . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
        else  d  ;
        . s dfn=$g(args("dfn"))
        . i dfn="" d  ;
        . . n icn s icn=$g(args("icn"))
        . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
        i $g(dfn)="" do  quit  ; need the patient
        . s result("conditions",1,"log",1)="Error, patient not found.. terminating"
        ;
        ;
        new zi s zi=0
        for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
        . ;
        . ; define a place to log the processing of this entry
        . ;
        . new jlog set jlog=$name(eval("conditions",zi))
        . ;
        . ; insure that the resourceType is Observation
        . ;
        . new type set type=$get(json("entry",zi,"resource","resourceType"))
        . if type'="Condition" do  quit  ;
        . . set eval("conditions",zi,"vars","resourceType")=type
        . . do log(jlog,"Resource type not Condition, skipping entry")
        . set eval("conditions",zi,"vars","resourceType")=type
        . ;
        . ; see if this resource has already been loaded. if so, skip it
        . ;
        . if $g(ien)'="" if $$loadStatus("condition",zi,ien)=1 do  quit  ;
        . . d log(jlog,"Condition already loaded, skipping")
        . ;
        . ; determine Condition snomed code, coding system, and display text
        . ;
        . ;
        . ; determine the id of the resource
        . ;
        . ;new id set id=$get(json("entry",zi,"resource","id"))
        . ;set eval("conditions",zi,"vars","id")=id
        . ;d log(jlog,"ID is: "_id)
        . ;
        . new sctcode set sctcode=$get(json("entry",zi,"resource","code","coding",1,"code"))
        . do log(jlog,"code is: "_sctcode)
        . set eval("conditions",zi,"vars","code")=sctcode
        . n icdcode,notmapped
        . s notmapped=0
        . s icdcode=$$MAP^SYNDHPMP("scd2icd",sctcode)
        . i +icdcode=-1 s notmapped=1
        . do log(jlog,"icd mapping is: "_icdcode)
        . do:notmapped log(jlog,"snomed code "_sctcode_"is not mapped")
        . set eval("conditions",zi,"vars","mappedIcdCode")=icdcode
        . ;
        . ;
        . new codesystem set codesystem=$get(json("entry",zi,"resource","code","coding",1,"system"))
        . do log(jlog,"code system is: "_codesystem)
        . set eval("conditions",zi,"vars","codeSystem")=codesystem
        . ;
        . ; determine the onset date and time
        . ;
        . new onsetdate set onsetdate=$get(json("entry",zi,"resource","onsetDateTime"))
        . do log(jlog,"onsetDateTime is: "_onsetdate)
        . set eval("conditions",zi,"vars","onsetDateTime")=onsetdate
        . new fmOnsetDateTime s fmOnsetDateTime=$$fhirTfm^SYNFUTL(onsetdate)
        . d log(jlog,"fileman onsetDateTime is: "_fmOnsetDateTime)
        . set eval("conditions",zi,"vars","fmOnsetDateTime")=fmOnsetDateTime ;
        . new hl7OnsetDateTime s hl7OnsetDateTime=$$fhirThl7^SYNFUTL(onsetdate)
        . d log(jlog,"hl7 onsetDateTime is: "_hl7OnsetDateTime)
        . set eval("conditions",zi,"vars","hl7OnsetDateTime")=hl7OnsetDateTime ;
        . ;
        . ; determine the abatement date and time, if any
        . ;
        . new abatementdate set abatementdate=$get(json("entry",zi,"resource","abatementDateTime"))
        . if abatementdate'="" d  ;
        . . do log(jlog,"abatementDateTime is: "_abatementdate)
        . . set eval("conditions",zi,"vars","abatementDateTime")=abatementdate
        . . new fmAbatementDateTime s fmAbatementDateTime=$$fhirTfm^SYNFUTL(abatementdate)
        . . d log(jlog,"fileman abatementDateTime is: "_fmAbatementDateTime)
        . . set eval("conditions",zi,"vars","fmAbatementDateTime")=fmAbatementDateTime ;
        . . new hl7AbatementDateTime s hl7AbatementDateTime=$$fhirThl7^SYNFUTL(abatementdate)
        . . d log(jlog,"hl7 abatementDateTime is: "_hl7AbatementDateTime)
        . . set eval("conditions",zi,"vars","hl7AbatementDateTime")=hl7AbatementDateTime ;
        . else  d log(jlog,"no abatementDateTime")
        . ;
        . ; determine clinical status (active vs inactive)
        . ;
        . n clinicalstatus set clinicalstatus=$get(json("entry",zi,"resource","clinicalStatus"))
        . i $get(abatementdate)'="" set clinicalstatus="inactive" ; VistA doesn't allow active problems with a resolution date
        . ;
        . ; determine the encounter visit ien
        . n encounterId
        . s encounterId=$g(json("entry",zi,"resource","context","reference"))
        . i encounterId["urn:uuid:" s encounterId=$p(encounterId,"urn:uuid:",2)
        . s eval("conditions",zi,"vars","encounterId")=encounterId
        . d log(jlog,"reference encounter ID is : "_encounterId)
        . ;
        . ; determine visit ien
        . ;
        . n visitIen s visitIen=$$visitIen^SYNFENC(ien,encounterId)
        . s eval("conditions",zi,"vars","visitIen")=visitIen
        . d log(jlog,"visit ien is: "_visitIen)
        . ;
        . ; set up to call the data loader
        . ;
        . ;PRBUPDT(RETSTA,DHPPAT,DHPVST,DHPROV,DHPONS,DHPABT,DHPCLNST,DHPSCT)   ;Problem/Condition update
        . n RETSTA,DHPPAT,DHPVST,DHPROV,DHPONS,DHPABT,DHPCLNST,DHPSCT ;Problem/Condition update
        . s (DHPPAT,DHPVST,DHPROV,DHPONS,DHPABT,DHPCLNST,DHPSCT)=""      ;Condition update
        . ;
        . s DHPPAT=$$dfn2icn^SYNFUTL(dfn)
        . s eval("conditions",zi,"parms","DHPPAT")=DHPPAT
        . ;
        . s DHPVST=visitIen
        . s eval("conditions",zi,"parms","DHPVST")=visitIen
        . ;
        . s DHPSCT=sctcode
        . s eval("conditions",zi,"parms","DHPSCT")=DHPSCT
        . ;
        . s DHPCLNST=$S(clinicalstatus="Active":"A",1:"I")
        . s eval("conditions",zi,"parms","DHPCLNST")=DHPCLNST
        . ;
        . s DHPONS=hl7OnsetDateTime
        . s eval("conditions",zi,"parms","DHPONS")=DHPONS
        . ;
        . s DHPROV=$$MAP^SYNQLDM("OP","provider") ; map should return the NPI number
        . ;n DHPPROVIEN s DHPPROVIEN=$o(^VA(200,"B",IMMPROV,""))
        . ;if DHPPROVIEN="" S DHPPROVIEN=3
        . s eval("conditions",zi,"parms","DHPROV")=DHPROV
        . d log(jlog,"Provider NPI for outpatient is: "_DHPROV)
        . ;
        . ;s DHPLOC=$$MAP^SYNQLDM("OP","location")
        . ;n DHPLOCIEN s DHPLOCIEN=$o(^SC("B",DHPLOC,""))
        . ;if DHPLOCIEN="" S DHPLOCIEN=4
        . ;s eval("conditions",zi,"parms","DHPLOC")=DHPLOCIEN
        . ;d log(jlog,"Location for outpatient is: #"_DHPLOCIEN_" "_DHPLOC)
        . ;
        . s eval("conditions",zi,"status","loadstatus")="readyToLoad"
        . ;
        . if $g(args("load"))=1 d  ; only load if told to
        . . if $g(ien)'="" if $$loadStatus("conditions",zi,ien)=1 do  quit  ;
        . . . d log(jlog,"Condition already loaded, skipping")
        . . i notmapped d  ; snomed code does not map to icd code, can't use DATA2PCE
        . . . d log(jlog,"Calling PROBUPD^SYNDHP61 to add condition")
        . . . n DHPSDES,DHPRID,DHPDTM S (DHPSDES,DHPRID)=""
        . . . s DHPDTM=DHPONS
        . . . D PROBUPD^SYNDHP61(.RETSTA,DHPPAT,DHPSCT,DHPSDES,DHPROV,DHPDTM,DHPRID) ; update problem list with Snomed code
        . . i 'notmapped d  ; snomed code does map, use DATA2PCE to add problem to problem list
        . . . d log(jlog,"Calling PRBUPD^SYNDHP62 to add snomed condition")
        . . . D PRBUPDT^SYNDHP62(.RETSTA,DHPPAT,DHPVST,DHPROV,DHPONS,DHPABT,DHPCLNST,DHPSCT)    ;Problem/Condition update
        . . m eval("conditions",zi,"status")=RETSTA
        . . i $g(DEBUG)=1 ZWR RETSTA
        . . d log(jlog,"Return from data loader was: "_$g(RETSTA))
        . . if +$g(RETSTA)=1 do  ;
        . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
        . . . s eval("conditions",zi,"status","loadstatus")="loaded"
        . . else  d  ;
        . . . s eval("status","errors")=$g(eval("status","errors"))+1
        . . . s eval("conditions",zi,"status","loadstatus")="notLoaded"
        . . . s eval("conditions",zi,"status","loadMessage")=$g(RETSTA)
        . . n root s root=$$setroot^%wd("fhir-intake")
        . . k @root@(ien,"load","conditions",zi)
        . . m @root@(ien,"load","conditions",zi)=eval("conditions",zi)
        ;
        if $get(args("debug"))=1 do  ;
        . m jrslt("source")=json
        . m jrslt("args")=args
        . m jrslt("eval")=eval
        m jrslt("conditionsStatus")=eval("conditionsStatus")
        set jrslt("result","status")="ok"
        set jrslt("result","loaded")=$g(eval("status","loaded"))
        i $g(ien)'="" d  ; called internally
        . m result=eval
        . m result("status")=jrslt("result")
        . m result("dfn")=dfn
        . m result("ien")=ien
        . ;b
        e  d  ;
        . d ENCODE^VPRJSON("jrslt","result")
        . set HTTPRSP("mime")="application/json" 
        q
        ;
log(ary,txt)    ; adds a text line to @ary@("log")
        s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
        w:$G(DEBUG) !,"      ",$G(txt)
        q
        ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
        n root s root=$$setroot^%wd("fhir-intake")
        n rt s rt=0
        i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
        i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
        q rt
        ;
testall ; run the conditions import on all imported patients
        new root s root=$$setroot^%wd("fhir-intake")
        new indx s indx=$na(@root@("POS","DFN"))
        n dfn,ien,filter,reslt
        s dfn=0
        f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
        . s ien=$o(@indx@(dfn,""))
        . q:ien=""
        . s filter("dfn")=dfn
        . k reslt
        . d wsIntakeConditions(.filter,,.reslt,ien)
        q
        ;
testone(reslt,doload)   ; run the conditions import on all imported patients
        new root s root=$$setroot^%wd("fhir-intake")
        new indx s indx=$na(@root@("POS","DFN"))
        n dfn,ien,filter
        n done s done=0
        s dfn=0
        f  s dfn=$o(@indx@(dfn)) q:+dfn=0  q:done   d  ;
        . s ien=$o(@indx@(dfn,""))
        . q:ien=""
        . q:$d(@root@(ien,"load","conditions"))
        . s filter("dfn")=dfn
        . s filter("debug")=1
        . i $g(doload)=1 s filter("load")=1
        . k reslt
        . d wsIntakeConditions(.filter,,.reslt,ien)
        . s done=1
        q
        ;

SYNFPUL
SYNFPUL ;ven/gpl - fhir loader utilities ; 2/23/18 5:27am
        ;;1.0;fhirloader;;oct 19, 2017;Build 2
        ;
        ; Authored by George P. Lilly 2017-2018
        ;
        ;
        ; patient list pull routines
        q
        ;
wsPull(rtn,filter)      ; pull web service. assumes url to list is passed as filter("listurl")=url
        ;
        n groot s groot=$$setroot^%wd("patient-lists")
        ;
        n listurl s listurl=$g(filter("listurl"))
        q:listurl=""
        i listurl["synthea1m.vistaplex.org" d  ;
        . s listurl="http://138.197.147.128"_$p(listurl,"synthea1m.vistaplex.org",2)
        ;
        n listname
        s listname=$re($p($re(listurl),"/",1))
        i listname[":" s listname=$p(listname,":",2)
        i listname["?" s listname=$p(listname,"?",1)
        ;
        n ret,json,jtmp
        s ret=$$GETURL^XTHC10(listurl,,"jtmp")
        d assemble("jtmp","json")
        ;s ret=$$%^%WC(.json,"GET",listurl)
        w !,"return is: ",ret,!
        ;zwr json
        ;
        n lien,jary
        s lien=$o(@groot@("B",listname,""))
        i lien'="" k @groot@(lien)
        e  set lien=$order(@groot@(" "),-1)+1
        s @groot@("B",listname,lien)=""
        ;
        set gr=$name(@groot@(lien,"list"))
        do DECODE^VPRJSON("json",gr)
        s @gr@("listname")=listname
        do indexList(lien)
        s rtn("listien")=lien
        ;
        w !
        ;zwr @gr@(*)
        ;
        q
        ;
testpull        ;
        s lurl="http://synthea1m.vistaplex.org:9080/see/tag:random-over50-notDead-M-10-2?format=json"
        s filter("listurl")=lurl
        d wsPull(.g,.filter)
        q
        ;
indexList(ien)  ; produce the index for a patient list
        ;
        n lroot s lroot=$$setroot^%wd("patient-lists")
        n zi s zi=""
        f  s zi=$o(@lroot@(ien,"list","items",zi)) q:zi=""  d  ;
        . n title s title=$g(@lroot@(ien,"list","items",zi,"title"))
        . s @lroot@(ien,"B",title,zi)=""
        q
        ;
wsLol(rtn,filter)       ; list of list web service
        ;
        n groot s groot=$$setroot^%wd("list-of-lists")
        ;
        n listurl s listurl="http://synthea1m.vistaplex.org:9080/see/rand*?format=json"
        ;n listurl s listurl="http://138.197.147.128:9080/see/rand*?format=json"
        ;
        n listname
        s listname=listurl
        ;s listname=$re($p($re(listurl),"/",1))
        ;i listname[":" s listname=$p(listname,":",2)
        i listname["?" s listname=$p(listname,"?",1)
        ;
        n zret,json,jtmp
        ;s zret=$$GETURL^XTHC10(listurl,,"jtmp")
        ;d assemble("jtmp","json")
        s zret=$$%^%WC(.json,"GET",listurl)
        ;w !,"return is: ",zret,!
        ;zwr json
        ;
        n lien,jary
        s lien=$o(@groot@("B",listname,""))
        i lien'="" k @groot@(lien)
        e  set lien=$order(@groot@(" "),-1)+1
        s @groot@("B",listname,lien)=""
        ;
        set gr=$name(@groot@(lien,"list"))
        do DECODE^VPRJSON("json",gr)
        s @gr@("listname")=listname
        do indexLol(lien)
        k @gr@("listname")
        ;
        s rtn=$na(^TMP("SYNFHIR",$J))
        k @rtn
        n jout m jout=@gr
        k jout("listname")
        ;m @rtn=json
        d ENCODE^VPRJSON("jout",rtn)
        set HTTPRSP("mime")="application/json"
        q
        ;
wsLol2(rtn,filter)      ; list of list web service
        ;
        n groot s groot=$$setroot^%wd("list-of-lists")
        ;
        ;n listurl s listurl="http://synthea1m.vistaplex.org:9080/see/rand*?format=json"
        n listurl s listurl="http://138.197.147.128:9080/see/rand*?format=json"
        ;
        n listname
        s listname=listurl
        ;s listname=$re($p($re(listurl),"/",1))
        ;i listname[":" s listname=$p(listname,":",2)
        i listname["?" s listname=$p(listname,"?",1)
        ;
        n zret,json,jtmp
        ;s zret=$$GETURL^XTHC10(listurl,,"jtmp")
        ;d assemble("jtmp","json")
        s zret=$$%^%WC(.json,"GET",listurl)
        ;w !,"return is: ",zret,!
        ;zwr json
        ;
        ;n lien,jary
        ;s lien=$o(@groot@("B",listname,""))
        ;i lien'="" k @groot@(lien)
        ;e  set lien=$order(@groot@(" "),-1)+1
        ;s @groot@("B",listname,lien)=""
        ;
        ;set gr=$name(@groot@(lien,"list"))
        ;do DECODE^VPRJSON("json",gr)
        ;s @gr@("listname")=listname
        ;do indexLol(lien)
        ;k @gr@("listname")
        ;
        s rtn=$na(^TMP("SYNFHIR",$J))
        k @rtn
        ;n jout m jout=@gr
        ;k jout("listname")
        m @rtn=json
        ;d ENCODE^VPRJSON("jout",rtn)
        set HTTPRSP("mime")="application/json"
        q
        ;
indexLol(ien)   ;
        ;
        n lroot s lroot=$$setroot^%wd("list-of-lists")
        n zi s zi=""
        f  s zi=$o(@lroot@(ien,"list","items",zi)) q:zi=""  d  ;
        . n title s title=$g(@lroot@(ien,"list","items",zi,"title"))
        . s @lroot@(ien,"B",title,zi)=""
        q
        ;
getlol  ; get list of lists
        ;
        n groot s groot=$$setroot^%wd("list-of-lists")
        ;
        n listurl 
        ;s listurl="http://synthea1m.vistaplex.org:9080/see/dhp-vista*?format=json"
        s listurl="http://138.197.147.128:9080/see/dhp-vista*?format=json"
        ;
        n listname
        s listname=listurl
        i listname["?" s listname=$p(listname,"?",1)
        ;
        q:$d(@groot@("B",listname)) ; list already loaded
        ;
        n zret,json,jtmp
        ;s zret=$$%^%WC(.json,"GET",listurl)
        s zret=$$GETURL^XTHC10(listurl,,"jtmp")
        d assemble("jtmp","json")
        w !,"return is: ",zret,!
        ;zwr json
        ;
        n lien,jary
        s lien=$o(@groot@("B",listname,""))
        i lien'="" k @groot@(lien)
        e  set lien=$order(@groot@(" "),-1)+1
        s @groot@("B",listname,lien)=""
        ;
        set gr=$name(@groot@(lien,"list"))
        do DECODE^VPRJSON("json",gr)
        s @gr@("listname")=listname
        do indexLol(lien)
        ;
        q
        ;
assemble(in,out)        ; reassemble json from the pieces
        n zi,zj
        s @out=""
        s zi=0
        f  s zi=$o(@in@(zi)) q:+zi=0  d  ;
        . s @out=@out_@in@(zi)
        . s zj=0
        . f  s zj=$o(@in@(zi,zj)) q:+zj=0  d  ;
        . . s @out=@out_$g(@in@(zi,zj))
        q
        ;
load1list(zlist)        ;
        n lroot s lroot=$$setroot^%wd("patient-lists")
        n lolroot s lolroot=$$setroot^%wd("list-of-lists")
        n uselist 
        ;s uselist="http://synthea1m.vistaplex.org:9080/see/dhp-vista*"
        s uselist="http://138.197.147.128:9080/see/dhp-vista*"
        n lolien s lolien=$o(@lolroot@("B",uselist,"")) ; ien of the list of lists
        ;
        n uselist2 s uselist2=zlist
        n zl
        s zl=$o(@lolroot@(lolien,"B",uselist2,""))
        i zl="" d  q  ;
        . w !,"Error, list not found: "_uselist2
        ;
        n ltitle s ltitle=$g(@lolroot@(lolien,"list","items",zl,"title"))
        n lurl s lurl=$g(@lolroot@(lolien,"list","items",zl,"url"))
        ;
        i lurl="" d  q  ;
        . w !,"error list url not found"
        ;
        n lien
        s lien=$o(@lroot@("B",ltitle,""))
        i lien'="" d  q lien  ;
        . w !,"list already loaded: "_ltitle_" ien: "_lien
        ;
        w !,"title: ",ltitle
        w !,"url: ",lurl
        ;
        n filter s filter("listurl")=lurl
        n lret
        d wsPull(.lret,.filter)
        ;
        s lien=$g(lret("listien"))
        i lien="" d  q  ;
        . w !,"error, list ien not returned"
        ;
        q lien
        ;  
test1pat(rtn,start,end) ;
        k rtn
        n lroot s lroot=$$setroot^%wd("patient-lists")
        n uselist s uselist="dhp-vista-1000-1"
        n listien s listien=$o(@lroot@("B",uselist,""))
        q:listien=""
        n listroot s listroot=$na(@lroot@(listien,"list","items"))
        n pid,purl
        i $g(start)="" s start=1
        i $g(end)="" s end=start
        n num
        f num=start:1:end d  
        . s pid=$g(@listroot@(num,"title"))
        . s purl=$g(@listroot@(num,"url"))
        . n filter
        . s filter("id")=pid
        . s filter("url")=purl
        . q:purl=""
        . d wsLoadPat(.rtn,.filter)
        q
        ;
loadpats(rtn,listien)   ;
        k rtn
        n lroot s lroot=$$setroot^%wd("patient-lists")
        n froot s froot=$$setroot^%wd("fhir-intake")
        q:listien=""
        n listroot s listroot=$na(@lroot@(listien,"list","items"))
        n pid,purl
        n num s num=0
        f  s num=$o(@listroot@(num)) q:+num=0  d  ;
        . s pid=$g(@listroot@(num,"title"))
        . s purl=$g(@listroot@(num,"url"))
        . n filter
        . s filter("id")=pid
        . s filter("url")=purl
        . q:purl=""
        . i $d(@froot@("B",pid)) d  q  ; already loaded
        . . w !,"patient already loaded: "_pid
        . w !,"loading patient "_pid
        . d wsLoadPat(.rtn,.filter)
        q
        ;
wsLoadPat(zrtn,zfilter) ; load one patient from a URL
        ; zfilter("url")=patienturl
        ; zfilter("id")=patientID
        ; returns same as wsPostFHIR^SYNFHIR
        ;
        s U="^"
        ;
        n ret,json,purl
        s purl=$g(zfilter("url"))
        q:purl=""
        i purl["synthea1m.vistaplex.org" d  ;
        . s purl="http://138.197.147.128"_$p(purl,"synthea1m.vistaplex.org",2)
        ;
        ;s ret=$$%^%WC(.json,"GET",purl)
        n jtmp
        s ret=$$GETURL^XTHC10(purl,,"jtmp")
        d assemble("jtmp","json")
        i +ret=-1 d  b
        . w !,ret," ",purl
        ;
        ;
        new ien,root,gr,id,return
        set root=$$setroot^%wd("fhir-intake")
        set id=$get(zfilter("id"))
        ;
        set ien=$order(@root@(" "),-1)+1
        set gr=$name(@root@(ien,"json"))
        do DECODE^VPRJSON("json",gr)
        do indexFhir^SYNFHIR(ien)
        W:ien#500=0 !,"Patient # "_ien_" "_$$FMTE^XLFDT($$NOW^XLFDT)
        ;
        if id'="" do  ;
        . set @root@("B",id,ien)=""
        else  do  ;
        . ;
        ;
        if $get(ARGS("returngraph"))=1 do  ;
        . merge return("graph")=@root@(ien,"graph")
        set return("status")="ok"
        set return("id")=id
        set return("ien")=ien
        ;
        do importPatient^SYNFPAT(.return,ien)
        ;
        new rdfn set rdfn=$get(return("dfn"))
        if rdfn'="" set @root@("DFN",rdfn,ien)=""
        ;
        if rdfn'="" do  ; patient creation was successful
        . if $g(ARGS("load"))="" s ARGS("load")=1
        . do importVitals^SYNFVIT(.return,ien,.ARGS)
        . ;do importEncounters^SYNFENC(.return,ien,.ARGS)
        . ;do importImmu^SYNFIMM(.return,ien,.ARGS)
        ;
        ;do ENCODE^VPRJSON("return","RESULT")
        ;do ENCODE^VPRJSON("return","zrtn")
        set HTTPRSP("mime")="application/json"
        ;
        quit
        ;
TEST1K  ; test loading first 1000 patients in the lists
        d getlol ; get the list of lists 
        n lstien ; ien in patient-lists that we will process
        n lname s lname="dhp-vista-1000-1" ; name of the first list
        s lstien=$$load1list(lname) ; load the first list and return the ien
        d loadpats(.return,lstien) ; load the patients from the first list
        q
        ;
LOADALL ; load all 50000 patients
        d getlol ; get the list of lists 
        n lstien ; ien in patient-lists that we will process
        n tlname s tlname="dhp-vista-1000-" ; template for the list names
        n ii
        f ii=1:1:50 d  ; for all 50 lists
        . s lname=tlname_ii ; name of the list
        . s lstien=$$load1list(lname) ; load the list and return the ien
        . d loadpats(.return,lstien) ; load the patients from the list
        q
        ;
CLEANGRAPH      ;
        ;
        n groot s groot=$$setroot^%wd("fhir-intake")
        n zi,zj,zk
        s (zi,zj,zk)=""
        f  s zi=$o(@groot@("B",zi)) q:zi=""  d  ;
        . s zj=$o(@groot@("B",zi,""))
        . s zk=$o(@groot@("B",zi,zj))
        . i zk'="" d  ; a duplicate
        . . i $$ien2dfn^SYNFUTL(zk)'="" q  ; has a VistA record
        . . w !,"removing ien: "_zk_" name: "_zi
        . . k @groot@(zk) ; clear the graph
        . . k @groot@("B",zi,zk) ; remove from the index
        q
        ;

SYNFUTL
SYNFUTL ;ven/gpl - fhir loader utilities ; 10/19/17 4:33pm
        ;;1.0;fhirloader;;oct 19, 2017;Build 2
        ;
        ; Authored by George P. Lilly 2017-2018
        ;
        q
        ;
initPLD(ien,element)    ; initializes the PLD pointers in the fhir graph
        new root set root=$$setroot^%wd("fhir-intake")
        set @root@(ien,"load",element,"PLD","parms")=$name(@root@(ien,"load",element,"parms"))
        set @root@(ien,"load",element,"PLD","log")=$name(@root@(ien,"load",element,"log"))
        set @root@(ien,"load",element,"PLD","verify")=$name(@root@(ien,"load",element,"verify"))
        set @root@(ien,"load",element,"PLD","status")=$name(@root@(ien,"load",element,"status"))
        set @root@(ien,"load",element,"PLD","index")=root
        quit
        ;
setPLD(ien,element)     ; extrinsic which returns the global name containing the PLD for this element
        new root set root=$$setroot^%wd("fhir-intake")
        if '$data(@root@(ien,"load",element,"PLD")) do initPLD(ien,element)
        quit $name(@root@(ien,"load","Patient","PLD"))
        ;
log(txt)        ; logs a line to the log array defined by PLD("log")
        if '$data(PLD("log")) do  quit  ;
        . w !,"Error log array not defined ",txt
        do addto(PLD("log"),txt)
        quit
        ;
addto(dest,string)      ; add string to list dest
        ; dest is passed by name
        new %ii
        set %ii=$order(@dest@("AAAAA"),-1)+1
        set @dest@(%ii)=string
        set @dest@(0)=%ii ; count
        quit
        ;
addArray(dest,array)    ; add array to list dest
        ; dest and array are passed by name
        new %ii
        set %ii=$order(@dest@("AAAAA"),-1)+1
        new %ij set %ij=0
        for  set %ij=$order(@array@(%ij)) quit:'%ij  do  ;
        . set @dest@(%ii)=$get(@array@(%ij))
        . set @dest@(0)=%ii ; count
        . set %ii=%ii+1
        quit
        ;
setIndex(sub,pred,obj)  ; set the graph indexices
        n gn s gn=$$setroot^%wd("fhir-intake")
        q:sub=""
        q:pred=""
        q:obj=""
        s @gn@("SPO",sub,pred,obj)=""
        s @gn@("POS",pred,obj,sub)=""
        s @gn@("PSO",pred,sub,obj)=""
        s @gn@("OPS",obj,pred,sub)=""
        q
        ;
clearIndexes    ; do this carefully
        n gn s gn=$$setroot^%wd("fhir-intake")
        k @gn@("SPO")
        k @gn@("POS")
        k @gn@("PSO")
        k @gn@("OPS")
        q
        ; 
fhirTfm(dtin)   ; extrinsic which returns the fileman dateTime 
        ; for the FHIR format input ie 2017-04-28T01:28:28-04:00
        n tdt
        s tdt=$tr(dtin,":")
        s tdt=$tr(tdt,"T")
        s tdt=$e(tdt,1,4)_$e(tdt,6,7)_$e(tdt,9,21)
        q $$HL7TFM^XLFDT(tdt)
        ;
fhirThl7(dtin)  ; extrinsic which returns the HL7 dateTime 
        ; for the FHIR format input ie 2017-04-28T01:28:28-04:00
        ; example hl7 returned: 20170428012828-0400
        n tdt
        s tdt=$tr(dtin,":")
        s tdt=$tr(tdt,"T")
        s tdt=$e(tdt,1,4)_$e(tdt,6,7)_$e(tdt,9,21)
        q tdt
        ;
ien2dfn(ien)    ; extrinsic returns the patient DFN given the graph ien
        n root s root=$$setroot^%wd("fhir-intake")
        q $o(@root@("PSO","DFN",ien,""))
        ;
dfn2ien(dfn)    ; extrinsic returns the graph ien given the DFN
        n root s root=$$setroot^%wd("fhir-intake")
        q $o(@root@("POS","DFN",dfn,""))
        ;
ien2icn(ien)    ; extrinsic returns the patient ICN given the graph ien
        n root s root=$$setroot^%wd("fhir-intake")
        q $o(@root@("PSO","ICN",ien,""))
        ;
icn2ien(icn)    ; extrinsic returns the graph ien given the DFN
        n root s root=$$setroot^%wd("fhir-intake")
        q $o(@root@("POS","ICN",icn,""))
        ;
dfn2icn(dfn)    ; extrinsic returns the ICN given the patient DFN
        n ien s ien=$$dfn2ien(dfn)
        q $$ien2icn(ien)
        ;
icn2dfn(icn)    ; extrinsic returns the DFN given the patient ICN
        n ien s ien=$$icn2ien(icn)
        q $$ien2dfn(ien)
        ;
urlEnd(zurl)    ; extrinsic which return the last part of a url 
        ; (the part after the final /
        q $re($p($re(zurl),"/",1))
        ;
testValueDex()  ; 
        ;new fhir
        do getIntakeFhir^SYNFHIR("testfhir",,"Patient",1)
        do valueDex("testfhir","value")
        ;zwrite fhir
        quit
        ;
valueDex(ary,indx)      ; creates index indx of values of the array
        ;
        new ind
        new fi s fi=$query(@ary@(""))
        ;new fi s fi=""
        set ind(indx,@fi)=fi
        for  set fi=$query(@fi) quit:fi=""  do  ;
        . ;w !,@fi," ",fi
        . if @fi="" quit
        . set ind(indx,@fi)=fi
        . ;write !,fi," ",@fi
        ;zwrite ind
        merge @ary=ind
        quit
        ;
valueDex2(ary,indx)     ; creates index indx of values of the array
        ; this one simplifies indx
        new ind
        new fi s fi=$query(@ary@(""))
        set ind(indx,@fi)=fi
        for  set fi=$query(@fi) quit:fi=""  do  ;
        . ;w !,@fi," ",fi
        . if @fi="" quit
        . set ind($qs(fi,$ql(fi)),@fi)=fi
        . ;write !,fi," ",@fi
        ;zwrite ind
        merge @indx=ind
        quit
        ;
testAdb()       ; test Array Defined By
        new fhir
        do getIntakeFhir^SYNFHIR("fhir",,"Patient",1)
        do adb("fhirrace","fhir","text","race")
        zwrite fhirrace
        ;
        ; expected results:
        ;d testAdb^SYNFUTL
        ;fhirrace("coding",1,"code")="2106-3"
        ;fhirrace("coding",1,"display")="White"
        ;fhirrace("coding",1,"system")="http://hl7.org/fhir/v3/Race"
        ;fhirrace("text")="race"
        ;
        quit
        ;
adb(rtn,ary,pred,obj)   ; returns the array defined by the predicate and object
        if '$d(@ary@("value")) do valueDex(ary,"value")
        new ref
        set ref=@ary@("value",obj) 
        if ref'[pred quit  ;
        do replace(.ref,","""_pred_"""","")
        ;w !,ref b
        merge @rtn=@ref
        quit
        ;
replace(ln,cur,repl)    ; replace current with replacment in line ln
        new where set where=$find(ln,cur)
        quit:where=0 ; this might not work for cur at the end of ln, please test
        set ln=$extract(ln,1,where-$length(cur)-1)_repl_$extract(ln,where,$length(ln))
        quit
        ;
        

SYNFVF
SYNFVF  ;ven/gpl - fhir loader utilities ; 2/20/18 4:11am
        ;;1.0;fhirloader;;Apr 15, 2018;Build 2
        ;
        ; Authored by George P. Lilly 2018
        ;
        q
        ;
        ; utilities to pull FHIR resources for VistA patients
        ;
vurl()  ; extrinsic returns the url for VistA get fhir
        q "https://vista-fhir-dev.openplatform.healthcare/api/Patient/"
        ;
wsIcnList(rtn,filter)   ; web service to return a list of ICNs for vista patients
        n dnfmin,dfnmax
        s dfnmin=$g(filter("dfnmin"))
        i dfnmin="" s dfnmin=$o(^DPT(0))
        s dfnmax=$g(filter("dfnmax"))
        i dfnmax="" s dfnmax=$o(^DPT("  "),-1)
        ;
        n tbl ; table of full ICNs sorted by dfn
        d sortAFICN(.tbl)
        ;
        n rtn1 ; json return before decode
        n zi s zi=+$o(tbl(dfnmin),-1)
        f  s zi=$o(tbl(zi)) q:+zi=0  q:zi>dfnmax  d  ;
        . n zj s zj=""
        . f  s zj=$o(tbl(zi,zj)) q:zj=""  d  ;
        . . s rtn1("return",zi,zj,"icn")=zj
        . . s rtn1("return",zi,zj,"dfn")=zi
        ;m rtn=rtn1
        d ENCODE^VPRJSON("rtn1","rtn")
        q
        ;
sortAFICN(ary)  ; sort the AFICN index by dfn
        n zii s zii=""
        f  s zii=$o(^DPT("AFICN",zii)) q:+zii=0  d  ;
        . n zdfn
        . s zdfn=$o(^DPT("AFICN",zii,""))
        . s ary(zdfn,zii)=""
        q
        ;
getVehuIcns     ; get the Dev VEHU ICNs and stores them in a graph
        n gn,root
        d purgegraph^%wd("vehu-icns")
        s root=$$setroot^%wd("vehu-icns")
        s gn="http://wip.vistaplex.org:9080/icnlist?dfnmax=100000"
        s ok=$$%^%WC(.g,"GET",gn)
        d DECODE^VPRJSON("g","g2")
        ;
        n zi,zj s (zi,zj)=""
        f  s zi=$o(g2("return",zi)) q:zi=""  d  ;
        . f  s zj=$o(g2("return",zi,zj)) q:zj=""  d  ;
        . . s @root@(zi,zj)=""
        . . s @root@("ICN",zj,zi)=""
        ;
        q
        ;
getAllergies    ; get VEHU allergies fhir resources
        ;
        n icnroot s icnroot=$$setroot^%wd("vehu-icns")
        ;
        d purgegraph^%wd("fhir-vista-AllergyIntolerance")
        n zicn s zicn=""
        f  s zicn=$o(@icnroot@("ICN",zicn)) q:zicn=""  d  ;
        . n domain,entries
        . s domain="AllergyIntolerance"
        . d getDomain("entries",domain,zicn)
        . i '$d(entries) q  ;
        . s entries("ICN")=zicn
        . s entries("DFN")=$o(@icnroot@("ICN",zicn,""))
        . s zien=$$storeGraph("entries","fhir-vista-"_domain,zicn)
        q
        ;
getAppointments ; get VEHU appointment fhir resources
        ;
        n icnroot s icnroot=$$setroot^%wd("vehu-icns")
        ;
        d purgegraph^%wd("fhir-vista-Appointment")
        n zicn s zicn=""
        f  s zicn=$o(@icnroot@("ICN",zicn)) q:zicn=""  d  ;
        . n domain,entries
        . s domain="Appointment"
        . d getDomain("entries",domain,zicn)
        . i '$d(entries) q  ;
        . s entries("ICN")=zicn
        . s entries("DFN")=$o(@icnroot@("ICN",zicn,""))
        . s zien=$$storeGraph("entries","fhir-vista-"_domain,zicn)
        q
        ;
getProcedures   ; get VEHU procedure fhir resources
        ;
        n icnroot s icnroot=$$setroot^%wd("vehu-icns")
        ;
        d purgegraph^%wd("fhir-vista-Procedure")
        n zicn s zicn=""
        f  s zicn=$o(@icnroot@("ICN",zicn)) q:zicn=""  d  ;
        . n domain,entries
        . s domain="Procedure"
        . d getDomain("entries",domain,zicn)
        . i '$d(entries) q  ;
        . s entries("ICN")=zicn
        . s entries("DFN")=$o(@icnroot@("ICN",zicn,""))
        . s zien=$$storeGraph("entries","fhir-vista-"_domain,zicn)
        q
        ;
getDomain(rtn,domain,icn)       ; pull domain entries for VistA patient ICN
        n gn2
        s gn2="https://vista-fhir-dev.openplatform.healthcare/api/Patient/"
        ;
        n url,fhir,r1
        s url=gn2_icn_"/"_domain
        s ok=$$%^%WC(.fhir,"GET",url)
        d DECODE^VPRJSON("fhir","r1")
        m @rtn@("entry")=r1("entry")
        ;
        q
        ;
storeGraph(ary,graph,id)        ; stores an array ary, passed by name
        ; into graphname graph with B index id
        ; extrinsic, returns the ien
        ;
        i graph="" s graph="misc"
        n root set root=$$setroot^%wd(graph)
        ;
        n ien,rien
        s ien=$o(@root@(" "),-1)+1
        ;
        m @root@(ien)=@ary
        ;
        s @root@("B",id,ien)=""
        ;
        q ien
        ;
wsGetAllergy(rtn,filter)        ; web service to pull a random allergy from 
        ; graph fhir-vista-Allergy
        ;
        n root s root=$$setroot^%wd("fhir-vista-AllergyIntolerance")
        n max
        s max=$o(@root@(" "),-1)
        i +max=0 q  ; nothing to pull
        n ien s ien=$r(max)
        i '$d(@root@(ien)) s ien=$r(max)
        n r1
        s r1=$na(@root@(ien))
        i $g(filter("format"))="mumps" d  q  ;
        . m rtn=@r1
        d ENCODE^VPRJSON(r1,"rtn")
        q
        ; 
wsGetAppointment(rtn,filter)    ; web service to pull a random appointments from 
        ; graph fhir-vista-Appointment
        ;
        n root s root=$$setroot^%wd("fhir-vista-Appointment")
        n max
        s max=$o(@root@(" "),-1)
        i +max=0 q  ; nothing to pull
        n ien s ien=$r(max)
        i '$d(@root@(ien)) s ien=$r(max)
        n r1
        s r1=$na(@root@(ien))
        i $g(filter("format"))="mumps" d  q  ;
        . m rtn=@r1
        d ENCODE^VPRJSON(r1,"rtn")
        q
        ; 
wsGetProcedure(rtn,filter)      ; web service to pull a random procedure from 
        ; graph fhir-vista-Procedure
        ;
        n root s root=$$setroot^%wd("fhir-vista-Procedure")
        n max
        s max=$o(@root@(" "),-1)
        i +max=0 q  ; nothing to pull
        n ien s ien=$r(max)
        i '$d(@root@(ien)) s ien=$r(max)
        n r1
        s r1=$na(@root@(ien))
        i $g(filter("format"))="mumps" d  q  ;
        . m rtn=@r1
        d ENCODE^VPRJSON(r1,"rtn")
        q
        ; 

SYNFVIT
SYNFVIT ;ven/gpl - fhir loader utilities ;2018-05-08  4:23 PM
 ;;1.0;fhirloader;;oct 19, 2017;Build 2
 ;
 ; Authored by George P. Lilly 2017-2018
 ;
 q
 ;
importVitals(rtn,ien,args) ; entry point for loading vitals for a patient
 ; calls the intake Vitals web service directly
 ;
 n grtn
 n root s root=$$setroot^%wd("fhir-intake")
 n % s %=$$wsIntakeVitals(.args,,.grtn,ien)
 i $d(grtn) d  ; something was returned
 . k @root@(ien,"load","vitals")
 . m @root@(ien,"load","vitals")=grtn("vitals")
 . if $g(args("debug"))=1 m rtn=grtn
 s rtn("vitalsStatus","status")=$g(grtn("status","status"))
 s rtn("vitalsStatus","loaded")=$g(grtn("status","loaded"))
 s rtn("vitalsStatus","errors")=$g(grtn("status","errors"))
 ;b
 ;
 ;
 q
 ;
wsIntakeVitals(args,body,result,ien) ; web service entry (post)
 ; for intake of one or more Vital signs. input are fhir resources
 ; result is json and summarizes what was done
 ; args include patientId
 ; ien is specified for internal calls, where the json is already in a graph
 n jtmp,json,jrslt,eval
 ;i $g(ien)'="" if $$loadStatus("vitals","",ien)=1 d  q  ;
 ;. s result("vitalsStatus","status")="alreadyLoaded"
 i $g(ien)'="" d  ; internal call
 . d getIntakeFhir^SYNFHIR("json",,"Observation",ien,1)
 e  d  ; 
 . ;s args("load")=0
 . merge jtmp=BODY
 . do DECODE^VPRJSON("jtmp","json")
 i '$d(json) q 0  ;
 m ^gpl("gjson")=json
 ;
 ; determine the patient
 ;
 n dfn,eval
 if $g(ien)'="" d  ;
 . s dfn=$$ien2dfn^SYNFUTL(ien) ; look up dfn in the graph
 else  d  ;
 . s dfn=$g(args("dfn"))
 . i dfn="" d  ;
 . . n icn s icn=$g(args("icn"))
 . . i icn'="" s dfn=$$icn2dfn^SYNFUTL(icn)
 i $g(dfn)="" do  quit 0  ; need the patient
 . s result("vitals",1,"log",1)="Error, patient not found.. terminating"
 ;
 ;
 new zi s zi=0
 for  set zi=$order(json("entry",zi)) quit:+zi=0  do  ;
 . ;
 . ; define a place to log the processing of this entry
 . ;
 . new jlog set jlog=$name(eval("vitals",zi))
 . ;
 . ; insure that the resourceType is Observation
 . ;
 . new type set type=$get(json("entry",zi,"resource","resourceType"))
 . if type'="Observation" do  quit  ;
 . . set eval("vitals",zi,"vars","resourceType")=type
 . . do log(jlog,"Resource type not Observation, skipping entry")
 . set eval("vitals",zi,"vars","resourceType")=type
 . ;
 . ; determine the Observation category and quit if not vital-signs
 . ;
 . new obstype set obstype=$get(json("entry",zi,"resource","category",1,"coding",1,"code"))
 . if obstype="" do  ; category is missing, try mapping the code
 . . new trycode,trydisp,tryy 
 . . set trycode=$g(json("entry",zi,"resource","code","coding",1,"code"))
 . . set trydisp=$g(json("entry",zi,"resource","code","coding",1,"display"))
 . . s tryy=$$loinc2sct(trycode)
 . . if tryy="" d  quit  ;
 . . . d log(jlog,"Observation Category missing, not vital signs; code is: "_trycode_" "_trydisp)
 . . if tryy'="" set obstype="vital-signs"
 . . d log(jlog,"Derived category is "_obstype)
 . ;
 . if obstype'="vital-signs" do  quit  ;
 . . set eval("vitals",zi,"vars","observationCategory")=obstype
 . . do log(jlog,"Observation Category is not vital-signs, skipping")
 . set eval("vitals",zi,"vars","observationCategory")=obstype
 . ;
 . ; see if this resource has already been loaded. if so, skip it
 . ;
 . if $g(ien)'="" if $$loadStatus("vitals",zi,ien)=1 do  quit  ;
 . . d log(jlog,"Vital sign already loaded, skipping")
 . ;
 . ; determine Vitals type, code, coding system, and display text
 . ;
 . new vittype set vittype=$get(json("entry",zi,"resource","code","text"))
 . if vittype="" set vittype=$get(json("entry",zi,"resource","code","coding",1,"display"))
 . do log(jlog,"Vitals type is: "_vittype)
 . set eval("vitals",zi,"vars","type")=vittype
 . ;
 . ; determine the id of the resource
 . ;
 . new id set id=$get(json("entry",zi,"resource","id"))
 . set eval("vitals",zi,"vars","id")=id
 . d log(jlog,"ID is: "_id)
 . ;
 . new obscode set obscode=$get(json("entry",zi,"resource","code","coding",1,"code"))
 . do log(jlog,"code is: "_obscode)
 . set eval("vitals",zi,"vars","code")=obscode
 . ;
 . s ^gpl("vitals",obscode,vittype)=""
 . ; here's what we got so far:
 . ;^gpl("vitals","29463-7","Body Weight")=""
 . ;^gpl("vitals","39156-5","Body Mass Index")=""
 . ;^gpl("vitals","55284-4","Blood Pressure")=""
 . ;^gpl("vitals","8302-2","Body Height")=""
 . ;^gpl("vitals","8331-1","Oral temperature")=""
 . ;
 . new codesystem set codesystem=$get(json("entry",zi,"resource","code","coding",1,"system"))
 . do log(jlog,"code system is: "_codesystem)
 . set eval("vitals",zi,"vars","codeSystem")=codesystem
 . ;
 . ; determine the value and units
 . ;
 . new value set value=$get(json("entry",zi,"resource","valueQuantity","value"))
 . do log(jlog,"value is: "_value)
 . set eval("vitals",zi,"vars","value")=value
 . ;
 . new unit set unit=$get(json("entry",zi,"resource","valueQuantity","unit"))
 . do log(jlog,"units are: "_unit)
 . set eval("vitals",zi,"vars","units")=unit
 . ;
 . ; fix blood preasure readings (combine two readings to one)
 . ;
 . if obscode="55284-4" do  ; Blood Pressure
 . . new tmpjson,systolic,diastolic,combined
 . . merge tmpjson=json("entry",zi)
 . . d log(jlog,"Combining Blood Pressure values")
 . . n tn s tn=$na(tmpjson("resource","component"))
 . . n tx
 . . f tx=1,2  d  ;
 . . . if $g(@tn@(tx,"code","coding",1,"code"))="8480-6" d  ; Systolic Blood Pressure
 . . . . s systolic("units")=$g(@tn@(tx,"valueQuantity","unit"))
 . . . . s unit=systolic("units")
 . . . . s systolic("value")=$g(@tn@(tx,"valueQuantity","value"))
 . . . . s value=systolic("value")
 . . . . d log(jlog,("Systolic value is: "_systolic("value")))
 . . . if $g(@tn@(tx,"code","coding",1,"code"))="8462-4" d  ; Diastolic Blood Pressure
 . . . . s diastolic("units")=$g(@tn@(tx,"valueQuantity","unit"))
 . . . . s unit=diastolic("units")
 . . . . s diastolic("value")=$g(@tn@(tx,"valueQuantity","value"))
 . . . . s value=diastolic("value")
 . . . . d log(jlog,("Diastolic value is: "_diastolic("value")))
 . . s combined=$g(systolic("value"))_"/"_$g(diastolic("value"))
 . . s value=combined
 . . d log(jlog,"Combined Blood Pressure value is: "_combined)
 . . set eval("vitals",zi,"vars","value")=combined
 . . set eval("vitals",zi,"vars","units")=$g(diastolic("units"))
 . . d log(jlog,"Blood Pressure units are: "_$g(diastolic("units")))
 . . ;b
 . ;
 . ; determine the effective date
 . ;
 . new effdate set effdate=$get(json("entry",zi,"resource","effectiveDateTime"))
 . do log(jlog,"effectiveDateTime is: "_effdate)
 . set eval("vitals",zi,"vars","effectiveDateTime")=effdate
 . new fmtime s fmtime=$$fhirTfm^SYNFUTL(effdate)
 . d log(jlog,"fileman dateTime is: "_fmtime)
 . set eval("vitals",zi,"vars","fmDateTime")=fmtime ;
 . new hl7time s hl7time=$$fhirThl7^SYNFUTL(effdate)
 . d log(jlog,"hl7 dateTime is: "_hl7time)
 . set eval("vitals",zi,"vars","hl7DateTime")=hl7time ;
 . ;
 . ; set up to call the data loader
 . ;
 . n RETSTA,DHPPAT,DHPSCT,DHPOBS,DHPUNT,DHPDTM,DHPPROV,DHPLOC
 . ;
 . s DHPPAT=$$dfn2icn^SYNFUTL(dfn)
 . s eval("vitals",zi,"parms","DHPPAT")=DHPPAT
 . ;
 . n sct s sct=$$loinc2sct(obscode) ; find the snomed code
 . i sct="" d  quit
 . . d log(jlog,"Snomed Code not found for vitals code: "_obscode_" -- skipping")
 . . s eval("vitals",zi,"status","loadstatus")="cannotLoad"
 . . s eval("vitals",zi,"status","issue")="Snomed Code not found for vitals code: "_obscode_" -- skipping"
 . . s eval("status","errors")=$g(eval("status","errors"))+1
 . s eval("vitals",zi,"parms","DHPSCT")=sct
 . d log(jlog,"Snomed Code is: "_sct)
 . s DHPSCT=sct
 . ;
 . s DHPOBS=value
 . s eval("vitals",zi,"parms","DHPOBS")=value
 . d log(jlog,"Value is: "_value)
 . ;
 . s DHPUNT=unit
 . s eval("vitals",zi,"parms","DHPUNT")=unit
 . d log(jlog,"Units are: "_unit)
 . ;
 . s DHPDTM=hl7time
 . s eval("vitals",zi,"parms","DHPDTM")=hl7time
 . d log(jlog,"HL7 DateTime is: "_hl7time)
 . ;
 . s DHPPROV=$$MAP^SYNQLDM("OP","provider")
 . n DHPPROVIEN s DHPPROVIEN=$o(^VA(200,"B",DHPPROV,""))
 . if DHPPROVIEN="" S DHPPROVIEN=3
 . s eval("vitals",zi,"parms","DHPPROV")=DHPPROVIEN
 . d log(jlog,"Provider for outpatient is: #"_DHPPROVIEN_" "_DHPPROV)
 . ;
 . s DHPLOC=$$MAP^SYNQLDM("OP","location")
 . n DHPLOCIEN s DHPLOCIEN=$o(^SC("B",DHPLOC,""))
 . if DHPLOCIEN="" S DHPLOCIEN=4
 . s eval("vitals",zi,"parms","DHPLOC")=DHPLOCIEN
 . d log(jlog,"Location for outpatient is: #"_DHPLOCIEN_" "_DHPLOC)
 . ;
 . s eval("vitals",zi,"status","loadstatus")="readyToLoad"
 . ;
 . if $g(args("load"))=1 d  ; only load if told to
 . . if $g(ien)'="" if $$loadStatus("vitals",zi,ien)=1 do  quit  ;
 . . . d log(jlog,"Vital sign already loaded, skipping")
 . . d log(jlog,"Calling VITUPD^SYNDHP61 to add vital")
 . . D VITUPD^SYNDHP61(.RETSTA,DHPPAT,DHPSCT,DHPOBS,DHPUNT,DHPDTM,DHPPROV,DHPLOC)       ; vitals update
 . . d log(jlog,"Return from VITUPD^ZZDHP61 was: "_$g(RETSTA))
 . . if +$g(RETSTA)=1 do  ;
 . . . s eval("status","loaded")=$g(eval("status","loaded"))+1
 . . . s eval("vitals",zi,"status","loadstatus")="loaded"
 . . else  s eval("status","errors")=$g(eval("status","errors"))+1
 ;
 if $get(args("debug"))=1 do  ;
 . m jrslt("source")=json
 . m jrslt("args")=args
 . m jrslt("eval")=eval
 m jrslt("vitalsStatus")=eval("vitalsStatus")
 set jrslt("result","status")="ok"
 set jrslt("result","loaded")=$g(eval("status","loaded"))
 i $g(ien)'="" d  ; called internally
 . m result=eval
 . m result("status")=jrslt("result")
 . ;b
 e  d  ;
 . d ENCODE^VPRJSON("jrslt","result")
 . set HTTPRSP("mime")="application/json" 
 q 1
 ;
log(ary,txt) ; adds a text line to @ary@("log")
 s @ary@("log",$o(@ary@("log",""),-1)+1)=$g(txt)
 q
 ;
loadStatus(typ,zx,zien) ; extrinsic return 1 if resource was loaded
 n root s root=$$setroot^%wd("fhir-intake")
 n rt s rt=0
 i $g(zx)="" i $d(@root@(zien,"load",typ)) s rt=1 q rt
 i $get(@root@(zien,"load",typ,zx,"status","loadstatus"))="loaded" s rt=1
 q rt
loinc2sct(loinc) ; extrinsic returns a Snomed code for a Loinc code
 ; for vitals
 ; thanks to Ferdi for the Snomed mapping
 ;
 ; here's what we got so far:
 ;^gpl("vitals","29463-7","Body Weight")=""
 ;^gpl("vitals","39156-5","Body Mass Index")="" ; oops
 ;^gpl("vitals","55284-4","Blood Pressure")=""
 ;^gpl("vitals","8302-2","Body Height")=""
 ;^gpl("vitals","8331-1","Oral temperature")="" ;
 ;
 S SCTA("29463-7",27113001)="9^Body weight"
 S SCTA("8302-2",50373000)="8^Body height"
 S SCTA("55284-4",75367002)="1^Blood pressure"
 S SCTA(78564009)="5^Pulse rate"
 S SCTA("8331-1",386725007)="2^Body Temperature"
 S SCTA(86290005)="3^Respiration"
 S SCTA(48094003)="10^Abdominal girth measurement"
 S SCTA(21727005)="11^Audiometry"
 S SCTA(252465000)="21^Pulse oximetry"
 S SCTA(22253000)="22^Pain"
 ;
 q $o(SCTA(loinc,""))
 ;
testall ; run the vitals import on all imported patients
 new root s root=$$setroot^%wd("fhir-intake")
 new indx s indx=$na(@root@("POS","DFN"))
 n dfn,ien,filter,reslt
 s dfn=0
 f  s dfn=$o(@indx@(dfn)) q:+dfn=0  d  ;
 . s ien=$o(@indx@(dfn,""))
 . q:ien=""
 . s filter("dfn")=dfn
 . k reslt
 . d wsIntakeVitals(.filter,,.reslt,ien)
 q
 ;

SYNQLDM
SYNQLDM ; GPL - QRDA loader entry routines ; 2/19/18 6:02am
        ;;0.1;QRDA LOADER;nopatch;noreleasedate;Build 2
        ;
        ; Authored by George P. Lilly 2016-2018
        ;
        Q
        ;
INITMAPS        ; initialize maps 
        N G
        S G=$NA(^XTMP("SYNQLD","MAPS"))
        K @G
        N MAP
        ; SOP (payment?)
        S MAP="SOP"
        S @G@(MAP,"CODE","394","OTHER")=""
        ; race
        S MAP="race"
        S @G@(MAP,"CODE","1002-5","AMERICAN INDIAN OR ALASKA NATI")=""
        S @G@(MAP,"CODE","2028-9","ASIAN")=""
        S @G@(MAP,"CODE","2054-5","BLACK OR AFRICAN AMERICAN")=""
        S @G@(MAP,"CODE","2076-8","NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER")=""
        S @G@(MAP,"CODE","2106-3","WHITE")=""
        S @G@(MAP,"CODE","213101","DECLINED TO SPECIFY")=""
        S @G@(MAP,"CODE","9999-4","UNKNOWN BY PATIENT")=""
        ; ethnicity
        S MAP="ethnicity"
        S @G@(MAP,"CODE","21350-2","HISPANIC OR LATINO")=""
        S @G@(MAP,"CODE","2186-5","NOT HISPANIC OR LATINO")=""
        S @G@(MAP,"CODE","213101","DECLINED TO ANSWER")=""
        ; Health Factors - SNOMED
        S MAP="HF"
        S @G@(MAP,"CODE","4525004","ED [ARRIVAL-DEPARTURE] TIME")=""
        S @G@(MAP,"CODE","1748006","VTE COMFIRMED")=""
        S @G@(MAP,"CODE","10378005","TIME DECISION TO ADMIT MADE")=""
        S @G@(MAP,"CODE","225337009","SUICIDE RISK ASSESSMENT")=""
        S @G@(MAP,"CODE","428191000124101","DOCUMENTATION OF CURRENT MEDS")=""
        S @G@(MAP,"CODE","371530004","CLINICAL CONSULTATION REPORT")=""
        S @G@(MAP,"CODE","428171000124102","ADOLESCENT DEPRESSION SCREEN NEGATIVE")=""
        S @G@(MAP,"CODE","428231000124106","MATERNAL POSTPARTUM DEPRESSION CARE")=""
        S @G@(MAP,"CODE","428341000124108","MACULAR EDEMA ABSENT")=""
        S @G@(MAP,"CODE","193350004","MACULAR EDEMA PRESENT")=""
        S @G@(MAP,"CODE","417886001","TREATMENT ADJUSTED PER PROTOCOL")=""
        S @G@(MAP,"CODE","105480006","WRITTEN INFORMATION NOT GIVEN")=""
        S @G@(MAP,"CODE","413318004","WRITTEN INFORMATION GIVEN")=""
        S @G@(MAP,"CODE","226789007","BREAST MILK ADMINISTERED")=""
        S @G@(MAP,"CODE","105480006","PATIENT REFUSED TREATMENT")=""
        S @G@(MAP,"CODE","428171000124102","ADULT DEPRESSION SCREEN")=""
        S @G@(MAP,"CODE","183932001","PROCEDURE CONTRAINDICATED")=""
        ; Health Factors - LOINC
        S @G@(MAP,"CODE","38208-5","STANDARD PAIN ASSMNT TOOL")=""
        S @G@(MAP,"CODE","44249-1","PHQ-9 RESULT")=""
        S @G@(MAP,"CODE","71955-9","PROMIS-29: ")=""
        S @G@(MAP,"CODE","71938-5","MLHFQ")=""
        S @G@(MAP,"CODE","71955-9","PROMIS-29")=""
        S @G@(MAP,"CODE","58151-2","BIMS SCORE")=""
        S @G@(MAP,"CODE","73830-2","FALL RISK ASSESSMENT")=""
        S @G@(MAP,"CODE","73831-0","ADOLESCENT DEPRESSION SCREEN")=""
        S @G@(MAP,"CODE","73832-8","ADULT DEPRESSION SCREEN")=""
        S @G@(MAP,"CODE","69981-9","ASTHMA ACTION PLAN")=""
        ; Encounters - SNOMED
        S MAP="encounters"
        ;S @G@(MAP,"CODE","183452005","IP")=""
        S @G@(MAP,"CODE","185349003","OP")=""
        ;S @G@(MAP,"CODE","4525004","ER")=""
        ;S @G@(MAP,"CODE","10197000","PS")=""
        ;S @G@(MAP,"CODE","10378005","IP")=""
        S @G@(MAP,"CODE","108313002","OP")=""
        ;S @G@(MAP,"CODE","171047005","IO")=""
        ;S @G@(MAP,"CODE","32485007","IP")=""
        ;S @G@(MAP,"CODE","305351004","ICU")=""
        ;S @G@(MAP,"CODE","112689000","IP")=""
        ;S @G@(MAP,"CODE","8715000","IP")=""
        ; Encounters - CPT
        S @G@(MAP,"CODE","92002","OP")=""
        ;S @G@(MAP,"CODE","96150","PS")=""
        S @G@(MAP,"CODE","99201","OP")=""
        ;S @G@(MAP,"CODE","99285","ER")=""
        ;S @G@(MAP,"CODE","90791","PS")=""
        S @G@(MAP,"CODE","99202","OP")=""
        ;S @G@(MAP,"CODE","99285","ER")=""
        S @G@(MAP,"CODE","99381","OP")=""
        ; location
        S MAP="location"
        ;S @G@(MAP,"CODE","OP","CLINIC A")=""
        ;S @G@(MAP,"CODE","OP","VISTA HEALTH CARE")=""
        S @G@(MAP,"CODE","OP","GENERAL MEDICINE")=""
        S @G@(MAP,"CODE","ER","EMERGENCY DEPT")=""
        S @G@(MAP,"CODE","IP","CERT MED SURG")=""
        S @G@(MAP,"CODE","ICU","CERT ICU")=""
        S @G@(MAP,"CODE","PS","CLINIC A")=""
        ; roombed
        S MAP="roombed"
        S @G@(MAP,"CODE","IP","M1-A")=""
        S @G@(MAP,"CODE","ICU","1-A")=""
        S @G@(MAP,"CODE","PS","CLINIC PSYCHIATRY")=""
        ; provider
        S MAP="provider"
        ;S @G@(MAP,"CODE","OP","CQM,HISTORICAL MD")=""
        ;S @G@(MAP,"CODE","OP","USER,THREE")=""
        S @G@(MAP,"CODE","OP","9990000348")=""
        S @G@(MAP,"CODE","ER","CQM,HISTORICAL MD")=""
        S @G@(MAP,"CODE","IP","CQM,HISTORICAL MD")=""
        S @G@(MAP,"CODE","ICU","CQM,HISTORICAL MD")=""
        S @G@(MAP,"CODE","PS","CQM,HISTORICAL MD")=""
        ; admitting regulation
        S MAP="regs"
        S @G@(MAP,"CODE","IP","OBSERVATION (AND) EXAMINATION")=""
        S @G@(MAP,"CODE","ICU","OBSERVATION (AND) EXAMINATION")=""
        ; facility treating speciality
        S MAP="facilityTreatingSpeciality"
        S @G@(MAP,"CODE","IP","MEDICAL OBSERVATION")=""
        S @G@(MAP,"CODE","ICU","MEDICAL OBSERVATION")=""
        ; discharge type
        S MAP="dischargeType"
        S @G@(MAP,"CODE","10161009","DISCHARGE TO HOME OR POLICE CU")=""
        ; vitals
        S MAP="vitals"
        S @G@(MAP,"CODE","8462-4","BLOOD PRESSURE")=""
        S @G@(MAP,"CODE","8480-6","BLOOD PRESSURE")=""
        S @G@(MAP,"CODE","39156-5","BMI")=""
        ; VPatientEd
        S MAP="vPatientEd"
        S @G@(MAP,"CODE","11816003","DIET EDUCATION")=""
        S @G@(MAP,"CODE","171047005","DRUGS OF ADDICTION EDUCATION")=""
        ; consults
        S MAP="consults"
        S @G@(MAP,"CODE","103697008","DENTAL")=""
        S @G@(MAP,"CODE","171047005","PHYSICAL REHAB")=""
        ; rad orders - LOINC
        S MAP="rad"
        S @G@(MAP,"CODE","24533-2","ABDOMINAL VESSELS MRI ANGIOGRAM W/CON  IV")=""
        S @G@(MAP,"CODE","24604-1","BREAST MAMMOGRAM DIAGNOSTIC LIMITED")=""
        S @G@(MAP,"CODE","25031-6","BONE SCAN")=""
        S @G@(MAP,"CODE","24665-2","SACRUM AND COCCYX X-RAY")=""
        ; rad orders - SNOMED
        S @G@(MAP,"CODE","113094008","DIAGNOSTIC RADIOGRAPHY OF CHEST, LATERAL")=""
        S @G@(MAP,"CODE","168731009","CHEST XRAY")=""
        S @G@(MAP,"CODE","1748006","VTE Confirmed.")=""
        ; immunizations - CVX
        S MAP="immunizations"
        S @G@(MAP,"CODE","3","MEASLES,MUMPS,RUBELLA (MMR)")=""
        S @G@(MAP,"CODE","8","HEPATITIS B")=""
        S @G@(MAP,"CODE","10","POLIOMYELITIS")=""
        S @G@(MAP,"CODE","20","DIP-TET-a/PERT")=""
        S @G@(MAP,"CODE","21","VARICELLA")=""
        S @G@(MAP,"CODE","33","PNEUMOCOCCAL CONJUGATE PCV23")=""
        S @G@(MAP,"CODE","48","HIB,PRP-T")=""
        S @G@(MAP,"CODE","83","HEPA,PED/ADOL-2")=""
        S @G@(MAP,"CODE","104","HEPA/HEPB ADULT")=""
        S @G@(MAP,"CODE","111","FLU,NASAL")=""
        S @G@(MAP,"CODE","116","ROTOVIRUS,ORAL")=""
        S @G@(MAP,"CODE","140","INFLUENZA")=""
        ; immunizations - SNOMED
        S @G@(MAP,"CODE","442333005","INFLUENZA")=""
        ; VExam LOINC
        S MAP="vExam"
        S @G@(MAP,"CODE","24604-1","MAMMOGRAM")=""
        S @G@(MAP,"CODE","32451-7","MACULAR EXAM")=""
        S @G@(MAP,"CODE","44249-1","PHQ-9 RESULT")=""
        S @G@(MAP,"CODE","54108-6","NEONATAL HEARING EXAM")=""
        S @G@(MAP,"CODE","54109-4","NEONATAL HEARING EXAM")=""
        S @G@(MAP,"CODE","57254-5","FALL RISK ASSESSMENT")=""
        S @G@(MAP,"CODE","58151-2","BIMS SCORE")=""
        S @G@(MAP,"CODE","65853-4","CARDIOVASCULAR RISK")=""
        S @G@(MAP,"CODE","71484-0","CUP TO DISK RATIO EXAM")=""
        S @G@(MAP,"CODE","71486-5","OPTIC DISK EXAM")=""
        S @G@(MAP,"CODE","71938-5","MLHFQ")=""
        S @G@(MAP,"CODE","71955-9","PROMIS-29:")=""
        S @G@(MAP,"CODE","73831-0","ADOLESCENT DEPRESSION SCREEN NEGATIVE")=""
        ; VExam - SNOMED
        S @G@(MAP,"CODE","225337009","SUICIDE RISK ASSESSMENT")=""
        S @G@(MAP,"CODE","91161007","PULSE FOOT EXAM")=""
        S @G@(MAP,"CODE","134388005","DIABETIC FOOT EXAM")=""
        S @G@(MAP,"CODE","252779009","DILATED EYE EXAM")=""
        S @G@(MAP,"CODE","401191002","DIABETIC FOOT CHECK")=""
        S @G@(MAP,"CODE","419775003","VISION EXAM")=""
        S @G@(MAP,"CODE","412726003","LENGTH OF GESTATION AT BIRTH")=""
        S @G@(MAP,"CODE","44413500","ESTIMATED FETAL GESTATIONAL AGE")=""
        S @G@(MAP,"CODE","417491009","NEONATAL HEARING EXAM")=""
        ; VCPT - CPT
        S MAP="vCPT"
        S @G@(MAP,"CODE","99201","OP")=""
        S @G@(MAP,"CODE","90791","PS")=""
        S @G@(MAP,"CODE","99202","OP")=""
        S @G@(MAP,"CODE","99381","OP")=""
        ; VCPT - SNOMED
        S MAP="sct2cpt"
        S @G@(MAP,"CODE","394701000","99241")=""
        S @G@(MAP,"CODE","371883000","99201")=""
        S @G@(MAP,"CODE","185347001","99201")=""
        S @G@(MAP,"CODE","183478001","99381")=""
        S @G@(MAP,"CODE","308646001","99238")=""
        S @G@(MAP,"CODE","424441002","59426")=""
        S @G@(MAP,"CODE","183460006","99218")=""
        S @G@(MAP,"CODE","698314001","99241")=""
        S @G@(MAP,"CODE","424619006","59425")=""
        S @G@(MAP,"CODE","50849002","99281")=""
        S @G@(MAP,"CODE","185345009","99213")=""
        S @G@(MAP,"CODE","170258001","99383")=""
        S @G@(MAP,"CODE","10492003","55810")=""
        S @G@(MAP,"CODE","84755001","77427")=""
        S @G@(MAP,"CODE","234723000","D1206")=""
        S @G@(MAP,"CODE","10745001","59400")=""
        S @G@(MAP,"CODE","10178000","66840")=""
        S @G@(MAP,"CODE","105355005","99408")=""
        S @G@(MAP,"CODE","12350003","44388")=""
        S @G@(MAP,"CODE","15163009","27130")=""
        S @G@(MAP,"CODE","177184002","59409")=""
        S @G@(MAP,"CODE","179344006","27447")=""
        S @G@(MAP,"CODE","13767004","65235")=""
        S @G@(MAP,"CODE","108241001","90937")=""
        S @G@(MAP,"CODE","185349003","99202")=""
        S @G@(MAP,"CODE","442333005","90653")=""
        S @G@(MAP,"CODE","444783004","45378")=""
        S @G@(MAP,"CODE","4525004","99285")=""
        S @G@(MAP,"CODE","185349003","99381")=""
        ; labs
        S MAP="labs"
        S @G@(MAP,"CODE","2085-9","HDL CHOLESTEROL")=""
        S @G@(MAP,"CODE","34714-6","PT/INR")=""
        S @G@(MAP,"CODE","2093-3","CHOLESTEROL, TOTAL")=""
        S @G@(MAP,"CODE","12773-8","LDL CHOLESTEROL")=""
        S @G@(MAP,"CODE","13457-7","LDL CHOLESTEROL")=""
        S @G@(MAP,"CODE","13056-7","PLATELET COUNT")=""
        S @G@(MAP,"CODE","10524-7","PAP TEST")=""
        S @G@(MAP,"CODE","17856-6","HEMOGLOBIN A1C")=""
        S @G@(MAP,"CODE","17855-8","HEMOGLOBIN A1C")=""
        S @G@(MAP,"CODE","10508-0","PSA")=""
        S @G@(MAP,"CODE","10351-5","HIV 1 RNA")=""
        S @G@(MAP,"CODE","35266-6","GLEASON SCORE")=""
        S @G@(MAP,"CODE","24467-3","CD4 COUNT")=""
        S @G@(MAP,"CODE","20447-9","HIV 1 RNA")=""
        S @G@(MAP,"CODE","19080-1","PREGNANCY TEST")=""
        S @G@(MAP,"CODE","10674-0","HEPATITIS B SURFACE ANTIGEN")=""
        S @G@(MAP,"CODE","2093-3","CHOLESTEROL, TOTAL")=""
        S @G@(MAP,"CODE","12951-0","TRIGLYCERIDES")=""
        S @G@(MAP,"CODE","11268-0","STREPTOZYME")=""
        S @G@(MAP,"CODE","13217-5","CHLAMYDIA CULTURE")=""
        S @G@(MAP,"CODE","14463-4","CHLAMYDIA CULTURE")=""
        ; gmr allergies snomed to vuid
        S MAP="gmr-allergies"
        S @G@(MAP,"CODE",419474003,4636980)=""
        S @G@(MAP,"CODE",232347008,4637420)=""
        S @G@(MAP,"CODE",419263009,4636804)=""
        S @G@(MAP,"CODE",418689008,4637448)=""
        ;S @G@(MAP,"CODE",232350006) ; MITE POLEN
        S @G@(MAP,"CODE",300913006,4636953)=""
        S @G@(MAP,"CODE",424213003,4637407)=""
        S @G@(MAP,"CODE",91935009,4636971)=""
        S @G@(MAP,"CODE",91934008,4636976)=""
        S @G@(MAP,"CODE",417532002,4637301)=""
        S @G@(MAP,"CODE",300916003,4538971)=""
        S @G@(MAP,"CODE",91930004,4637287)=""
        S @G@(MAP,"CODE",420174000,4637435)=""
        S @G@(MAP,"CODE",425525006,4636665)=""
        S @G@(MAP,"CODE",714035009,4636951)=""
        ; rxnorm to vuid
        S MAP="rxnorm"
        S @G@(MAP,"CODE",1000097,4002480)=""
        S @G@(MAP,"CODE",313585,4012182)=""
        S @G@(MAP,"CODE",314153,4013783)=""
        S @G@(MAP,"CODE",692876,4025906)=""
        S @G@(MAP,"CODE",577154,4025018)=""
        S @G@(MAP,"CODE",860215,4003764)=""
        S @G@(MAP,"CODE",860221,4003765)=""
        S @G@(MAP,"CODE",151226,4024528)=""
        S @G@(MAP,"CODE",198029,4010104)=""
        S @G@(MAP,"CODE",198030,4010106)=""
        S @G@(MAP,"CODE",198031,4010105)=""
        S @G@(MAP,"CODE",198045,4001216)=""
        S @G@(MAP,"CODE",198046,4001218)=""
        S @G@(MAP,"CODE",198047,4001215)=""
        S @G@(MAP,"CODE",199888,4013030)=""
        S @G@(MAP,"CODE",199889,4013031)=""
        S @G@(MAP,"CODE",199890,4013032)=""
        S @G@(MAP,"CODE",205315,4013343)=""
        S @G@(MAP,"CODE",205316,4013342)=""
        S @G@(MAP,"CODE",250983,4013568)=""
        S @G@(MAP,"CODE",311975,4005637)=""
        S @G@(MAP,"CODE",312036,4001214)=""
        S @G@(MAP,"CODE",314119,4005636)=""
        S @G@(MAP,"CODE",317136,4001217)=""
        S @G@(MAP,"CODE",359817,4016739)=""
        S @G@(MAP,"CODE",359818,4016738)=""
        S @G@(MAP,"CODE",636671,4025534)=""
        S @G@(MAP,"CODE",636676,4025535)=""
        S @G@(MAP,"CODE",749289,4025532)=""
        S @G@(MAP,"CODE",749788,4025533)=""
        S @G@(MAP,"CODE",896100,4010112)=""
        S @G@(MAP,"CODE",966531,4017048)=""
        S @G@(MAP,"CODE",993503,4016940)=""
        S @G@(MAP,"CODE",993518,4017073)=""
        S @G@(MAP,"CODE",993536,4024749)=""
        S @G@(MAP,"CODE",993541,4026567)=""
        S @G@(MAP,"CODE",993550,4029871)=""
        S @G@(MAP,"CODE",993557,4026568)=""
        S @G@(MAP,"CODE",993567,4029870)=""
        S @G@(MAP,"CODE",993681,4029872)=""
        S @G@(MAP,"CODE",998671,4002473)=""
        S @G@(MAP,"CODE",998675,4002474)=""
        S @G@(MAP,"CODE",998679,4002475)=""
        N ZI
        S ZI=""
        F  S ZI=$O(@G@(ZI)) Q:ZI=""  D  ;
        . N ZJ S ZJ=""
        . F  S ZJ=$O(@G@(ZI,"CODE",ZJ)) Q:ZJ=""  D  ;
        . . N VAL
        . . S VAL=$O(@G@(ZI,"CODE",ZJ,""))
        . . S @G@(ZI,"VALUE",VAL,ZJ)=""
        . . S @G@("CODE",ZJ,VAL,ZI)=""
        . . S @G@("VALUE",VAL,ZJ,ZI)=""
        Q
        ;
MAP(CDE,MAP)    ; extrinsic returns the Value for the Code in map MAP, which is optional
        N RTN
        N GN S GN=$NA(^XTMP("SYNQLD","MAPS"))
        I '$D(@GN) D INITMAPS
        I $G(CDE)="" Q ""
        I $G(MAP)="" D  Q RTN
        . S RTN=$O(@GN@("CODE",CDE,""))
        I '$D(@GN@(MAP)) S RTN="" Q RTN  ;
        S RTN=$O(@GN@(MAP,"CODE",CDE,""))
        I $O(@GN@(MAP,"CODE",CDE,RTN))'="" S RTN=-1 ; more than one match
        Q RTN
        ;
UNMAP(VAL,MAP)  ; extrinsic returns the Value for the Code in map MAP, which is optional
        N RTN
        N GN S GN=$NA(^XTMP("SYNQLD","MAPS"))
        I '$D(MAP) D  Q RTN
        . S RTN=$O(@GN@("VALUE",VAL,""))
        I '$D(@GN@(MAP)) S RTN="" Q  ;
        S RTN=$O(@GN@(MAP,"VALUE",VAL,""))
        I $O(@GN@(MAP,"VALUE",VAL,RTN))'="" S RTN=-1 ; more than one match
        Q RTN
        ;
GETMAP(RTN,MAP) ; returns an array of the MAP. if MAP is not specified, it returns an
        ; array of the names of all the maps
        N GN S GN=$NA(^XTMP("SYNQLD","MAPS"))
        I '$D(MAP) D  Q  ;
        . N ZI S ZI=""
        . F  S ZI=$O(@GN@(ZI)) Q:ZI=""  D  ;
        . . Q:ZI="CODE"
        . . Q:ZI="VALUE"
        . . S @RTN@(ZI)=""
        I $D(@GN@(MAP)) M @RTN=@GN@(MAP)
        Q
        ;

SYNVPR
SYNVPR  ; GPL - VPR viewing routines ; 2/24/18 4:39am
        ;;0.1;QRDA LOADER;nopatch;noreleasedate;Build 2
        ;
        ; Authored by George P. Lilly 2013-2018
        ;
        Q
        ;
SELPART()       ; extrinsic which returns the part of the VPR selected
        N ZT
        S ZT(1)="all"
        S ZT(2)="demographics"
        S ZT(3)="reactions"
        S ZT(4)="problems"
        S ZT(5)="vitals"
        S ZT(6)="labs"
        S ZT(7)="meds"
        S ZT(8)="immunizations"
        S ZT(9)="observation"
        S ZT(10)="visits"
        S ZT(11)="appointments"
        S ZT(12)="documents"
        S ZT(13)="procedures"
        S ZT(14)="consults"
        S ZT(15)="flags"
        S ZT(16)="factors"
        S ZT(17)="skinTests"
        S ZT(18)="exams"
        S ZT(19)="education"
        S ZT(20)="insurance"
        K DIR
        S DIR(0)="SO^"
        F ZI=1:1:20 S DIR(0)=DIR(0)_ZI_":"_ZT(ZI)_";"
        S DIR("B")=1
        S DIR("L")="Please select clinical category to view: "
        S DIR("L",1)="1 all          6 labs          11 appointments 16 factors"
        S DIR("L",2)="2 demographics 7 meds          12 documents    17 skinTests"
        S DIR("L",3)="3 reactions    8 immunizations 13 procedures   18 exams"
        S DIR("L",4)="4 problems     9 observation   14 consults     19 education"
        S DIR("L",5)="5 vitals       10 visits       15 flags        20 insurance"
        D ^DIR
        Q ZT(X)
        ;
SELPART2()      ; extrinsic which returns the part of the NHIN extract selected
        N ZT
        S ZT(1)="all"
        S ZT(2)="patient"
        S ZT(3)="allergy"
        S ZT(4)="problem"
        S ZT(5)="vital"
        S ZT(6)="lab"
        S ZT(7)="med"
        S ZT(8)="immunization"
        S ZT(9)="visit"
        S ZT(10)="appointment"
        S ZT(11)="procedure"
        K DIR
        S DIR(0)="SO^"
        F ZI=1:1:11 S DIR(0)=DIR(0)_ZI_":"_ZT(ZI)_";"
        S DIR("B")=1
        S DIR("L")="Please select clinical category to view: "
        S DIR("L",1)="1 all      6 lab          11 procedure"
        S DIR("L",2)="2 patient  7 med          "
        S DIR("L",3)="3 allergy  8 immunization"
        S DIR("L",4)="4 problems 9 visit"
        S DIR("L",5)="5 vitals   10 appointment"
        D ^DIR
        Q ZT(X)
        ;
gen     
        S G="all;demographics;reactions;problems;vitals;labs;meds;immunizations;observation;visits;appointments;documents;procedures;consults;flags;factors;skinTests;exams;education;insurance"
        S ZI=""
        F ZI=1:1 Q:$P(G,";",ZI)=""  D  ;
        . W !," S ZT("_ZI_")="""_$P(G,";",ZI)_""""
        q
        ;
gen2    
        S G="all;patient;allergy;problem;vital;lab;med;immunization;visit;appointment;procedure"
        S ZI=""
        F ZI=1:1 Q:$P(G,";",ZI)=""  D  ;
        . W !," S ZT("_ZI_")="""_$P(G,";",ZI)_""""
        q
        ;
PAT()   ; extrinsic which returns a dfn from the patient selected
        S DIC=2,DIC(0)="AEMQ" D ^DIC
        I Y<1 Q  ; EXIT
        S DFN=$P(Y,U,1) ; SET THE PATIENT
        Q +Y
        ;
tree(where,prefix,docid,zout)     ; show a tree starting at a node in MXML. 
        ; node is passed by name
        ; 
        i $g(prefix)="" s prefix="|--" ; starting prefix
        i '$d(SYNJOB) s SYNJOB=$J
        n node s node=$na(^TMP("MXMLDOM",SYNJOB,docid,where))
        n txt s txt=$$CLEAN($$ALLTXT(node))
        w:'$G(DIQUIET) !,prefix_@node_" "_txt
        d oneout(zout,prefix_@node_" "_txt)
        n zi s zi=""
        f  s zi=$o(@node@("A",zi)) q:zi=""  d  ;
        . w:'$G(DIQUIET) !,prefix_"  : "_zi_"^"_$g(@node@("A",zi))
        . d oneout(zout,prefix_"  : "_zi_"^"_$g(@node@("A",zi)))
        f  s zi=$o(@node@("C",zi)) q:zi=""  d  ;
        . d tree(zi,"|  "_prefix,docid,zout)
        q
        ;
oneout(zbuf,ztxt)       ; adds a line to zbuf
        n zi s zi=$o(@zbuf@(""),-1)+1
        s @zbuf@(zi)=ztxt
        q
        ;
ALLTXT(where)     ; extrinsic which returns all text lines from the node .. concatinated 
        ; together
        n zti s zti=""
        n ztr s ztr=""
        f  s zti=$o(@where@("T",zti)) q:zti=""  d  ;
        . s ztr=ztr_$g(@where@("T",zti))
        q ztr
        ;
CLEAN(STR)           ; extrinsic function; returns string - gpl borrowed from the CCR package
        ;; Removes all non printable characters from a string.
        ;; STR by Value
        N TR,I
        F I=0:1:31 S TR=$G(TR)_$C(I)
        S TR=TR_$C(127)
        N ZR S ZR=$TR(STR,TR)
        S ZR=$$LDBLNKS(ZR) ; get rid of leading blanks
        QUIT ZR
        ;
LDBLNKS(st)         ; extrinsic which removes leading blanks from a string
        n pos f pos=1:1:$l(st)  q:$e(st,pos)'=" "
        q $e(st,pos,$l(st))
        ;
show(what,docid,zout)     ;
        I '$D(C0XJOB) S C0XJOB=$J
        d tree(what,,docid,zout)
        q
        ; 
GET(ZRTN,ZDFN,ZTYP)     
        I ZTYP="all" S ZTYP=""
        D GET^VPRD(.ZRTN,ZDFN,ZTYP,,$$NOW^XLFDT)
        Q
        ;
GET2(ZRTN,ZDFN,ZTYP)    
        I ZTYP="all" S ZTYP=""
        ;D GET^VPRD(.ZRTN,ZDFN,ZTYP)
        D GET^KBAINHIN(.ZRTN,ZDFN,ZTYP) ; CALL NHINV ROUTINES TO PULL XML
        Q
        ;
PARSE(INXML)    ; 
        K ^TMP("MXMLERR",$J)
        Q $$EN^MXMLDOM(INXML,"W")
        ;
VPR     ;
        N ZDFN,ZTYPE
        ;N ZTMP
        S ZDFN=$$PAT()
        S ZTYPE=$$SELPART()
        D GET(.ZTMP,ZDFN,ZTYPE)
        N DOCID
        S DOCID=$$PARSE(.ZTMP)
        S GN=$NA(^TMP("VPROUT",$J))
        D show(1,DOCID,GN)
        D BROWSE^DDBR(GN,"N","PATIENT "_ZDFN_" "_ZTYPE)
        K @GN,^TMP("MXMLDOM",$J),^TMP("VPR",$J),GN
        q
        ;
wsVPR(VPR,FILTER)       ; get from web service call
        I '$D(DT) N DIQUIET S DIQUIET=1 D DT^DICRW
        N ZDFN,ZTYPE
        ;N ZTMP
        S ZDFN=$G(FILTER("patientId"))
        I ZDFN="" S ZDFN=$G(FILTER("patientID"))
        I ZDFN="" S ZDFN=$G(FILTER("patientid"))
        I ZDFN="" S ZDFN=$G(FILTER("dfn"))
        I ZDFN="" D  ;
        . N ICN S ICN=$G(FILTER("icn"))
        . I ICN="" Q  ;
        . S ZDFN=$O(^DPT("AFICN",ICN,""))
        I ZDFN="" D  ; try ien
        . N IEN S IEN=$G(FILTER("ien"))
        . I IEN="" Q  ;
        . S ZDFN=$$ien2dfn^SYNFUTL(IEN)
        I ZDFN="" S ZDFN=2
        S ZTYPE=$G(FILTER("domain"),"all")
        D GET(.ZTMP,ZDFN,ZTYPE)
        I $G(FILTER("format"))="xml" D  Q  ;
        . S HTTPRSP("mime")="text/xml"
        . M VPR=ZTMP
        N DOCID
        S DOCID=$$PARSE(.ZTMP)
        S HTTPRSP("mime")="text/html"
        S VPR=$NA(^TMP("VPROUT",$J))
        K @VPR
        S @VPR="<!DOCTYPE HTML><html><head></head><body><pre>"
        D show(1,DOCID,VPR)
        S @VPR@($O(@VPR@(""),-1)+1)="</pre></body></html>"
        D ADDCRLF^VPRJRUT(.VPR)
        ;D BROWSE^DDBR(GN,"N","PATIENT "_ZDFN_" "_ZTYPE)
        ;K @GN,^TMP("MXMLDOM",$J),^TMP("VPR",$J),GN
        q
        ;
NHIN    ;
        N ZDFN,ZTYPE
        ;N ZTMP
        S ZDFN=$$PAT()
        S ZTYPE=$$SELPART2()
        D GET2(.ZTMP,ZDFN,ZTYPE)
        N DOCID
        S DOCID=$$PARSE(.ZTMP)
        S GN=$NA(^TMP("VPROUT",$J))
        D show(1,DOCID,GN)
        D BROWSE^DDBR(GN,"N","PATIENT "_ZDFN_" "_ZTYPE)
        K @GN,^TMP("MXMLDOM",$J),^TMP("VPR",$J),GN
        q
        ;
LABS    ;
        S DFN=$$PAT()
        K OUT
        D LIST^C0CLABS
        S GN=$NA(^TMP("VPROUT",$J))
        K @GN
        M @GN=OUT
        D BROWSE^DDBR(GN,"N","PATIENT "_DFN_" LABS FROM CCR PACKAGE")
        K @GN
        Q
        ; 
CCRXML  ;
        S DFN=$$PAT()
        K OUT
        D CCRRPC^C0CCCR(.OUT,DFN)
        S GN=$NA(^TMP("VPROUT",$J))
        K @GN
        M @GN=OUT
        D BROWSE^DDBR(GN,"N","PATIENT "_DFN_" CCR XML")
        K @GN
        Q
        ; 
CCR     ;
        S DFN=$$PAT()
        N ZTMP
        D CCRRPC^C0CCCR(.ZTMP,DFN)
        K ZTMP(0)
        N ZCCR S ZCCR=$NA(^TMP("SYNVPR","CCR"))
        K @ZCCR
        M @ZCCR=ZTMP
        N DOCID
        S DOCID=$$PARSE(ZCCR)
        I $D(^TMP("MXMLERR",$J)) D  ;
        . ;ZWR ^TMP("MXMLERR",$J,*)
        . B  
        I DOCID=0 B  ;
        S GN=$NA(^TMP("VPROUT",$J))
        K @GN
        D show(1,DOCID,GN)
        D BROWSE^DDBR(GN,"N","PATIENT "_DFN_" CCR XML")
        K @GN,@ZCCR
        Q
        ; 
CCDA    ;
        S DFN=$$PAT()
        N ZTMP
        D CCDARPC^KBAICDA(.ZTMP,DFN)
        K ZTMP(0)
        N ZCCDA S ZCCDA=$NA(^TMP("SYNVPR",$J,"CCDA"))
        K @ZCCDA
        M @ZCCDA=@ZTMP
        N DOCID
        S DOCID=$$PARSE(ZCCDA)
        I $D(^TMP("MXMLERR",$J)) D  ;
        . ;ZWR ^TMP("MXMLERR",$J,*)
        . B  
        I DOCID=0 B  ;
        S GN=$NA(^TMP("VPROUT",$J))
        K @GN
        D show(1,DOCID,GN)
        D BROWSE^DDBR(GN,"N","PATIENT "_DFN_" CCDA XML")
        K @GN,@ZCCDA
        Q
        ; 
listm(out,in)   ; out is passed by name in is passed by reference
        n i s i=$q(@in@(""))
        f  s i=$q(@i) q:i=""  d oneout^SYNVPR(out,i_"="_@i)
        q
        ;
SMART   ; 
        S DFN=$$PAT()
        S ZTYPE=$$SELPART2()
        K G,OUT
        D EN^C0SMART(.G,DFN,ZTYPE,"raw")
        S GN=$NA(^TMP("SYNOUT",$J))
        K @GN
        D listm(GN,"G")
        D BROWSE^DDBR(GN,"N","PATIENT "_DFN_" SMART MUMPS ARRAY")
        K @GN,G,OUT
        Q 
        ;
SMARTRDF        ; 
        S DFN=$$PAT()
        S ZTYPE=$$SELPART2()
        K G,OUT
        D EN^C0SMART(.G,DFN,ZTYPE,"rdf")
        N ZRDF S ZRDF=$NA(^TMP("SYNVPR","RDF"))
        K @ZRDF
        M @ZRDF=G
        N DOCID
        S DOCID=$$PARSE(ZRDF)
        I $D(^TMP("MXMLERR",$J)) D  ;
        . ;ZWR ^TMP("MXMLERR",$J,*)
        . B  
        I DOCID=0 B  ;
        S GN=$NA(^TMP("VPROUT",$J))
        K @GN
        D show(1,DOCID,GN)
        D BROWSE^DDBR(GN,"N","PATIENT "_DFN_" RDF XML")
        K @GN,@ZRDF
        Q 
        ;
VPRM    ;
        N ZDFN,ZTYPE
        N ZTMP
        S ZDFN=$$PAT()
        S ZTYPE=$$SELPART()
        D GETPAT^SYNVPRE(.ZTMP,ZDFN,ZTYPE)
        S GN=$NA(^TMP("VPROUT",$J))
        K @GN
        D listm(GN,"ZTMP")
        D BROWSE^DDBR(GN,"N","PATIENT "_ZDFN_" "_ZTYPE)
        K @GN,^TMP("VPR",$J),GN
        q
        ;
wsGLOBAL(OUT,FILTER)    ; dump a global to the browser as an html page
        I '$D(DT) N DIQUIET S DIQUIET=1 D DT^DICRW
        S HTTPRSP("mime")="text/html"
        S OUT=$NA(^TMP("SYNOUT",$J))
        K @OUT
        N ROOT S ROOT=$G(FILTER("root"))
        Q:ROOT=""
        I $G(FILTER("local"))'=1 S ROOT="^"_ROOT
        N ORIG,OL S ORIG=ROOT,OL=$QL(ROOT) ; Orig, Orig Length
        F  S ROOT=$Q(@ROOT) Q:$G(ROOT)=""  Q:$NA(@ROOT,OL)'=$NA(@ORIG,OL)  D
        . S @OUT@($O(@OUT@(""),-1)+1)=ROOT_"="_$$CLEAN(@ROOT)
        S @OUT="<!DOCTYPE HTML><html><head></head><body><pre>"
        S @OUT@($O(@OUT@(""),-1)+1)="</pre></body></html>"
        D ADDCRLF^VPRJRUT(.OUT)
        Q
        ;
GTREE(ROOT,DEPTH,PREFIX,LVL)    ; show a global in a tree
        I $G(PREFIX)="" S PREFIX="|--" ; STARTING PREFIX
        I '$D(DEPTH) S DEPTH=1 ; USUALLY THIS IS WHAT WE WANT
        I +$G(LVL)>DEPTH Q  ; ONLY GO THAT DEEP
        N ZGI S ZGI=""
        N ZVAL S ZVAL=$G(@ROOT)
        I $G(LVL)="" W !,ROOT_" "_$G(@ROOT@(0))
        F  S ZGI=$O(@ROOT@(ZGI)) Q:ZGI=""  D  ;
        . I $O(@ROOT@(ZGI,""))'="" D  ;
        . . I $G(@ROOT@(ZGI))'="" W !,PREFIX_ZGI_" ",@ROOT@(ZGI)
        . . E  W !,PREFIX_ZGI_" ",$G(@ROOT@(ZGI,0))
        . E  W !,PREFIX_ZGI_" "_$G(@ROOT@(ZGI))
        . D GTREE($NA(@ROOT@(ZGI)),DEPTH,"|  "_PREFIX,+$G(LVL)+1)
        Q
        ; 



